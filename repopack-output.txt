This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-29T14:30:03.188Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
config/
  __init__.py
  config.development.yaml
  config.production.yaml
  manager.py
data/
  official_prices.json
src/
  apple_scraper_for_rudea.py
  apple_scraper.py
templates/
  index.html
tests/
  integration/
    test_config_integration.py
  unit/
    test_validators.py
  conftest.py
  pytest.ini
  test_config_manager.py
.env.example
.gitignore
.python-version
.render.yaml
app.py
Procfile
README.md
renovate.json
requirements.txt

================================================================
Repository Files
================================================================

================
File: config/__init__.py
================
from .manager import AppConfig, ConfigManager, ScraperConfig, config

__all__ = ['AppConfig', 'ConfigManager', 'ScraperConfig', 'config']

================
File: config/config.development.yaml
================
app:
  debug: true
  log_level: DEBUG
  secret_key: dev-secret-key

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 30
  retry_count: 3
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'

================
File: config/config.production.yaml
================
app:
  debug: false
  log_level: INFO
  # secret_keyは環境変数から取得するため、ここには記載しない

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 60
  retry_count: 5
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'

================
File: config/manager.py
================
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Literal, Optional, Union
from urllib.parse import urlparse

import yaml
from dotenv import load_dotenv


@dataclass(frozen=True)
class ScraperConfig:
    """スクレイピング関連の設定を管理するデータクラス"""
    KAITORI_RUDEA_URLS: list  # 複数形に変更し、型をlistに
    APPLE_STORE_URL: str
    REQUEST_TIMEOUT: int
    RETRY_COUNT: int
    USER_AGENT: str

    # ScraperConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_urls()
        self._validate_timeout()
        self._validate_retry_count()
        # 型チェック
        if not isinstance(self.KAITORI_RUDEA_URLS, list):
            raise TypeError("KAITORI_RUDEA_URLS must be a list of strings")
        if not isinstance(self.APPLE_STORE_URL, str):
            raise TypeError("APPLE_STORE_URL must be a string")
        if not isinstance(self.REQUEST_TIMEOUT, int):
            raise TypeError("REQUEST_TIMEOUT must be an integer")
        if not isinstance(self.RETRY_COUNT, int):
            raise TypeError("RETRY_COUNT must be an integer")
        if not isinstance(self.USER_AGENT, str):
            raise TypeError("USER_AGENT must be a string")

    def _validate_urls(self) -> None:
        """URLの形式を検証"""
        for url in self.KAITORI_RUDEA_URLS + [self.APPLE_STORE_URL]:
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                raise ValueError(f"Invalid URL format: {url}")

    def _validate_timeout(self) -> None:
        """タイムアウト値の検証"""
        if not isinstance(self.REQUEST_TIMEOUT, int) or self.REQUEST_TIMEOUT <= 0:
            raise ValueError(f"REQUEST_TIMEOUT must be a positive integer, got {self.REQUEST_TIMEOUT}")

    def _validate_retry_count(self) -> None:
        """リトライ回数の検証"""
        if not isinstance(self.RETRY_COUNT, int) or self.RETRY_COUNT < 0:
            raise ValueError(f"RETRY_COUNT must be a non-negative integer, got {self.RETRY_COUNT}")

@dataclass(frozen=True)
class AppConfig:
    """アプリケーション全体の設定を管理するデータクラス"""
    DEBUG: bool
    SECRET_KEY: str
    LOG_LEVEL: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
    # AppConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_secret_key()
        self._validate_log_level()
        # 型チェック
        if not isinstance(self.DEBUG, bool):
            raise TypeError("DEBUG must be a boolean")
        if not isinstance(self.SECRET_KEY, str):
            raise TypeError("SECRET_KEY must be a string")
        if not isinstance(self.LOG_LEVEL, str):
            raise TypeError("LOG_LEVEL must be a string")

    def _validate_secret_key(self) -> None:
        """シークレットキーの検証"""
        if not self.SECRET_KEY or len(self.SECRET_KEY) < 16:
            raise ValueError("SECRET_KEY must be at least 16 characters long")

    def _validate_log_level(self) -> None:
        """ログレベルの検証"""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if self.LOG_LEVEL not in valid_levels:
            raise ValueError(f"LOG_LEVEL must be one of {valid_levels}")

class ConfigManager:
    """設定を一元管理するクラス"""
    def __init__(self, config_dir=None):
        self._config: Optional[dict] = None
        self._scraper_config: Optional[ScraperConfig] = None
        self._app_config: Optional[AppConfig] = None
        
        self.load_environment()
        self.load_config_file(config_dir)

    def load_environment(self) -> None:
        """環境変数を読み込む"""
        load_dotenv()
        self.env: str = os.getenv('FLASK_ENV', 'development')
        
    def load_config_file(self, config_dir=None) -> None:
        """設定ファイルを読み込む"""
        if config_dir is None:
            config_dir = Path(__file__).parent
        else:
            config_dir = Path(config_dir)
        
        config_file = config_dir / f'config.{self.env}.yaml'
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
            
        with open(config_file, 'r') as f:
            self._config = yaml.safe_load(f)

    @property
    def scraper(self) -> ScraperConfig:
        """スクレイピング設定を取得"""
        if self._scraper_config is None:
            self._scraper_config = ScraperConfig(
                KAITORI_RUDEA_URLS=self._config['scraper']['kaitori_rudea_urls'],
                APPLE_STORE_URL=self._config['scraper']['apple_store_url'],
                REQUEST_TIMEOUT=self._config['scraper']['request_timeout'],
                RETRY_COUNT=self._config['scraper']['retry_count'],
                USER_AGENT=self._config['scraper']['user_agent']
            )
        return self._scraper_config

    @property
    def app(self) -> AppConfig:
        """アプリケーション設定を取得"""
        if self._app_config is None:
            self._app_config = AppConfig(
                DEBUG=self._config['app']['debug'],
                SECRET_KEY=os.getenv('SECRET_KEY', 'default-secret-key'),
                LOG_LEVEL=self._config['app']['log_level']
            )
        return self._app_config

# シングルトンインスタンスを作成
config = ConfigManager()

================
File: data/official_prices.json
================
{
  "iPhone 16": {
    "128GB": {
      "black 黒 MYDQ3J/A 未開封 SIMフリー": 124800,
      "pink 桃 MYDT3J/A 未開封 SIMフリー": 124800,
      "teal 緑 MYDV3J/A 未開封 SIMフリー": 124800,
      "ultramarine 青 MYDU3J/A 未開封 SIMフリー": 124800,
      "white 白 MYDR3J/A 未開封 SIMフリー": 124800
    },
    "256GB": {
      "black 黒 MYDW3J/A 未開封 SIMフリー": 139800,
      "pink 桃 MYDY3J/A 未開封 SIMフリー": 139800,
      "teal 緑 MYDZ3J/A 未開封 SIMフリー": 139800,
      "ultramarine 青 MYDX3J/A 未開封 SIMフリー": 139800,
      "white 白 MYDW3J/A 未開封 SIMフリー": 139800
    },
    "512GB": {
      "black 黒 MYDQ3J/A 未開封 SIMフリー": 169800,
      "pink 桃 MYDT3J/A 未開封 SIMフリー": 169800,
      "teal 緑 MYDV3J/A 未開封 SIMフリー": 169800,
      "ultramarine 青 MYDU3J/A 未開封 SIMフリー": 169800,
      "white 白 MYDR3J/A 未開封 SIMフリー": 169800
    }
  },
  "iPhone 16 Pro": {
    "128GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 161000,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 161000,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 161000,
      "white 白 MYWK3J/A 未開封 SIMフリー": 161000
    },
    "256GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 177500,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 177500,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 177500,
      "white 白 MYWK3J/A 未開封 SIMフリー": 177500
    },
    "512GB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 204000,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 204000,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 204000,
      "white 白 MYWR3J/A 未開封 SIMフリー": 204000
    },
    "1TB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 234000,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 234000,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 234000,
      "white 白 MYWR3J/A 未開封 SIMフリー": 234000
    }
  },
  "iPhone 16 Pro Max": {
    "256GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 189800,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 189800,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 189800,
      "white 白 MYWK3J/A 未開封 SIMフリー": 189800
    },
    "512GB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 219800,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 219800,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 219800,
      "white 白 MYWR3J/A 未開封 SIMフリー": 219800
    },
    "1TB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 249800,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 249800,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 249800,
      "white 白 MYWR3J/A 未開封 SIMフリー": 249800
    }
  }
}

================
File: src/apple_scraper_for_rudea.py
================
import logging
from playwright.sync_api import sync_playwright
from config import config

logger = logging.getLogger(__name__)

def get_kaitori_prices():
    """買取価格を取得する関数"""
    all_product_details = {
        'iPhone 16': {},
        'iPhone 16 Pro': {},
        'iPhone 16 Pro Max': {}
    }
    
    with sync_playwright() as p:
        try:
            browser = p.chromium.launch(chromium_sandbox=False)
            page = browser.new_page()
            
            for url in config.scraper.KAITORI_RUDEA_URLS:
                page.goto(url)
                page.wait_for_load_state('networkidle')

                items = page.query_selector_all('.tr')
                
                for item in items:
                    try:
                        model_element = item.query_selector('.ttl h2')
                        model_name = model_element.inner_text().strip() if model_element else ""
                        
                        # モデル名からシリーズを判定
                        if 'Pro Max' in model_name:
                            series = 'iPhone 16 Pro Max'
                        elif 'Pro' in model_name:
                            series = 'iPhone 16 Pro'
                        elif '16' in model_name:
                            series = 'iPhone 16'
                        else:
                            continue  # 対象外のモデルはスキップ

                        price_element = item.query_selector('.td.td2 .td2wrap')
                        price_text = price_element.inner_text().strip() if price_element else ""

                        if model_name and price_text and '円' in price_text:
                            all_product_details[series][model_name] = price_text
                    except Exception as e:
                        logger.error(f"データ取得エラー: {str(e)}")
                        continue

            return all_product_details
            
        except Exception as e:
            logger.error(f"スクレイピングエラー: {str(e)}")
            raise
            
        finally:
            browser.close()

if __name__ == '__main__':
    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 価格取得テスト
    prices = get_kaitori_prices()
    for series, models in prices.items():
        for model, price in models.items():
            print(f"シリーズ: {series} | モデル: {model} | 価格: {price}")

================
File: src/apple_scraper.py
================
import requests
from bs4 import BeautifulSoup

# iPhone 16, iPhone 16 Plusの購入ページURL
url_iphone16 = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16'
# iPhone 16 Pro, iPhone 16 Pro Maxの購入ページURL
url_iphone16_pro = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16-pro'

# ページから価格情報を取得する関数
def get_prices(url):
    # ページを取得
    response = requests.get(url)
    
    # レスポンスの内容を確認
    print(response.text)  # ここでHTMLの内容を表示
    
    # BeautifulSoupでHTML解析
    soup = BeautifulSoup(response.text, 'html.parser')

    # 価格情報を取得するためのセレクタ
    prices = soup.select('span.price-point.price-point-fullPrice > span.nowrap')

    # 取得した価格情報をリストに格納
    price_list = [price.get_text() for price in prices]
    return price_list

# iPhone 16シリーズの価格取得
print("iPhone 16シリーズの価格:")
iphone16_prices = get_prices(url_iphone16)
for price in iphone16_prices:
    print(price)

# iPhone 16 Proシリーズの価格取得
print("\niPhone 16 Proシリーズの価格:")
iphone16_pro_prices = get_prices(url_iphone16_pro)
for price in iphone16_pro_prices:
    print(price)

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPhone 16シリーズ 買取価格比較</title>
    <style>
      /* ローディングスピナーのスタイル */
      .loader {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #priceTable {
        display: none;
      }

      .tables-container {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }

      .price-table {
        border-collapse: collapse;
        min-width: 400px;
      }

      .price-table caption {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .price-table th, .price-table td {
        padding: 8px 15px;
        border: 1px solid #ddd;
        text-align: left;
      }

      .price-table th {
        background-color: #f2f2f2;
      }

      .price-table td:last-child {
        text-align: right;
      }

      .price-table td[style*="color: green"] {
        font-weight: bold;
      }

      .price-table td[style*="color: red"] {
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>iPhone 16シリーズ 買取価格比較</h1>

    <!-- ローディング中の表示 -->
    <div id="loading">
      <div class="loader"></div>
      <p>Loading（読み込み中）...</p>
    </div>

    <!-- エラーメッセージ表示エリア -->
    <div id="error-message" style="display: none; color: red"></div>

    <!-- 価格テーブル -->
    <div id="priceTablesContainer" class="tables-container" style="display: none;"></div>

    <script>
      // ページが読み込まれた時に価格データを取得する
      document.addEventListener('DOMContentLoaded', function () {
        // ローディング表示
        document.getElementById('loading').style.display = 'block';
        document.getElementById('priceTablesContainer').style.display = 'none';

        // データを非同期で取得
        fetch('/get_prices')
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              console.error('Error:', data.error);
              document.getElementById('loading').innerHTML = 'エラーが発生しました。詳細はコンソールを確認してください。';
            } else {
              const container = document.getElementById('priceTablesContainer');
              container.innerHTML = '';

              // シリーズの順序を指定
              const seriesOrder = ['iPhone 16', 'iPhone 16 Pro', 'iPhone 16 Pro Max'];
              
              // 指定された順序でテーブルを作成
              seriesOrder.forEach(seriesName => {
                if (data[seriesName]) {
                  const table = document.createElement('table');
                  table.className = 'price-table';
                  
                  // テーブルのキャプション（シリーズ名）を追加
                  const caption = table.createCaption();
                  caption.textContent = seriesName;

                  // ヘッダー行を更新
                  const headerRow = table.insertRow();
                  headerRow.innerHTML = `
                    <th>容量</th>
                    <th>カラー別買取価格</th>
                    <th>公式価格</th>
                    <th>収支（最小～最大）</th>
                  `;

                  // データ行を作成
                  for (const [capacity, details] of Object.entries(data[seriesName])) {
                    const row = table.insertRow();
                    
                    // 価格をフォーマットする関数
                    const formatPrice = (price) => {
                      if (price === null || price === undefined) return '-';
                      return new Intl.NumberFormat('ja-JP', {
                        style: 'currency',
                        currency: 'JPY'
                      }).format(price);
                    };

                    // 収支の色を決定する関数
                    const getProfitColor = (profit) => {
                      if (profit === null || profit === undefined) return '';
                      return profit >= 0 ? 'color: green;' : 'color: red;';
                    };

                    // カラー別価格のHTML生成
                    const colorPricesHtml = Object.entries(details.colors)
                      .map(([color, colorDetails]) => `${color}: ${colorDetails.price_text}`)
                      .join('<br>');

                    // 収支範囲の表示を生成
                    const profitRangeHtml = details.profit_min !== null && details.profit_max !== null
                      ? `<span style="${getProfitColor(details.profit_min)}">${formatPrice(details.profit_min)}</span>
                         ～
                         <span style="${getProfitColor(details.profit_max)}">${formatPrice(details.profit_max)}</span>`
                      : '-';

                    row.innerHTML = `
                      <td>${capacity}</td>
                      <td>${colorPricesHtml}</td>
                      <td>${formatPrice(details.official_price)}</td>
                      <td>${profitRangeHtml}</td>
                    `;
                  }

                  container.appendChild(table);
                }
              });

              // ローディングを非表示にしてテーブルを表示
              document.getElementById('loading').style.display = 'none';
              document.getElementById('priceTablesContainer').style.display = 'flex';
            }
          })
          .catch(error => {
            console.error('Fetch error:', error);
            document.getElementById('loading').innerHTML = 'データの取得中にエラーが発生しました。';
          });
      });

      // ブラウザ拡張機能のエラーハンドリング
      window.addEventListener('error', function (event) {
        if (event.error && event.error.message.includes('runtime.lastError')) {
          console.warn('Browser extension error:', event.error.message);
          document.getElementById('error-message').textContent =
            'ブラウザ拡張機能の動作に問題が発生しています。拡張機能を無効にしてみてください。';
          document.getElementById('error-message').style.display = 'block';
        }
      });
    </script>
  </body>
</html>

================
File: tests/integration/test_config_integration.py
================
from pathlib import Path

import pytest

from config import ConfigManager


def test_config_environment_integration(mock_env_vars, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 環境変数からの値
    assert config.app.SECRET_KEY == mock_env_vars["SECRET_KEY"]
    
    # 設定ファイルからの値
    assert isinstance(config.app.DEBUG, bool)
    assert config.app.LOG_LEVEL in ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

def test_scraper_config_integration(mock_env_vars, test_config_file):
    """スクレイパー設定の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    assert config.scraper.REQUEST_TIMEOUT > 0
    assert config.scraper.RETRY_COUNT >= 0
    assert all("http" in url for url in config.scraper.KAITORI_RUDEA_URLS)
    assert "http" in config.scraper.APPLE_STORE_URL

# ConfigManager の統合テスト: 設定ファイルと環境変数が正しく統合されるか確認
def test_config_integration_with_file_and_env(monkeypatch, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    monkeypatch.setenv("FLASK_ENV", "testing")
    monkeypatch.setenv("SECRET_KEY", "env-secret-key-16ch")  # 16文字以上に変更
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 統合後の ConfigManager が正しく値を取得しているか確認
    assert config.app.SECRET_KEY == "env-secret-key-16ch"  # 環境変数が優先される
    assert config.app.DEBUG is True  # 設定ファイルから取得
    assert config.scraper.REQUEST_TIMEOUT == 30  # 設定ファイルから取得

# 設定ファイルが存在しない場合のテスト
def test_config_file_not_found():
    """設定ファイルが見つからない場合のエラーハンドリング"""
    # 存在しないディレクトリを指定して ConfigManager を初期化
    with pytest.raises(FileNotFoundError, match="Configuration file not found"):
        ConfigManager(config_dir="non_existent_directory")

def test_iphone16_pro_url_integration(mock_env_vars, test_config_file):
    """iPhone 16 Pro URLの統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 全てのiPhoneモデルのURLが含まれているか確認
    expected_urls = [
        "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
        "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
        "https://kaitori-rudeya.com/category/detail/186"   # iPhone 16 Pro Max
    ]
    
    # URLの数が正しいか確認
    assert len(config.scraper.KAITORI_RUDEA_URLS) == len(expected_urls)
    
    # 各URLが正しく含まれているか確認
    for url in expected_urls:
        assert url in config.scraper.KAITORI_RUDEA_URLS
        
    # URLの順序が正しいか確認
    assert config.scraper.KAITORI_RUDEA_URLS == expected_urls

================
File: tests/unit/test_validators.py
================
import pytest

from config import AppConfig, ScraperConfig
from config.manager import ConfigManager


class TestAppConfigValidation:
    def test_valid_app_config(self):
        """有効なアプリケーション設定のテスト"""
        config = AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="DEBUG"
        )
        assert config.DEBUG is True
        assert config.SECRET_KEY == "valid-secret-key-12345"
        assert config.LOG_LEVEL == "DEBUG"

    def test_invalid_secret_key(self):
        """無効なシークレットキーのテスト"""
        with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="short",
                LOG_LEVEL="DEBUG"
            )

    def test_invalid_log_level(self):
        """無効なログレベルのテスト"""
        with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="valid-secret-key-12345",
                LOG_LEVEL="INVALID"
            )

class TestScraperConfigValidation:
    def test_valid_scraper_config(self):
        """有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 1
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori"

    def test_invalid_url_format(self):
        """無効なURL形式のテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["invalid-url"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_invalid_timeout(self):
        """無効なタイムアウト値のテスト"""
        with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=0,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_valid_scraper_config_with_multiple_urls(self):
        """複数のURLを持つ有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori1", "https://example.com/kaitori2"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 2
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori1"
        assert config.KAITORI_RUDEA_URLS[1] == "https://example.com/kaitori2"

    def test_invalid_kaitori_rudea_urls(self):
        """無効なkaitori_rudea_urlsのテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com", "invalid-url"],
                APPLE_STORE_URL="https://example.com/apple",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

# 境界値テスト: REQUEST_TIMEOUT が 0 以下の場合はエラーを出す必要があります
def test_scraper_request_timeout_boundary():
    """REQUEST_TIMEOUT の境界値テスト"""
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=-1,  # 境界値（0 以下はエラー）
            RETRY_COUNT=1,
            USER_AGENT="Test Agent"
        )

# 無効な LOG_LEVEL を渡した場合のテスト
def test_app_log_level_invalid():
    """LOG_LEVEL が無効な場合のテスト"""
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        # LOG_LEVEL に無効な値 "INVALID" を指定し、エラーハンドリングを確認
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"  # 無効な LOG_LEVEL
        )

# SECRET_KEY が設定されていない場合、デフォルト値が使用されるかのテスト
def test_config_environment_with_missing_secret_key(monkeypatch):
    """SECRET_KEY が存在しない場合のテスト"""
    # SECRET_KEY を削除して、デフォルト値が設定されるか確認
    monkeypatch.delenv("SECRET_KEY", raising=False)
    config = ConfigManager()
    # デフォルトのシークレットキーが使用されるか確認
    assert config.app.SECRET_KEY == "default-secret-key"  # デフォルト値として設定されている

# FLASK_ENV が production の場合に正しく設定されるか確認
def test_config_environment_with_different_env(monkeypatch):
    """異なる FLASK_ENV のテスト"""
    # FLASK_ENV を production に設定
    monkeypatch.setenv("FLASK_ENV", "production")
    config = ConfigManager()
    # 環境が production になっているか確認
    assert config.env == "production"

# 無効な SECRET_KEY を渡した場合のエラーハンドリングテスト
def test_invalid_secret_key_length(monkeypatch):
    """SECRET_KEY が無効な場合のテスト"""
    monkeypatch.setenv("SECRET_KEY", "short")
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        config = ConfigManager()
        _ = config.app  # app プロパティにアクセスして初期化を強制

def test_config_manager_with_multiple_urls(monkeypatch, tmp_path):
    """複数のURLを持つConfigManagerのテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://test1.example.com/kaitori
        - https://test2.example.com/kaitori
      apple_store_url: https://test.example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 2
    assert "https://test1.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://test2.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS

def test_scraper_config_with_iphone16_pro_url():
    """iPhone 16 Pro URLを含むスクレイパー設定のテスト"""
    config = ScraperConfig(
        KAITORI_RUDEA_URLS=[
            "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
            "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
            "https://kaitori-rudeya.com/category/detail/186"   # iPhone 16 Pro Max
        ],
        APPLE_STORE_URL="https://example.com/apple",
        REQUEST_TIMEOUT=30,
        RETRY_COUNT=3,
        USER_AGENT="Test Agent"
    )
    assert len(config.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/185" in config.KAITORI_RUDEA_URLS

def test_config_manager_loads_iphone16_pro_url(mock_env_vars, tmp_path):
    """ConfigManagerがiPhone 16 Pro URLを正しく読み込むかテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://kaitori-rudeya.com/category/detail/183
        - https://kaitori-rudeya.com/category/detail/185
        - https://kaitori-rudeya.com/category/detail/186
      apple_store_url: https://example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch = mock_env_vars
    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS

================
File: tests/conftest.py
================
import pytest
from pathlib import Path
import shutil

@pytest.fixture(scope="function")
def mock_env_vars(monkeypatch):
    """環境変数をモックするフィクスチャ"""
    test_vars = {
        "FLASK_ENV": "testing",
        "SECRET_KEY": "test-secret-key-16ch",  # 16文字以上に変更
        "LOG_LEVEL": "DEBUG"
    }
    for key, value in test_vars.items():
        monkeypatch.setenv(key, value)
    return test_vars

@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    """テスト用の設定ファイルを作成するフィクスチャ"""
    config_content = """
app:
  debug: true
  log_level: DEBUG
  secret_key: test-secret-key-16

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183  # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185  # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186  # iPhone 16 Pro Max
  apple_store_url: https://test.example.com/apple
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    dest_dir.mkdir(exist_ok=True)
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

================
File: tests/pytest.ini
================
[pytest]
pythonpath = .
testpaths = tests
python_files = test_*.py
addopts = -v -s --cov=config --cov-report=term-missing

================
File: tests/test_config_manager.py
================
import sys
from pathlib import Path
import shutil
import pytest

# プロジェクトのルートディレクトリをPYTHONPATHに追加
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import pytest

from config import AppConfig, ConfigManager, ScraperConfig

@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    config_content = """
app:
  debug: true
  log_level: "DEBUG"

scraper:
  kaitori_rudea_urls:
    - "https://kaitori-rudeya.com/category/detail/183"  # iPhone 16
    - "https://kaitori-rudeya.com/category/detail/185"  # iPhone 16 Pro
    - "https://kaitori-rudeya.com/category/detail/186"  # iPhone 16 Pro Max
  apple_store_url: "https://example.com/apple"
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

def test_config_manager_initialization(mock_env_vars, test_config_file):
    """ConfigManagerの初期化テスト"""
    config = ConfigManager()
    assert config.env == "testing"
    assert isinstance(config.app, AppConfig)
    assert isinstance(config.scraper, ScraperConfig)

def test_app_config_validation():
    """AppConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="short",
            LOG_LEVEL="DEBUG"
        )
    
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"
        )

def test_scraper_config_validation():
    """ScraperConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="Invalid URL format"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["invalid-url"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
    
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=0,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )

def test_scraper_config_multiple_urls(mock_env_vars, test_config_file):
    """複数のkaitori_rudea_urlsを持つScraperConfigのテスト"""
    config = ConfigManager()
    assert isinstance(config.scraper.KAITORI_RUDEA_URLS, list)
    assert len(config.scraper.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/183" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/186" in config.scraper.KAITORI_RUDEA_URLS

================
File: .env.example
================
FLASK_ENV=development
SECRET_KEY=your-secret-key-here

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

================
File: .python-version
================
3.11.9

================
File: .render.yaml
================
# デプロイの設定を詳細に指定するためのファイルで、以下のような情報を設定可能
# ・ サービスの種類（web service、background jobなど）
# ・ 環境変数
# ・ ビルドコマンドやスタートコマンド
# ・ 自動デプロイの有無など

services:
  - type: web
    name: priceComparisonAppForIphone
    runtime: python
    buildCommand: |
      pip install -r requirements.txt
      playwright install chromium
      playwright install-deps
    startCommand: gunicorn app:app
    envVars:
      - key: PLAYWRIGHT_BROWSERS_PATH
        value: /home/render/.cache/ms-playwright
    env: python

================
File: app.py
================
import json
import logging
import os
import re
from pathlib import Path

from flask import Flask, jsonify, render_template
from playwright.sync_api import sync_playwright

from config import config


def create_app():
    app = Flask(__name__)
    
    # アプリケーション設定の適用
    app.config['DEBUG'] = config.app.DEBUG
    app.config['SECRET_KEY'] = config.app.SECRET_KEY
    
    # Playwrightのタイムアウト設定
    app.config['PLAYWRIGHT_TIMEOUT'] = config.scraper.REQUEST_TIMEOUT * 1000  # ミリ秒単位に変換
    
    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    return app

def load_official_prices():
    """公式価格データをJSONファイルから読み込む"""
    try:
        json_path = Path(__file__).parent / 'data' / 'official_prices.json'
        with open(json_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        app.logger.error(f"公式価格データの読み込みエラー: {str(e)}")
        return {}

def price_text_to_int(price_text):
    """価格テキストを整数に変換する"""
    try:
        # "123,456円" → 123456
        return int(price_text.replace('円', '').replace(',', ''))
    except (ValueError, AttributeError):
        return 0

def get_kaitori_prices():
    all_product_details = {
        'iPhone 16': {},
        'iPhone 16 Pro': {},
        'iPhone 16 Pro Max': {}
    }
    
    with sync_playwright() as p:
        browser = p.chromium.launch(chromium_sandbox=False)
        page = browser.new_page()
        
        for url in config.scraper.KAITORI_RUDEA_URLS:
            page.goto(url)
            page.wait_for_load_state('networkidle')

            items = page.query_selector_all('.tr')
            
            for item in items:
                try:
                    model_element = item.query_selector('.ttl h2')
                    model_name = model_element.inner_text().strip() if model_element else ""
                    
                    # モデル名からシリーズを判定
                    if 'Pro Max' in model_name:
                        series = 'iPhone 16 Pro Max'
                    elif 'Pro' in model_name:
                        series = 'iPhone 16 Pro'
                    elif '16' in model_name:
                        series = 'iPhone 16'
                    else:
                        continue
                    
                    # 容量を抽出（例: "128GB" または "1TB"）
                    capacity_match = re.search(r'(\d+)(GB|TB)', model_name)
                    if not capacity_match:
                        continue
                    capacity = capacity_match.group(0)  # "128GB" or "1TB"
                    
                    price_element = item.query_selector('.td.td2 .td2wrap')
                    price_text = price_element.inner_text().strip() if price_element else ""

                    if model_name and price_text and '円' in price_text:
                        # カラーを抽出（黒、白、桃、緑、青、金、灰など）
                        color_match = re.search(r'(黒|白|桃|緑|青|金|灰)', model_name)
                        color = color_match.group(1) if color_match else "不明"
                        
                        # 容量ごとのデータを初期化・更新
                        if capacity not in all_product_details[series]:
                            all_product_details[series][capacity] = {
                                'colors': {},
                                'kaitori_price_min': None,
                                'kaitori_price_max': None
                            }
                        
                        # 色ごとの価格を保存
                        price_value = price_text_to_int(price_text)
                        all_product_details[series][capacity]['colors'][color] = {
                            'price_text': price_text,
                            'price_value': price_value
                        }
                        
                        # 最小・最大価格を更新
                        current_min = all_product_details[series][capacity]['kaitori_price_min']
                        current_max = all_product_details[series][capacity]['kaitori_price_max']
                        
                        if current_min is None or price_value < current_min:
                            all_product_details[series][capacity]['kaitori_price_min'] = price_value
                        if current_max is None or price_value > current_max:
                            all_product_details[series][capacity]['kaitori_price_max'] = price_value
                            
                except Exception as e:
                    app.logger.error(f"データ取得エラー: {str(e)}")
                    continue

        browser.close()
    
    return all_product_details

# アプリケーションインスタンスの作成
app = create_app()

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/get_prices')
def get_prices():
    try:
        kaitori_prices = get_kaitori_prices()
        official_prices = load_official_prices()
        
        # 買取価格と公式価格を組み合わせる
        for series in kaitori_prices:
            if series in official_prices:
                for capacity, details in kaitori_prices[series].items():
                    if capacity in official_prices[series]:
                        # 最安値の公式価格を取得
                        official_price = min(official_prices[series][capacity].values())
                        details['official_price'] = official_price
                        # 最大収益と最小収益を計算
                        details['profit_min'] = details['kaitori_price_min'] - official_price
                        details['profit_max'] = details['kaitori_price_max'] - official_price
                    else:
                        details['official_price'] = None
                        details['profit_min'] = None
                        details['profit_max'] = None
        
        app.logger.debug(f"取得した価格データ: {kaitori_prices}")
        return jsonify(kaitori_prices)
    except Exception as e:
        app.logger.error(f"価格取得エラー: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))

================
File: Procfile
================
web: gunicorn app:app

================
File: README.md
================
# priceComparisonAppForIphone

# ClaudeやChatGPTにリポジトリを丸ごと読み込ませるコマンド

以下のコマンドを実行することでリポジトリ一式をテキストファイル（`repopack-output.txt`）を出力することができます。
```
npx repopack
```
chatへ最初に取り込ませることでコード修正に役立ちます。

## 読み込ませるポイント
ファイルと合わせて以下のプロンプトで始めるとスムーズに改修を始めやすい
```
このファイルはリポジトリのファイルを1つにしたものです。コードのリファクタなどをしたいのでまず添付のコードを確認してください。
```

# About setting to "Renovate"

## 説明:

- extends: ["config:base"]: デフォルト設定に基づきます。
- labels: ["dependencies"]: すべての PR に "dependencies" ラベルが付与されます。
- packageRules:
  - minor と patch の自動マージ: 自動的に PR がマージされます（automergeType: "pr"）。
  - 大規模なマイナー変更（特定のパッケージ）やメジャーアップデートは自動マージされません\*\*。
- prConcurrentLimit: 一度に開かれる PR の上限(number)。

この設定で、メジャーアップデートと大規模なマイナー変更は手動でマージすることができ、それ以外の更新は自動的にマージされます。

================
File: renovate.json
================
{
  "extends": [
    "config:recommended"
  ],
  "labels": [
    "dependencies"
  ],
  "packageRules": [
    {
      "matchUpdateTypes": [
        "minor",
        "patch"
      ],
      "automerge": true,
      "automergeType": "pr",
      "prConcurrentLimit": 10,
      "prPriority": -1,
      "matchPackageNames": [
        "!/@*/",
        "!/some-risky-package/",
        "!/another-risky-package/"
      ]
    },
    {
      "matchUpdateTypes": [
        "major"
      ],
      "automerge": false,
      "prConcurrentLimit": 5,
      "prPriority": 1
    },
    {
      "matchUpdateTypes": [
        "minor"
      ],
      "automerge": false,
      "prPriority": 1,
      "matchPackageNames": [
        "/@*/"
      ]
    }
  ],
  "prConcurrentLimit": 10
}

================
File: requirements.txt
================
attrs==24.2.0
beautifulsoup4==4.12.3
blinker==1.9.0
certifi==2024.8.30
charset-normalizer==3.3.2
click==8.1.7
exceptiongroup==1.2.2
Flask==3.1.0
greenlet==3.0.3
gunicorn==23.0.0
h11==0.14.0
idna==3.10
importlib_metadata==8.5.0
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
outcome==1.3.0.post0
packaging==24.1
playwright==1.49.0
pyee==12.1.1
PySocks==1.7.1
pytest-cov==6.0.0
pytest==7.4.4
python-dotenv==1.0.1
PyYAML==6.0.1
requests==2.32.3
selenium==4.27.1
sniffio==1.3.1
sortedcontainers==2.4.0
soupsieve==2.6
trio-websocket==0.11.1
trio==0.26.2
typing_extensions==4.12.2
urllib3==2.2.3
webdriver-manager==4.0.2
websocket-client==1.8.0
Werkzeug==3.0.4
wsproto==1.2.0
zipp==3.21.0
