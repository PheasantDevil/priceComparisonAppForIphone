This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-26T12:44:36.542Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
config/
  __init__.py
  config.development.yaml
  config.production.yaml
  manager.py
src/
  apple_scraper_for_rudea.py
  apple_scraper.py
templates/
  index.html
tests/
  conftest.py
  pytest.ini
  test_config_manager.py
.env.example
.gitignore
.python-version
.render.yaml
app.py
Procfile
README.md
renovate.json
requirements.txt

================================================================
Repository Files
================================================================

================
File: config/__init__.py
================
from .manager import AppConfig, ConfigManager, ScraperConfig, config

__all__ = ['AppConfig', 'ConfigManager', 'ScraperConfig', 'config']

================
File: config/config.development.yaml
================
app:
  debug: true
  log_level: DEBUG
  secret_key: dev-secret-key

scraper:
  kaitori_rudea_url: https://kaitori-rudeya.com/category/detail/183
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 30
  retry_count: 3
  user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"

================
File: config/config.production.yaml
================
app:
  debug: false
  log_level: INFO
  # secret_keyは環境変数から取得するため、ここには記載しない

scraper:
  kaitori_rudea_url: https://kaitori-rudeya.com/category/detail/183
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 60
  retry_count: 5
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'

================
File: config/manager.py
================
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Literal, Optional, Union
from urllib.parse import urlparse

import yaml
from dotenv import load_dotenv


@dataclass(frozen=True)
class ScraperConfig:
    """スクレイピング関連の設定を管理するデータクラス"""
    KAITORI_RUDEA_URL: str
    APPLE_STORE_URL: str
    REQUEST_TIMEOUT: int
    RETRY_COUNT: int
    USER_AGENT: str

    def __post_init__(self):
        self._validate_urls()
        self._validate_timeout()
        self._validate_retry_count()

    def _validate_urls(self) -> None:
        """URLの形式を検証"""
        for url in [self.KAITORI_RUDEA_URL, self.APPLE_STORE_URL]:
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                raise ValueError(f"Invalid URL format: {url}")

    def _validate_timeout(self) -> None:
        """タイムアウト値の検証"""
        if not isinstance(self.REQUEST_TIMEOUT, int) or self.REQUEST_TIMEOUT <= 0:
            raise ValueError(f"REQUEST_TIMEOUT must be a positive integer, got {self.REQUEST_TIMEOUT}")

    def _validate_retry_count(self) -> None:
        """リトライ回数の検証"""
        if not isinstance(self.RETRY_COUNT, int) or self.RETRY_COUNT < 0:
            raise ValueError(f"RETRY_COUNT must be a non-negative integer, got {self.RETRY_COUNT}")

@dataclass(frozen=True)
class AppConfig:
    """アプリケーション全体の設定を管理するデータクラス"""
    DEBUG: bool
    SECRET_KEY: str
    LOG_LEVEL: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

    def __post_init__(self):
        self._validate_secret_key()
        self._validate_log_level()

    def _validate_secret_key(self) -> None:
        """シークレットキーの検証"""
        if not self.SECRET_KEY or len(self.SECRET_KEY) < 16:
            raise ValueError("SECRET_KEY must be at least 16 characters long")

    def _validate_log_level(self) -> None:
        """ログレベルの検証"""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if self.LOG_LEVEL not in valid_levels:
            raise ValueError(f"LOG_LEVEL must be one of {valid_levels}")

class ConfigManager:
    """設定を一元管理するクラス"""
    def __init__(self):
        self._config: Optional[dict] = None
        self._scraper_config: Optional[ScraperConfig] = None
        self._app_config: Optional[AppConfig] = None
        
        self.load_environment()
        self.load_config_file()

    def load_environment(self) -> None:
        """環境変数を読み込む"""
        load_dotenv()
        self.env: str = os.getenv('FLASK_ENV', 'development')
        
    def load_config_file(self) -> None:
        """設定ファイルを読み込む"""
        config_dir = Path(__file__).parent
        config_file = config_dir / f'config.{self.env}.yaml'
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
            
        with open(config_file, 'r') as f:
            self._config = yaml.safe_load(f)

    @property
    def scraper(self) -> ScraperConfig:
        """スクレイピング設定を取得"""
        if self._scraper_config is None:
            self._scraper_config = ScraperConfig(
                KAITORI_RUDEA_URL=self._config['scraper']['kaitori_rudea_url'],
                APPLE_STORE_URL=self._config['scraper']['apple_store_url'],
                REQUEST_TIMEOUT=self._config['scraper']['request_timeout'],
                RETRY_COUNT=self._config['scraper']['retry_count'],
                USER_AGENT=self._config['scraper']['user_agent']
            )
        return self._scraper_config

    @property
    def app(self) -> AppConfig:
        """アプリケーション設定を取得"""
        if self._app_config is None:
            self._app_config = AppConfig(
                DEBUG=self._config['app']['debug'],
                SECRET_KEY=os.getenv('SECRET_KEY', 'default-secret-key'),
                LOG_LEVEL=self._config['app']['log_level']
            )
        return self._app_config

# シングルトンインスタンスを作成
config = ConfigManager()

================
File: src/apple_scraper_for_rudea.py
================
import logging

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager

from config import config

logger = logging.getLogger(__name__)

def get_kaitori_prices():
    """買取価格を取得する関数"""
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)
    
    try:
        driver.get(config.scraper.KAITORI_RUDEA_URL)
        driver.implicitly_wait(config.scraper.REQUEST_TIMEOUT)

        items = driver.find_elements(By.CSS_SELECTOR, '.tr')
        product_details = []

        for item in items:
            try:
                model_element = item.find_element(By.CSS_SELECTOR, '.ttl h2')
                model_name = model_element.text.strip()
                
                price_element = item.find_element(By.CSS_SELECTOR, '.td.td2 .td2wrap')
                price_text = price_element.text.strip()

                if model_name and price_text and '円' in price_text:
                    product_details.append({
                        "model": model_name,
                        "price": price_text
                    })
            except Exception as e:
                logger.error(f"データ取得エラー: {str(e)}")
                continue

        return product_details
        
    except Exception as e:
        logger.error(f"スクレイピングエラー: {str(e)}")
        raise
        
    finally:
        driver.quit()

if __name__ == '__main__':
    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 価格取得テスト
    prices = get_kaitori_prices()
    for price in prices:
        print(f"モデル: {price['model']} | 価格: {price['price']}")

================
File: src/apple_scraper.py
================
import requests
from bs4 import BeautifulSoup

# iPhone 16, iPhone 16 Plusの購入ページURL
url_iphone16 = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16'
# iPhone 16 Pro, iPhone 16 Pro Maxの購入ページURL
url_iphone16_pro = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16-pro'

# ページから価格情報を取得する関数
def get_prices(url):
    # ページを取得
    response = requests.get(url)
    
    # レスポンスの内容を確認
    print(response.text)  # ここでHTMLの内容を表示
    
    # BeautifulSoupでHTML解析
    soup = BeautifulSoup(response.text, 'html.parser')

    # 価格情報を取得するためのセレクタ
    prices = soup.select('span.price-point.price-point-fullPrice > span.nowrap')

    # 取得した価格情報をリストに格納
    price_list = [price.get_text() for price in prices]
    return price_list

# iPhone 16シリーズの価格取得
print("iPhone 16シリーズの価格:")
iphone16_prices = get_prices(url_iphone16)
for price in iphone16_prices:
    print(price)

# iPhone 16 Proシリーズの価格取得
print("\niPhone 16 Proシリーズの価格:")
iphone16_pro_prices = get_prices(url_iphone16_pro)
for price in iphone16_pro_prices:
    print(price)

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPhone買取価格比較</title>
    <style>
      /* ローディングスピナーのスタイル */
      .loader {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #priceTable {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>iPhone 16シリーズ 買取価格比較</h1>

    <!-- ローディング中の表示 -->
    <div id="loading">
      <div class="loader"></div>
      <p>Loading（読み込み中）...</p>
    </div>

    <!-- エラーメッセージ表示エリア -->
    <div id="error-message" style="display: none; color: red"></div>

    <!-- 価格テーブル -->
    <table id="priceTable" border="1">
      <tr>
        <th>モデル</th>
        <th>買取価格</th>
      </tr>
      <tbody id="priceTableBody"></tbody>
    </table>

    <script>
      // ページが読み込まれた時に価格データを取得する
      document.addEventListener('DOMContentLoaded', function () {
        // ローディング表示
        document.getElementById('loading').style.display = 'block';
        document.getElementById('priceTable').style.display = 'none';

        // データを非同期で取得
        fetch('/get_prices')
          .then(response => response.json())
          .then(data => {
            if (data.length > 0 && data[0].error) {
              console.error('Error:', data[0].error);
              document.getElementById('loading').innerHTML =
                'エラーが発生しました。詳細はコンソールを確認してください。';
            } else {
              const table = document.getElementById('priceTableBody');
              table.innerHTML = ''; // 既存の内容をクリア
              data.forEach(iphone => {
                const row = `<tr>
                                <td>${iphone.model}</td>
                                <td>${iphone.price}</td>
                             </tr>`;
                table.innerHTML += row;
              });

              // ローディングを非表示にしてテーブルを表示
              document.getElementById('loading').style.display = 'none';
              document.getElementById('priceTable').style.display = 'block';
            }
          })
          .catch(error => {
            console.error('Fetch error:', error);
            document.getElementById('loading').innerHTML =
              'データの取得中にエラーが発生しました。';
          });
      });

      // ブラウザ拡張機能のエラーハンドリング
      window.addEventListener('error', function (event) {
        if (event.error && event.error.message.includes('runtime.lastError')) {
          console.warn('Browser extension error:', event.error.message);
          document.getElementById('error-message').textContent =
            'ブラウザ拡張機能の動作に問題が発生しています。拡張機能を無効にしてみてください。';
          document.getElementById('error-message').style.display = 'block';
        }
      });
    </script>
  </body>
</html>

================
File: tests/conftest.py
================
import pytest
from pathlib import Path
import os



@pytest.fixture
def temp_config_dir(tmp_path):
    """一時的な設定ファイルディレクトリを作成するフィクスチャ"""
    config_dir = tmp_path / "config"
    config_dir.mkdir()
    return config_dir

@pytest.fixture(scope="function")
def mock_env_vars(monkeypatch):
    """環境変数をモックするフィクスチャ"""
    monkeypatch.setenv("FLASK_ENV", "testing")
    monkeypatch.setenv("SECRET_KEY", "test-secret-key-12345")
    return {
        "FLASK_ENV": "testing",
        "SECRET_KEY": "test-secret-key-12345"
    }

@pytest.fixture
def test_config_file(temp_config_dir):
    """テスト用の設定ファイルを作成するフィクスチャ"""
    config_content = """
app:
  debug: true
  log_level: DEBUG
  secret_key: test-secret-key

scraper:
  kaitori_rudea_url: https://test.example.com/kaitori
  apple_store_url: https://test.example.com/apple
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = temp_config_dir / "config.testing.yaml"
    config_file.write_text(config_content)
    return config_file

================
File: tests/pytest.ini
================
[pytest]
pythonpath = .
testpaths = tests
python_files = test_*.py
addopts = -v -s --cov=config --cov-report=term-missing

================
File: tests/test_config_manager.py
================
import sys
from pathlib import Path
import shutil
import pytest

# プロジェクトのルートディレクトリをPYTHONPATHに追加
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import pytest

from config import AppConfig, ConfigManager, ScraperConfig

@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    config_content = """
app:
  debug: true
  log_level: "DEBUG"

scraper:
  kaitori_rudea_url: "https://example.com/kaitori"
  apple_store_url: "https://example.com/apple"
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

def test_config_manager_initialization(mock_env_vars, test_config_file):
    """ConfigManagerの初期化テスト"""
    config = ConfigManager()
    assert config.env == "testing"
    assert isinstance(config.app, AppConfig)
    assert isinstance(config.scraper, ScraperConfig)

def test_app_config_validation():
    """AppConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="short",
            LOG_LEVEL="DEBUG"
        )
    
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"
        )

def test_scraper_config_validation():
    """ScraperConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="Invalid URL format"):
        ScraperConfig(
            KAITORI_RUDEA_URL="invalid-url",
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
    
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URL="https://example.com",
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=0,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )

================
File: .env.example
================
FLASK_ENV=development
SECRET_KEY=your-secret-key-here

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

================
File: .python-version
================
3.11.9

================
File: .render.yaml
================
# デプロイの設定を詳細に指定するためのファイルで、以下のような情報を設定可能
# ・ サービスの種類（web service、background jobなど）
# ・ 環境変数
# ・ ビルドコマンドやスタートコマンド
# ・ 自動デプロイの有無など

services:
  - type: web
    name: priceComparisonAppForIphone
    runtime: python
    buildCommand: |
      pip install -r requirements.txt
      playwright install chromium
      playwright install-deps
    startCommand: gunicorn app:app
    envVars:
      - key: PLAYWRIGHT_BROWSERS_PATH
        value: /home/render/.cache/ms-playwright
    env: python

================
File: app.py
================
import logging
import os

from flask import Flask, jsonify, render_template
from playwright.sync_api import sync_playwright

from config import config


def create_app():
    app = Flask(__name__)
    
    # アプリケーション設定の適用
    app.config['DEBUG'] = config.app.DEBUG
    app.config['SECRET_KEY'] = config.app.SECRET_KEY
    
    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    return app

def get_kaitori_prices():
    product_details = []
    
    with sync_playwright() as p:
        browser = p.chromium.launch(chromium_sandbox=False)
        page = browser.new_page()
        
        # 設定から URL を使用
        page.goto(config.scraper.KAITORI_RUDEA_URL)
        page.wait_for_selector('.tr')

        items = page.query_selector_all('.tr')

        for item in items:
            model_name = "不明"
            price_text = "不明"

            try:
                model_element = item.query_selector('.ttl h2')
                model_name = model_element.inner_text().strip()
            except Exception as e:
                app.logger.error(f"モデル名取得エラー: {str(e)}")
                model_name = "エラー: モデル名取得失敗"

            try:
                price_element = item.query_selector('.td.td2 .td2wrap')
                price_text = price_element.inner_text().strip()
            except Exception as e:
                app.logger.error(f"価格取得エラー: {str(e)}")
                price_text = "エラー: 買取価格取得失敗"

            if model_name and price_text and '円' in price_text:
                product_details.append({
                    "model": model_name,
                    "price": price_text
                })

        browser.close()
    return product_details

# アプリケーションインスタンスの作成
app = create_app()

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/get_prices')
def get_prices():
    try:
        iphone_prices = get_kaitori_prices()
        return jsonify(iphone_prices)
    except Exception as e:
        app.logger.error(f"価格取得エラー: {str(e)}")
        return jsonify([{"error": str(e)}]), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))

================
File: Procfile
================
web: gunicorn app:app

================
File: README.md
================
# priceComparisonAppForIphone

# ClaudeやChatGPTにリポジトリを丸ごと読み込ませるコマンド

以下のコマンドを実行することでリポジトリ一式をテキストファイル（`repopack-output.txt`）を出力することができます。
```
npx repopack
```
chatへ最初に取り込ませることでコード修正に役立ちます。

## 読み込ませるポイント
ファイルと合わせて以下のプロンプトで始めるとスムーズに改修を始めやすい
```
このファイルはリポジトリのファイルを1つにしたものです。コードのリファクタなどをしたいのでまず添付のコードを確認してください。
```

# About setting to "Renovate"

## 説明:

- extends: ["config:base"]: デフォルト設定に基づきます。
- labels: ["dependencies"]: すべての PR に "dependencies" ラベルが付与されます。
- packageRules:
  - minor と patch の自動マージ: 自動的に PR がマージされます（automergeType: "pr"）。
  - 大規模なマイナー変更（特定のパッケージ）やメジャーアップデートは自動マージされません\*\*。
- prConcurrentLimit: 一度に開かれる PR の上限(number)。

この設定で、メジャーアップデートと大規模なマイナー変更は手動でマージすることができ、それ以外の更新は自動的にマージされます。

================
File: renovate.json
================
{
  "extends": ["config:base"],
  "labels": ["dependencies"],
  "packageRules": [
    {
      "matchUpdateTypes": ["minor", "patch"],
      "automerge": true,
      "automergeType": "pr",
      "excludePackagePatterns": ["*"],
      "prConcurrentLimit": 10
    },
    {
      "matchUpdateTypes": ["major"],
      "automerge": false,
      "prConcurrentLimit": 5
    },
    {
      "matchUpdateTypes": ["minor"],
      "excludePackagePatterns": ["@*"],
      "automerge": false
    }
  ],
  "prConcurrentLimit": 10
}

================
File: requirements.txt
================
attrs==24.2.0
beautifulsoup4==4.12.3
blinker==1.8.2
certifi==2024.8.30
charset-normalizer==3.3.2
click==8.1.7
exceptiongroup==1.2.2
Flask==3.0.3
greenlet==3.0.3
gunicorn==23.0.0
h11==0.14.0
idna==3.10
importlib_metadata==8.5.0
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
outcome==1.3.0.post0
packaging==24.1
playwright==1.47.0
pyee==12.0.0
PySocks==1.7.1
pytest-cov==4.1.0
pytest==7.4.4
python-dotenv==1.0.1
PyYAML==6.0.1
requests==2.32.3
selenium==4.25.0
sniffio==1.3.1
sortedcontainers==2.4.0
soupsieve==2.6
trio-websocket==0.11.1
trio==0.26.2
typing_extensions==4.12.2
urllib3==2.2.3
webdriver-manager==4.0.2
websocket-client==1.8.0
Werkzeug==3.0.4
wsproto==1.2.0
zipp==3.20.2
