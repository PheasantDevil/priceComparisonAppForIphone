<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPhone 16シリーズ 買取価格比較</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* ローディングスピナーのスタイル */
      .loader {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #priceTable {
        display: none;
      }

      .tables-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin: 20px auto;
        max-width: 1400px;
        padding: 0 20px;
      }

      .price-table {
        min-width: 300px;
        width: 100%;
        border-collapse: collapse;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .price-table caption {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .price-table th,
      .price-table td {
        padding: 8px 15px;
        border: 1px solid #ddd;
        text-align: left;
        white-space: nowrap;
      }

      .price-table th {
        background-color: #f2f2f2;
      }

      .price-table td:last-child {
        text-align: right;
      }

      .price-table td[style*='color: green'] {
        font-weight: bold;
      }

      .price-table td[style*='color: red'] {
        font-weight: bold;
      }

      .series-section {
        flex: 1 1 100%;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .series-section h2 {
        text-align: center;
        color: #333;
        margin-bottom: 15px;
      }

      /* 収支の色分け */
      .price-diff-negative {
        color: red;
        font-weight: bold;
      }

      .price-diff-positive {
        color: green;
        font-weight: bold;
      }

      /* ブレークポイントの調整 */
      @media (min-width: 576px) {
        .series-section {
          padding: 0 10px;
        }
      }

      @media (min-width: 768px) {
        .series-section {
          flex: 0 1 calc(50% - 20px);
        }
      }

      @media (min-width: 992px) {
        .series-section {
          flex: 0 1 calc(33.333% - 20px);
        }
      }

      @media (max-width: 576px) {
        .price-table {
          font-size: 0.85em;
        }
        .price-table th,
        .price-table td {
          padding: 6px 10px;
        }
      }

      /* テーブルラッパーを追加 */
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
        margin-bottom: 15px;
      }

      /* スマートフォン向けの調整 */
      @media (max-width: 414px) {
        .series-section {
          flex: 1 1 100%;
          max-width: 100%;
          padding: 0 10px;
        }

        .tables-container {
          gap: 20px;
          padding: 0 5px;
        }

        .table-wrapper {
          max-width: calc(100vw - 20px); /* 画面幅からパディングを引いた幅 */
        }

        .price-table {
          min-width: 300px; /* テーブルの最小幅を設定 */
          font-size: 0.85em; /* フォントサイズを縮小 */
        }

        .price-table th,
        .price-table td {
          padding: 6px 10px; /* セルのパディングを縮小 */
          white-space: nowrap; /* テキストの折り返しを防止 */
        }

        /* テーブルのキャプションスタイルを調整 */
        .series-section h2 {
          font-size: 1.1em;
          margin-bottom: 10px;
        }
      }

      /* さらに小さい画面向けの微調整 */
      @media (max-width: 374px) {
        .price-table {
          font-size: 0.8em;
        }

        .price-table th,
        .price-table td {
          padding: 5px 8px;
        }
      }

      /* グラフコンテナのスタイル */
      .graph-container {
        width: 100%;
        height: 200px;
        margin-top: 20px;
        margin-bottom: 30px;
      }

      /* 統計情報のスタイル */
      .stats-container {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .stat-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .stat-title {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
      }

      .stat-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .stat-change {
        font-size: 0.8em;
        margin-top: 5px;
      }

      .stat-change.positive {
        color: #2ecc71;
      }

      .stat-change.negative {
        color: #e74c3c;
      }

      .trend-indicator {
        display: inline-block;
        margin-left: 5px;
        font-size: 0.8em;
      }

      .trend-up {
        color: #2ecc71;
      }

      .trend-down {
        color: #e74c3c;
      }

      .graph-toggle {
        background-color: #f2f2f2;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
        font-size: 0.9em;
        transition: background-color 0.3s ease;
      }

      .graph-toggle:hover {
        background-color: #e0e0e0;
      }

      .graph-wrapper {
        display: none;
        width: 100%;
        overflow-x: auto;
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .graph-wrapper.active {
        display: block;
      }

      .graph-wrapper canvas {
        width: 100% !important;
        height: 200px !important;
      }

      /* 期間選択のスタイル */
      .period-selector {
        margin: 10px 0;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: #fff;
        font-size: 0.9em;
      }

      .period-selector:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
      }

      /* 予測グラフのスタイル */
      .prediction-graph {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .prediction-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .prediction-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
      }

      .prediction-controls {
        display: flex;
        gap: 10px;
      }

      .prediction-period {
        padding: 5px 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: white;
      }

      .prediction-info {
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .prediction-trend {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.9em;
      }

      .prediction-trend.up {
        color: #2ecc71;
      }

      .prediction-trend.down {
        color: #e74c3c;
      }

      .confidence-interval {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
      }

      /* モデル比較のスタイル */
      .model-comparison {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .comparison-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .comparison-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .comparison-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .model-selector {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 200px;
      }

      .comparison-period {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .comparison-graph {
        margin-top: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .comparison-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .model-stat-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .model-name {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .price-change {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
      }

      .price-change.positive {
        color: #2ecc71;
      }

      .price-change.negative {
        color: #e74c3c;
      }

      /* フィルターのスタイル */
      .filter-container {
        margin: 20px 0;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .filter-label {
        font-size: 0.9em;
        color: #666;
      }

      .filter-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 150px;
      }

      .filter-button {
        padding: 8px 16px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .filter-button:hover {
        background-color: #2980b9;
      }

      .filter-button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      /* 価格差のスタイル */
      .price-difference {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .price-difference-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .price-difference-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
      }

      .price-difference-content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .price-difference-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .price-difference-label {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
      }

      .price-difference-value {
        font-size: 1.2em;
        font-weight: bold;
      }

      .price-difference-value.positive {
        color: #2ecc71;
      }

      .price-difference-value.negative {
        color: #e74c3c;
      }

      /* レコメンデーションのスタイル */
      .recommendation-section {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .recommendation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .recommendation-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .recommendation-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .preference-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 150px;
      }

      .recommendation-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .recommendation-card {
        background-color: white;
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease;
      }

      .recommendation-card:hover {
        transform: translateY(-5px);
      }

      .recommendation-card.best {
        border: 2px solid #2ecc71;
      }

      .recommendation-card.good {
        border: 2px solid #3498db;
      }

      .recommendation-card.fair {
        border: 2px solid #f1c40f;
      }

      .recommendation-model {
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .recommendation-details {
        margin-top: 10px;
      }

      .recommendation-detail {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.9em;
      }

      .recommendation-label {
        color: #666;
      }

      .recommendation-value {
        font-weight: bold;
      }

      .recommendation-value.positive {
        color: #2ecc71;
      }

      .recommendation-value.negative {
        color: #e74c3c;
      }

      .recommendation-score {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
        text-align: right;
        font-size: 0.9em;
        color: #666;
      }

      /* 予測期間選択のスタイル */
      .prediction-period-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: white;
        font-size: 0.9em;
        margin-left: 10px;
      }

      /* 購入タイミング提案のスタイル */
      .purchase-timing {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .purchase-timing-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .purchase-timing-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .purchase-timing-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .purchase-timing-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .purchase-timing-card {
        background-color: white;
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .purchase-timing-card.best {
        border: 2px solid #2ecc71;
      }

      .purchase-timing-card.good {
        border: 2px solid #3498db;
      }

      .purchase-timing-card.fair {
        border: 2px solid #f1c40f;
      }

      .purchase-timing-model {
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .purchase-timing-details {
        margin-top: 10px;
      }

      .purchase-timing-detail {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.9em;
      }

      .purchase-timing-label {
        color: #666;
      }

      .purchase-timing-value {
        font-weight: bold;
      }

      .purchase-timing-value.positive {
        color: #2ecc71;
      }

      .purchase-timing-value.negative {
        color: #e74c3c;
      }

      .purchase-timing-recommendation {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #666;
      }

      .purchase-timing-score {
        text-align: right;
        font-size: 0.8em;
        color: #999;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container mt-4">
      <h1 class="mb-4">iPhone価格比較</h1>

      <!-- 価格アラート設定セクション -->
      <div class="card mb-4">
        <div class="card-header">
          <h5 class="mb-0">価格アラート設定</h5>
        </div>
        <div class="card-body">
          <form id="alertForm">
            <div class="form-group">
              <label for="alertThreshold">アラート閾値（円）</label>
              <input
                type="number"
                class="form-control"
                id="alertThreshold"
                required
              />
            </div>
            <button type="submit" class="btn btn-primary mt-3">
              アラートを設定
            </button>
          </form>
        </div>
      </div>

      <!-- 価格比較セクション -->
      <div id="content">
        <div id="priceTablesContainer" class="tables-container">
          <!-- iPhone 16 -->
          <div class="series-section">
            <h2>iPhone 16</h2>
            <div class="table-wrapper">
              <table id="iPhone16-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16 Pro -->
          <div class="series-section">
            <h2>iPhone 16 Pro</h2>
            <div class="table-wrapper">
              <table id="iPhone16Pro-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16 Pro Max -->
          <div class="series-section">
            <h2>iPhone 16 Pro Max</h2>
            <div class="table-wrapper">
              <table id="iPhone16ProMax-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16e -->
          <div class="series-section">
            <h2>iPhone 16e</h2>
            <div class="table-wrapper">
              <table id="iPhone16e-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const API_ENDPOINT =
          'https://l8l7v5xw9d.execute-api.ap-northeast-1.amazonaws.com/prod/get_prices';
        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16 e',
        ];

        // ローディング状態を管理する要素
        const loadingElement = document.getElementById('loading');
        const contentElement = document.getElementById('content');
        const priceTablesContainer = document.getElementById(
          'priceTablesContainer'
        );

        // データ取得と表示の処理
        async function fetchPrices() {
          try {
            // ローディング表示
            if (loadingElement) loadingElement.style.display = 'block';
            if (contentElement) contentElement.style.display = 'none';

            const results = await Promise.all(
              series.map(series =>
                fetch(
                  `${API_ENDPOINT}?series=${encodeURIComponent(series)}`
                ).then(response => {
                  if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                  }
                  return response.json();
                })
              )
            );

            console.log('Raw response data from Lambda:', results);

            results.forEach((data, index) => {
              if (data && data.data) {
                const seriesName = Object.keys(data.data)[0];
                const priceData = data.data[seriesName];

                const tableId = seriesName.replace(/\s+/g, '') + '-prices';
                const tableBody = document.querySelector(`#${tableId} tbody`);

                if (tableBody && priceData) {
                  // DocumentFragment を使用
                  const fragment = document.createDocumentFragment();

                  // 容量配列の作成（既存のソートロジックを維持）
                  const capacities = Array.from(
                    new Set([
                      ...Object.keys(priceData.official || {}),
                      ...Object.keys(priceData.kaitori || {}),
                    ])
                  ).sort((a, b) => {
                    const [aNum, aUnit] = a.match(/(\d+)(GB|TB)/).slice(1);
                    const [bNum, bUnit] = b.match(/(\d+)(GB|TB)/).slice(1);
                    const aValue =
                      aUnit === 'TB' ? parseInt(aNum) * 1024 : parseInt(aNum);
                    const bValue =
                      bUnit === 'TB' ? parseInt(bNum) * 1024 : parseInt(bNum);
                    return aValue - bValue;
                  });

                  // 一度のループで全ての行を生成
                  capacities.forEach(capacity => {
                    const row = document.createElement('tr');
                    const officialPrice = parseInt(
                      priceData.official?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const kaitoriPrice = parseInt(
                      priceData.kaitori?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const priceDiff = kaitoriPrice - officialPrice;
                    const rakutenPriceDiff = kaitoriPrice - officialPrice * 0.9;

                    row.innerHTML = `
                      <td>${capacity}</td>
                      <td>¥${officialPrice.toLocaleString()}</td>
                      <td>¥${kaitoriPrice.toLocaleString()}</td>
                      <td class="${
                        priceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${priceDiff.toLocaleString()}
                      </td>
                      <td class="${
                        rakutenPriceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${Math.round(rakutenPriceDiff).toLocaleString()}
                      </td>
                    `;
                    fragment.appendChild(row);
                  });

                  // まとめてDOM更新
                  tableBody.innerHTML = '';
                  tableBody.appendChild(fragment);
                }
              }
            });

            // データ表示後にテーブルを表示
            if (priceTablesContainer)
              priceTablesContainer.style.display = 'flex';
          } catch (error) {
            console.error('Fetch Error:', error);
            // エラーメッセージを表示
            const errorElement = document.getElementById('error-message');
            if (errorElement) {
              errorElement.textContent = `データの取得に失敗しました: ${error.message}`;
              errorElement.style.display = 'block';
            }
          } finally {
            // ローディング非表示
            if (loadingElement) loadingElement.style.display = 'none';
            if (contentElement) contentElement.style.display = 'block';
          }
        }

        // 初期データ取得
        fetchPrices();
      });

      // 価格履歴グラフの実装
      const priceHistoryCharts = {};

      function formatDate(timestamp) {
        const date = new Date(timestamp * 1000);
        return `${date.getMonth() + 1}/${date.getDate()}`;
      }

      function createPriceHistoryGraph(series, capacity, color) {
        const modelId = `${series}-${capacity}-${color}`;
        const graphContainer = document.createElement('div');
        graphContainer.className = 'graph-wrapper';
        graphContainer.id = `graph-${modelId}`;

        // 期間選択ドロップダウンを追加
        const periodSelector = document.createElement('select');
        periodSelector.className = 'period-selector';
        periodSelector.innerHTML = `
          <option value="7">過去1週間</option>
          <option value="14" selected>過去2週間</option>
          <option value="30">過去1ヶ月</option>
          <option value="90">過去3ヶ月</option>
        `;
        periodSelector.onchange = () => {
          fetchPriceHistory(
            series,
            capacity,
            color,
            parseInt(periodSelector.value)
          );
        };

        graphContainer.appendChild(periodSelector);

        const canvas = document.createElement('canvas');
        graphContainer.appendChild(canvas);

        // 統計情報コンテナを追加
        const statsContainer = document.createElement('div');
        statsContainer.className = 'stats-container';
        statsContainer.id = `stats-${modelId}`;
        graphContainer.appendChild(statsContainer);

        // 予測グラフコンテナを追加
        const predictionContainer = document.createElement('div');
        predictionContainer.className = 'prediction-graph';
        predictionContainer.id = `prediction-${modelId}`;

        const predictionHeader = document.createElement('div');
        predictionHeader.className = 'prediction-header';

        const predictionTitle = document.createElement('div');
        predictionTitle.className = 'prediction-title';
        predictionTitle.textContent = '価格予測';

        const predictionControls = document.createElement('div');
        predictionControls.className = 'prediction-controls';

        const predictionPeriod = document.createElement('select');
        predictionPeriod.className = 'prediction-period';
        predictionPeriod.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriod.onchange = () => {
          fetchPricePrediction(modelId, parseInt(predictionPeriod.value));
        };

        predictionControls.appendChild(predictionPeriod);
        predictionHeader.appendChild(predictionTitle);
        predictionHeader.appendChild(predictionControls);
        predictionContainer.appendChild(predictionHeader);

        const predictionCanvas = document.createElement('canvas');
        predictionContainer.appendChild(predictionCanvas);

        const predictionInfo = document.createElement('div');
        predictionInfo.className = 'prediction-info';
        predictionInfo.id = `prediction-info-${modelId}`;
        predictionContainer.appendChild(predictionInfo);

        graphContainer.appendChild(predictionContainer);

        const table = document.getElementById(`${series}-prices`);
        const row = table.querySelector(
          `tr[data-capacity="${capacity}"][data-color="${color}"]`
        );
        if (row) {
          row.parentNode.insertBefore(graphContainer, row.nextSibling);
        }

        const ctx = canvas.getContext('2d');
        priceHistoryCharts[modelId] = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: '買取価格',
                data: [],
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                borderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6,
                pointBackgroundColor: 'rgb(75, 192, 192)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgb(75, 192, 192)',
                tension: 0.3,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 1000,
              easing: 'easeInOutQuart',
              onComplete: function () {
                const chart = this;
                const ctx = chart.ctx;
                ctx.save();
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                chart.data.datasets.forEach((dataset, i) => {
                  const meta = chart.getDatasetMeta(i);
                  meta.data.forEach((point, index) => {
                    const data = dataset.data[index];
                    ctx.fillText(
                      '¥' + data.toLocaleString(),
                      point.x,
                      point.y - 5
                    );
                  });
                });
                ctx.restore();
              },
            },
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleFont: {
                  size: 14,
                  weight: 'bold',
                },
                bodyFont: {
                  size: 12,
                },
                padding: 12,
                callbacks: {
                  title: function (context) {
                    const date = new Date(context[0].label);
                    return date.toLocaleDateString('ja-JP', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      weekday: 'long',
                    });
                  },
                  label: function (context) {
                    const value = context.parsed.y;
                    const index = context.dataIndex;
                    const dataset = context.dataset.data;
                    const previousValue = index > 0 ? dataset[index - 1] : null;

                    let label = `買取価格: ¥${value.toLocaleString()}`;

                    if (previousValue) {
                      const diff = value - previousValue;
                      const percentage = ((diff / previousValue) * 100).toFixed(
                        1
                      );
                      const diffText =
                        diff > 0
                          ? `+¥${diff.toLocaleString()}`
                          : `-¥${Math.abs(diff).toLocaleString()}`;
                      const percentageText =
                        diff > 0 ? `+${percentage}%` : `${percentage}%`;

                      label += `\n前回比: ${diffText} (${percentageText})`;
                    }

                    return label;
                  },
                  footer: function (context) {
                    const index = context[0].dataIndex;
                    const dataset = context[0].dataset.data;
                    const value = context[0].parsed.y;

                    if (index > 0) {
                      const previousValue = dataset[index - 1];
                      const diff = value - previousValue;
                      const percentage = ((diff / previousValue) * 100).toFixed(
                        1
                      );

                      if (diff > 0) {
                        return '価格が上昇しています';
                      } else if (diff < 0) {
                        return '価格が下落しています';
                      } else {
                        return '価格に変化はありません';
                      }
                    }
                    return '';
                  },
                },
              },
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)',
                },
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
              x: {
                grid: {
                  display: false,
                },
              },
            },
            interaction: {
              mode: 'nearest',
              axis: 'x',
              intersect: false,
            },
          },
        });

        // 予測グラフの初期化
        const predictionCtx = predictionCanvas.getContext('2d');
        pricePredictionCharts[modelId] = new Chart(predictionCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: '予測価格',
                data: [],
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                borderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6,
                tension: 0.3,
                fill: true,
              },
              {
                label: '信頼区間（上限）',
                data: [],
                borderColor: 'rgba(255, 99, 132, 0.3)',
                borderWidth: 1,
                pointRadius: 0,
                borderDash: [5, 5],
                fill: false,
              },
              {
                label: '信頼区間（下限）',
                data: [],
                borderColor: 'rgba(255, 99, 132, 0.3)',
                borderWidth: 1,
                pointRadius: 0,
                borderDash: [5, 5],
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    const value = context.parsed.y;
                    return `${
                      context.dataset.label
                    }: ¥${value.toLocaleString()}`;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
            },
          },
        });

        return graphContainer;
      }

      function updateStats(modelId, data) {
        const statsContainer = document.getElementById(`stats-${modelId}`);
        if (!statsContainer || !data || data.length === 0) return;

        const prices = data.map(item => item.price);
        const timestamps = data.map(item => item.timestamp);

        // 基本統計量の計算
        const maxPrice = Math.max(...prices);
        const minPrice = Math.min(...prices);
        const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;

        // 標準偏差の計算
        const variance =
          prices.reduce(
            (acc, price) => acc + Math.pow(price - avgPrice, 2),
            0
          ) / prices.length;
        const stdDev = Math.sqrt(variance);

        // トレンドの計算（単純な線形回帰）
        const n = prices.length;
        const sumX = timestamps.reduce((a, b) => a + b, 0);
        const sumY = prices.reduce((a, b) => a + b, 0);
        const sumXY = timestamps.reduce((acc, x, i) => acc + x * prices[i], 0);
        const sumX2 = timestamps.reduce((acc, x) => acc + x * x, 0);

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const trend = slope > 0 ? '上昇' : '下落';
        const trendClass = slope > 0 ? 'trend-up' : 'trend-down';

        // 統計情報の表示
        statsContainer.innerHTML = `
          <div class="stat-card">
            <div class="stat-title">最高価格</div>
            <div class="stat-value">¥${maxPrice.toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">最低価格</div>
            <div class="stat-value">¥${minPrice.toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">平均価格</div>
            <div class="stat-value">¥${Math.round(
              avgPrice
            ).toLocaleString()}</div>
            <div class="stat-change">標準偏差: ¥${Math.round(
              stdDev
            ).toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">価格トレンド</div>
            <div class="stat-value">
              ${trend}
              <span class="trend-indicator ${trendClass}">
                ${slope > 0 ? '↑' : '↓'}
              </span>
            </div>
            <div class="stat-change">
              1日あたりの変化: ¥${Math.abs(
                Math.round(slope * 86400)
              ).toLocaleString()}
            </div>
          </div>
        `;
      }

      async function fetchPriceHistory(series, capacity, color, days = 14) {
        const modelId = `${series}-${capacity}-${color}`;
        try {
          const response = await fetch(
            `/price-history?model=${modelId}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          const chart = priceHistoryCharts[modelId];
          if (chart) {
            chart.data.labels = data.map(item => formatDate(item.timestamp));
            chart.data.datasets[0].data = data.map(item => item.price);
            chart.update();

            // 統計情報を更新
            updateStats(modelId, data);
          }
        } catch (error) {
          console.error('Error fetching price history:', error);
          const errorMessage = document.createElement('div');
          errorMessage.className = 'error-message';
          errorMessage.textContent = '価格履歴の取得に失敗しました';
          const graphWrapper = document.getElementById(`graph-${modelId}`);
          if (graphWrapper) {
            graphWrapper.appendChild(errorMessage);
          }
        }
      }

      function addGraphToggle(series, capacity, color) {
        const modelId = `${series}-${capacity}-${color}`;
        const table = document.getElementById(`${series}-prices`);
        const row = table.querySelector(
          `tr[data-capacity="${capacity}"][data-color="${color}"]`
        );

        if (row) {
          const toggleButton = document.createElement('button');
          toggleButton.className = 'graph-toggle';
          toggleButton.textContent = '価格推移を表示';
          toggleButton.onclick = () => {
            const graphWrapper = document.getElementById(`graph-${modelId}`);
            if (!graphWrapper) {
              createPriceHistoryGraph(series, capacity, color);
              fetchPriceHistory(series, capacity, color);
            }
            graphWrapper.classList.toggle('active');
            toggleButton.textContent = graphWrapper.classList.contains('active')
              ? '価格推移を隠す'
              : '価格推移を表示';
          };

          // 新しいセルを作成してボタンを追加
          const newCell = document.createElement('td');
          newCell.appendChild(toggleButton);
          row.appendChild(newCell);
        }
      }

      // 既存のテーブル作成処理を修正
      function createTable(series, data) {
        // ... existing table creation code ...

        // 各行にグラフトグルを追加
        Object.entries(data).forEach(([capacity, colors]) => {
          Object.entries(colors).forEach(([color, price]) => {
            addGraphToggle(series, capacity, color);
          });
        });
      }

      async function fetchPricePrediction(modelId, days = 7) {
        try {
          const response = await fetch(
            `/predict-prices?model=${modelId}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          if (data.error) {
            throw new Error(data.error);
          }

          const chart = pricePredictionCharts[modelId];
          if (chart) {
            // 予測データの更新
            chart.data.labels = data.predictions.map(p => p.date);
            chart.data.datasets[0].data = data.predictions.map(
              p => p.predicted_price
            );
            chart.data.datasets[1].data = data.predictions.map(
              p => p.predicted_price + p.confidence_interval
            );
            chart.data.datasets[2].data = data.predictions.map(
              p => p.predicted_price - p.confidence_interval
            );
            chart.update();

            // 予測情報の更新
            const predictionInfo = document.getElementById(
              `prediction-info-${modelId}`
            );
            if (predictionInfo) {
              const trendClass =
                data.trend === 'up' ? 'trend-up' : 'trend-down';
              const trendIcon = data.trend === 'up' ? '↑' : '↓';

              predictionInfo.innerHTML = `
                <div class="prediction-trend ${trendClass}">
                  <span>予測トレンド: ${data.trend}</span>
                  <span>${trendIcon}</span>
                </div>
                <div class="confidence-interval">
                  信頼区間: ±¥${data.predictions[0].confidence_interval.toLocaleString()}
                </div>
              `;
            }
          }
        } catch (error) {
          console.error('Error fetching price prediction:', error);
          const predictionInfo = document.getElementById(
            `prediction-info-${modelId}`
          );
          if (predictionInfo) {
            predictionInfo.innerHTML = `
              <div style="color: red;">
                予測データの取得に失敗しました
              </div>
            `;
          }
        }
      }

      // モデル比較の実装
      const comparisonCharts = {};
      let selectedModels = [];

      function createModelComparison() {
        const comparisonContainer = document.createElement('div');
        comparisonContainer.className = 'model-comparison';
        comparisonContainer.id = 'model-comparison';

        const header = document.createElement('div');
        header.className = 'comparison-header';

        const title = document.createElement('div');
        title.className = 'comparison-title';
        title.textContent = 'モデル比較';

        const controls = document.createElement('div');
        controls.className = 'comparison-controls';

        // モデル選択用のマルチセレクト
        const modelSelector = document.createElement('select');
        modelSelector.className = 'model-selector';
        modelSelector.multiple = true;
        modelSelector.size = 4;

        // 期間選択
        const periodSelector = document.createElement('select');
        periodSelector.className = 'comparison-period';
        periodSelector.innerHTML = `
          <option value="7">過去1週間</option>
          <option value="14">過去2週間</option>
          <option value="30" selected>過去1ヶ月</option>
          <option value="90">過去3ヶ月</option>
        `;

        // 比較ボタン
        const compareButton = document.createElement('button');
        compareButton.className = 'graph-toggle';
        compareButton.textContent = '比較する';
        compareButton.onclick = () => {
          selectedModels = Array.from(modelSelector.selectedOptions).map(
            option => option.value
          );
          if (selectedModels.length >= 2) {
            fetchComparisonData(selectedModels, parseInt(periodSelector.value));
          } else {
            alert('比較するには2つ以上のモデルを選択してください');
          }
        };

        controls.appendChild(modelSelector);
        controls.appendChild(periodSelector);
        controls.appendChild(compareButton);
        header.appendChild(title);
        header.appendChild(controls);
        comparisonContainer.appendChild(header);

        // グラフコンテナ
        const graphContainer = document.createElement('div');
        graphContainer.className = 'comparison-graph';
        graphContainer.id = 'comparison-graph';
        comparisonContainer.appendChild(graphContainer);

        // 統計情報コンテナ
        const statsContainer = document.createElement('div');
        statsContainer.className = 'comparison-stats';
        statsContainer.id = 'comparison-stats';
        comparisonContainer.appendChild(statsContainer);

        document.body.appendChild(comparisonContainer);

        // モデル選択肢の更新
        updateModelSelector(modelSelector);
      }

      function updateModelSelector(selector) {
        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16e',
        ];
        const capacities = ['128GB', '256GB', '512GB', '1TB'];
        const colors = ['黒', '白', '桃', '緑', '青', '金', '灰'];

        selector.innerHTML = '';
        series.forEach(s => {
          capacities.forEach(cap => {
            colors.forEach(color => {
              const modelId = `${s}-${cap}-${color}`;
              const option = document.createElement('option');
              option.value = modelId;
              option.textContent = `${s} ${cap} ${color}`;
              selector.appendChild(option);
            });
          });
        });
      }

      async function fetchComparisonData(modelIds, days) {
        try {
          const response = await fetch(
            `/compare-prices?models=${modelIds.join(',')}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          updateComparisonGraph(data);
          updateComparisonStats(data);
        } catch (error) {
          console.error('Error fetching comparison data:', error);
          const graphContainer = document.getElementById('comparison-graph');
          if (graphContainer) {
            graphContainer.innerHTML = `
              <div style="color: red; padding: 10px;">
                比較データの取得に失敗しました
              </div>
            `;
          }
        }
      }

      function updateComparisonGraph(data) {
        const graphContainer = document.getElementById('comparison-graph');
        if (!graphContainer) return;

        const canvas = document.createElement('canvas');
        graphContainer.innerHTML = '';
        graphContainer.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        const datasets = [];

        const colors = [
          'rgb(255, 99, 132)',
          'rgb(54, 162, 235)',
          'rgb(255, 206, 86)',
          'rgb(75, 192, 192)',
          'rgb(153, 102, 255)',
          'rgb(255, 159, 64)',
        ];

        Object.entries(data).forEach(([modelId, modelData], index) => {
          const color = colors[index % colors.length];
          datasets.push({
            label: modelId,
            data: modelData.price_history.map(item => item.price),
            borderColor: color,
            backgroundColor: color
              .replace('rgb', 'rgba')
              .replace(')', ', 0.1)'),
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            tension: 0.3,
            fill: true,
          });
        });

        new Chart(ctx, {
          type: 'line',
          data: {
            labels: data[Object.keys(data)[0]].price_history.map(item =>
              new Date(item.date).toLocaleDateString('ja-JP')
            ),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    return `${
                      context.dataset.label
                    }: ¥${context.parsed.y.toLocaleString()}`;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
            },
          },
        });
      }

      function updateComparisonStats(data) {
        const statsContainer = document.getElementById('comparison-stats');
        if (!statsContainer) return;

        statsContainer.innerHTML = '';
        Object.entries(data).forEach(([modelId, modelData]) => {
          const statCard = document.createElement('div');
          statCard.className = 'model-stat-card';

          const priceChange = modelData.price_change;
          const changeClass = priceChange > 0 ? 'positive' : 'negative';
          const changeIcon = priceChange > 0 ? '↑' : '↓';

          statCard.innerHTML = `
            <div class="model-name">${modelId}</div>
            <div>現在価格: ¥${modelData.current_price.toLocaleString()}</div>
            <div>平均価格: ¥${modelData.avg_price.toLocaleString()}</div>
            <div>最高価格: ¥${modelData.max_price.toLocaleString()}</div>
            <div>最低価格: ¥${modelData.min_price.toLocaleString()}</div>
            <div class="price-change ${changeClass}">
              価格変動: ${Math.abs(priceChange).toFixed(1)}% ${changeIcon}
            </div>
          `;

          statsContainer.appendChild(statCard);
        });
      }

      // ページ読み込み時にモデル比較UIを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createModelComparison();
      });

      // フィルタリング機能の実装
      let currentFilters = {
        series: null,
        capacity: null,
        color: null,
      };

      function createFilterControls() {
        const filterContainer = document.createElement('div');
        filterContainer.className = 'filter-container';
        filterContainer.id = 'filter-container';

        // シリーズフィルター
        const seriesGroup = document.createElement('div');
        seriesGroup.className = 'filter-group';
        seriesGroup.innerHTML = `
          <label class="filter-label">シリーズ</label>
          <select class="filter-select" id="series-filter">
            <option value="">すべて</option>
            <option value="iPhone 16">iPhone 16</option>
            <option value="iPhone 16 Pro">iPhone 16 Pro</option>
            <option value="iPhone 16 Pro Max">iPhone 16 Pro Max</option>
            <option value="iPhone 16e">iPhone 16e</option>
          </select>
        `;

        // 容量フィルター
        const capacityGroup = document.createElement('div');
        capacityGroup.className = 'filter-group';
        capacityGroup.innerHTML = `
          <label class="filter-label">容量</label>
          <select class="filter-select" id="capacity-filter">
            <option value="">すべて</option>
            <option value="128GB">128GB</option>
            <option value="256GB">256GB</option>
            <option value="512GB">512GB</option>
            <option value="1TB">1TB</option>
          </select>
        `;

        // 色フィルター
        const colorGroup = document.createElement('div');
        colorGroup.className = 'filter-group';
        colorGroup.innerHTML = `
          <label class="filter-label">色</label>
          <select class="filter-select" id="color-filter">
            <option value="">すべて</option>
            <option value="黒">黒</option>
            <option value="白">白</option>
            <option value="桃">桃</option>
            <option value="緑">緑</option>
            <option value="青">青</option>
            <option value="金">金</option>
            <option value="灰">灰</option>
          </select>
        `;

        // フィルター適用ボタン
        const applyButton = document.createElement('button');
        applyButton.className = 'filter-button';
        applyButton.textContent = 'フィルターを適用';
        applyButton.onclick = applyFilters;

        // フィルターリセットボタン
        const resetButton = document.createElement('button');
        resetButton.className = 'filter-button';
        resetButton.textContent = 'リセット';
        resetButton.onclick = resetFilters;

        filterContainer.appendChild(seriesGroup);
        filterContainer.appendChild(capacityGroup);
        filterContainer.appendChild(colorGroup);
        filterContainer.appendChild(applyButton);
        filterContainer.appendChild(resetButton);

        document.body.insertBefore(
          filterContainer,
          document.getElementById('content')
        );

        // フィルターの初期状態を設定
        document
          .getElementById('series-filter')
          .addEventListener('change', updateFilterState);
        document
          .getElementById('capacity-filter')
          .addEventListener('change', updateFilterState);
        document
          .getElementById('color-filter')
          .addEventListener('change', updateFilterState);
      }

      function updateFilterState() {
        currentFilters = {
          series: document.getElementById('series-filter').value,
          capacity: document.getElementById('capacity-filter').value,
          color: document.getElementById('color-filter').value,
        };
      }

      function applyFilters() {
        const tables = document.querySelectorAll('.price-table');
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');
          let hasVisibleRows = false;

          rows.forEach(row => {
            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const isVisible =
              (!currentFilters.series ||
                series.includes(currentFilters.series)) &&
              (!currentFilters.capacity ||
                capacity === currentFilters.capacity) &&
              (!currentFilters.color || color === currentFilters.color);

            row.style.display = isVisible ? '' : 'none';
            if (isVisible) hasVisibleRows = true;
          });

          // テーブル全体の表示/非表示
          const tableContainer = table.closest('.series-section');
          if (tableContainer) {
            tableContainer.style.display = hasVisibleRows ? '' : 'none';
          }
        });

        // モデル比較セレクターの更新
        updateModelSelector(document.querySelector('.model-selector'));
      }

      function resetFilters() {
        document.getElementById('series-filter').value = '';
        document.getElementById('capacity-filter').value = '';
        document.getElementById('color-filter').value = '';
        currentFilters = { series: null, capacity: null, color: null };

        // すべての行を表示
        const rows = document.querySelectorAll('.price-table tbody tr');
        rows.forEach(row => (row.style.display = ''));

        // すべてのテーブルを表示
        const tables = document.querySelectorAll('.series-section');
        tables.forEach(table => (table.style.display = ''));

        // モデル比較セレクターの更新
        updateModelSelector(document.querySelector('.model-selector'));
      }

      function updateModelSelector(selector) {
        if (!selector) return;

        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16e',
        ];
        const capacities = ['128GB', '256GB', '512GB', '1TB'];
        const colors = ['黒', '白', '桃', '緑', '青', '金', '灰'];

        selector.innerHTML = '';
        series.forEach(s => {
          if (currentFilters.series && !s.includes(currentFilters.series))
            return;

          capacities.forEach(cap => {
            if (currentFilters.capacity && cap !== currentFilters.capacity)
              return;

            colors.forEach(color => {
              if (currentFilters.color && color !== currentFilters.color)
                return;

              const modelId = `${s}-${cap}-${color}`;
              const option = document.createElement('option');
              option.value = modelId;
              option.textContent = `${s} ${cap} ${color}`;
              selector.appendChild(option);
            });
          });
        });
      }

      // ページ読み込み時にフィルターコントロールを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createFilterControls();
      });

      // 価格差の計算と表示機能
      function createPriceDifferenceSection() {
        const priceDifferenceContainer = document.createElement('div');
        priceDifferenceContainer.className = 'price-difference';
        priceDifferenceContainer.id = 'price-difference';

        const header = document.createElement('div');
        header.className = 'price-difference-header';

        const title = document.createElement('div');
        title.className = 'price-difference-title';
        title.textContent = '価格差の比較';

        const refreshButton = document.createElement('button');
        refreshButton.className = 'filter-button';
        refreshButton.textContent = '更新';
        refreshButton.onclick = updatePriceDifferences;

        header.appendChild(title);
        header.appendChild(refreshButton);
        priceDifferenceContainer.appendChild(header);

        const content = document.createElement('div');
        content.className = 'price-difference-content';
        content.id = 'price-difference-content';
        priceDifferenceContainer.appendChild(content);

        document.body.appendChild(priceDifferenceContainer);
      }

      function updatePriceDifferences() {
        const content = document.getElementById('price-difference-content');
        if (!content) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 価格差の計算と表示
        content.innerHTML = '';

        // 最大価格差
        const maxDiff = Object.values(priceData).reduce((max, item) =>
          Math.abs(item.difference) > Math.abs(max.difference) ? item : max
        );

        const maxDiffCard = document.createElement('div');
        maxDiffCard.className = 'price-difference-card';
        maxDiffCard.innerHTML = `
          <div class="price-difference-label">最大価格差</div>
          <div class="price-difference-value ${
            maxDiff.difference >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(maxDiff.difference).toLocaleString()}
            <span>(${maxDiff.differencePercentage}%)</span>
          </div>
          <div>${maxDiff.series} ${maxDiff.capacity} ${maxDiff.color}</div>
        `;
        content.appendChild(maxDiffCard);

        // 最小価格差
        const minDiff = Object.values(priceData).reduce((min, item) =>
          Math.abs(item.difference) < Math.abs(min.difference) ? item : min
        );

        const minDiffCard = document.createElement('div');
        minDiffCard.className = 'price-difference-card';
        minDiffCard.innerHTML = `
          <div class="price-difference-label">最小価格差</div>
          <div class="price-difference-value ${
            minDiff.difference >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(minDiff.difference).toLocaleString()}
            <span>(${minDiff.differencePercentage}%)</span>
          </div>
          <div>${minDiff.series} ${minDiff.capacity} ${minDiff.color}</div>
        `;
        content.appendChild(minDiffCard);

        // 平均価格差
        const avgDiff =
          Object.values(priceData).reduce(
            (sum, item) => sum + item.difference,
            0
          ) / Object.keys(priceData).length;
        const avgDiffPercentage = (
          (avgDiff / Object.values(priceData)[0].officialPrice) *
          100
        ).toFixed(1);

        const avgDiffCard = document.createElement('div');
        avgDiffCard.className = 'price-difference-card';
        avgDiffCard.innerHTML = `
          <div class="price-difference-label">平均価格差</div>
          <div class="price-difference-value ${
            avgDiff >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(avgDiff).toLocaleString()}
            <span>(${avgDiffPercentage}%)</span>
          </div>
        `;
        content.appendChild(avgDiffCard);

        // 価格差の分布
        const positiveCount = Object.values(priceData).filter(
          item => item.difference > 0
        ).length;
        const negativeCount = Object.values(priceData).filter(
          item => item.difference < 0
        ).length;
        const zeroCount = Object.values(priceData).filter(
          item => item.difference === 0
        ).length;

        const distributionCard = document.createElement('div');
        distributionCard.className = 'price-difference-card';
        distributionCard.innerHTML = `
          <div class="price-difference-label">価格差の分布</div>
          <div>プラス: ${positiveCount}件</div>
          <div>マイナス: ${negativeCount}件</div>
          <div>変化なし: ${zeroCount}件</div>
        `;
        content.appendChild(distributionCard);
      }

      // ページ読み込み時に価格差セクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createPriceDifferenceSection();
        updatePriceDifferences();
      });

      // レコメンデーション機能の実装
      function createRecommendationSection() {
        const recommendationContainer = document.createElement('div');
        recommendationContainer.className = 'recommendation-section';
        recommendationContainer.id = 'recommendation-section';

        const header = document.createElement('div');
        header.className = 'recommendation-header';

        const title = document.createElement('div');
        title.className = 'recommendation-title';
        title.textContent = 'おすすめモデル';

        const controls = document.createElement('div');
        controls.className = 'recommendation-controls';

        // 優先条件の選択
        const prioritySelect = document.createElement('select');
        prioritySelect.className = 'preference-select';
        prioritySelect.id = 'priority-select';
        prioritySelect.innerHTML = `
          <option value="price">価格差を優先</option>
          <option value="capacity">容量を優先</option>
          <option value="color">色を優先</option>
          <option value="balance">バランス重視</option>
        `;

        // 予測期間の選択
        const predictionPeriodSelect = document.createElement('select');
        predictionPeriodSelect.className = 'prediction-period-select';
        predictionPeriodSelect.id = 'prediction-period-select';
        predictionPeriodSelect.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriodSelect.onchange = updateRecommendations;

        // 更新ボタン
        const updateButton = document.createElement('button');
        updateButton.className = 'filter-button';
        updateButton.textContent = '更新';
        updateButton.onclick = updateRecommendations;

        controls.appendChild(prioritySelect);
        controls.appendChild(predictionPeriodSelect);
        controls.appendChild(updateButton);
        header.appendChild(title);
        header.appendChild(controls);
        recommendationContainer.appendChild(header);

        // レコメンデーションカードのコンテナ
        const cardsContainer = document.createElement('div');
        cardsContainer.className = 'recommendation-cards';
        cardsContainer.id = 'recommendation-cards';
        recommendationContainer.appendChild(cardsContainer);

        document.body.appendChild(recommendationContainer);
      }

      function calculateRecommendationScore(
        model,
        priority,
        predictionData = null
      ) {
        let score = 0;
        const maxScore = 100;

        // 価格差のスコア（最大40点）
        const priceDiff = model.difference;
        const priceScore = Math.min(40, Math.abs(priceDiff) / 10000);
        score += priceScore;

        // 容量のスコア（最大30点）
        const capacityScore =
          {
            '128GB': 20,
            '256GB': 25,
            '512GB': 30,
            '1TB': 30,
          }[model.capacity] || 0;
        score += capacityScore;

        // 色のスコア（最大30点）
        const colorScore =
          {
            黒: 30,
            白: 25,
            青: 20,
            金: 20,
            灰: 15,
            緑: 15,
            桃: 10,
          }[model.color] || 0;
        score += colorScore;

        // 予測データがある場合、予測スコアを追加（最大20点）
        if (predictionData) {
          let predictionScore = 0;

          // トレンドによるスコア調整（最大10点）
          if (predictionData.trend === 'up') {
            predictionScore += 10; // 上昇トレンドは高評価
          } else if (predictionData.trend === 'down') {
            predictionScore += 5; // 下落トレンドは中評価
          }

          // 信頼区間によるスコア調整（最大10点）
          const confidenceInterval =
            predictionData.predictions[0].confidence_interval;
          const confidenceScore = Math.max(0, 10 - confidenceInterval / 10000);
          predictionScore += confidenceScore;

          score += predictionScore;
        }

        // 優先条件に応じてスコアを調整
        switch (priority) {
          case 'price':
            score = priceScore * 2.5;
            break;
          case 'capacity':
            score = capacityScore * 3.3;
            break;
          case 'color':
            score = colorScore * 3.3;
            break;
          // 'balance'の場合はデフォルトのスコアを使用
        }

        return Math.min(maxScore, Math.round(score));
      }

      async function updateRecommendations() {
        const priority = document.getElementById('priority-select').value;
        const predictionDays = parseInt(
          document.getElementById('prediction-period-select').value
        );
        const cardsContainer = document.getElementById('recommendation-cards');
        if (!cardsContainer) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 各モデルの予測データを取得
        const modelPredictions = {};
        for (const modelId in priceData) {
          try {
            const predictionData = await fetchPricePrediction(
              modelId,
              predictionDays
            );
            modelPredictions[modelId] = predictionData;
          } catch (error) {
            console.error(`Error fetching prediction for ${modelId}:`, error);
            modelPredictions[modelId] = null;
          }
        }

        // スコアの計算とソート（予測データを含む）
        const models = Object.values(priceData).map(model => {
          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          return {
            ...model,
            score: calculateRecommendationScore(
              model,
              priority,
              modelPredictions[modelId]
            ),
          };
        });

        models.sort((a, b) => b.score - a.score);

        // レコメンデーションカードの表示
        cardsContainer.innerHTML = '';
        models.slice(0, 3).forEach((model, index) => {
          const card = document.createElement('div');
          card.className = `recommendation-card ${
            index === 0 ? 'best' : index === 1 ? 'good' : 'fair'
          }`;

          const scoreClass =
            model.score >= 80 ? 'best' : model.score >= 60 ? 'good' : 'fair';
          const scoreText =
            model.score >= 80
              ? '最適'
              : model.score >= 60
              ? 'おすすめ'
              : '検討';

          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];

          // 価格予測情報の表示
          const predictionInfo = document.createElement('div');
          predictionInfo.className = 'prediction-info';

          if (predictionData && predictionData.trend) {
            const trendClass = predictionData.trend === 'up' ? 'up' : 'down';
            const trendIcon = predictionData.trend === 'up' ? '↑' : '↓';

            predictionInfo.innerHTML = `
              <div class="prediction-trend ${trendClass}">
                <span>予測トレンド: ${
                  predictionData.trend === 'up' ? '上昇' : '下落'
                }</span>
                <span>${trendIcon}</span>
              </div>
              <div class="confidence-interval">
                信頼区間: ±¥${predictionData.predictions[0].confidence_interval.toLocaleString()}
              </div>
              <div class="prediction-period">
                予測期間: ${predictionDays}日後まで
              </div>
            `;
          } else {
            predictionInfo.innerHTML = `
              <div style="color: #666; font-size: 0.9em;">
                予測データが利用できません
              </div>
            `;
          }

          card.appendChild(predictionInfo);

          card.innerHTML += `
            <div class="recommendation-model">${model.series} ${
            model.capacity
          } ${model.color}</div>
            <div class="recommendation-details">
              <div class="recommendation-detail">
                <span class="recommendation-label">公式価格</span>
                <span class="recommendation-value">¥${model.officialPrice.toLocaleString()}</span>
              </div>
              <div class="recommendation-detail">
                <span class="recommendation-label">買取価格</span>
                <span class="recommendation-value">¥${model.kaitoriPrice.toLocaleString()}</span>
              </div>
              <div class="recommendation-detail">
                <span class="recommendation-label">価格差</span>
                <span class="recommendation-value ${
                  model.difference >= 0 ? 'positive' : 'negative'
                }">
                  ¥${Math.abs(model.difference).toLocaleString()} (${
            model.differencePercentage
          }%)
                </span>
              </div>
            </div>
            <div class="recommendation-score">
              評価: ${scoreText} (スコア: ${model.score}/100)
            </div>
          `;

          cardsContainer.appendChild(card);
        });
      }

      // ページ読み込み時にレコメンデーションセクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createRecommendationSection();
        updateRecommendations();
      });

      function createPurchaseTimingSection() {
        const purchaseTimingContainer = document.createElement('div');
        purchaseTimingContainer.className = 'purchase-timing';
        purchaseTimingContainer.id = 'purchase-timing';

        const header = document.createElement('div');
        header.className = 'purchase-timing-header';

        const title = document.createElement('div');
        title.className = 'purchase-timing-title';
        title.textContent = '購入タイミングの提案';

        const controls = document.createElement('div');
        controls.className = 'purchase-timing-controls';

        // 予測期間の選択
        const predictionPeriodSelect = document.createElement('select');
        predictionPeriodSelect.className = 'prediction-period-select';
        predictionPeriodSelect.id = 'purchase-timing-period-select';
        predictionPeriodSelect.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriodSelect.onchange = updatePurchaseTiming;

        // 更新ボタン
        const updateButton = document.createElement('button');
        updateButton.className = 'filter-button';
        updateButton.textContent = '更新';
        updateButton.onclick = updatePurchaseTiming;

        controls.appendChild(predictionPeriodSelect);
        controls.appendChild(updateButton);
        header.appendChild(title);
        header.appendChild(controls);
        purchaseTimingContainer.appendChild(header);

        // 提案カードのコンテナ
        const cardsContainer = document.createElement('div');
        cardsContainer.className = 'purchase-timing-cards';
        cardsContainer.id = 'purchase-timing-cards';
        purchaseTimingContainer.appendChild(cardsContainer);

        document.body.appendChild(purchaseTimingContainer);
      }

      function calculatePurchaseTimingScore(predictionData) {
        let score = 0;
        const maxScore = 100;

        if (!predictionData || !predictionData.predictions) {
          return 0;
        }

        // トレンドによるスコア（最大40点）
        if (predictionData.trend === 'down') {
          score += 40; // 下落トレンドは高評価
        } else if (predictionData.trend === 'up') {
          score += 20; // 上昇トレンドは中評価
        }

        // 信頼区間によるスコア（最大30点）
        const confidenceInterval =
          predictionData.predictions[0].confidence_interval;
        const confidenceScore = Math.max(0, 30 - confidenceInterval / 10000);
        score += confidenceScore;

        // 価格変動の安定性によるスコア（最大30点）
        const prices = predictionData.predictions.map(p => p.predicted_price);
        const priceChanges = [];
        for (let i = 1; i < prices.length; i++) {
          priceChanges.push(Math.abs(prices[i] - prices[i - 1]));
        }
        const avgPriceChange =
          priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length;
        const stabilityScore = Math.max(0, 30 - avgPriceChange / 1000);
        score += stabilityScore;

        return Math.min(maxScore, Math.round(score));
      }

      function getPurchaseTimingRecommendation(score, predictionData) {
        if (score >= 80) {
          return {
            timing: '今すぐ購入',
            reason: '価格が下落傾向で、信頼性の高い予測が示されています。',
            urgency: 'high',
          };
        } else if (score >= 60) {
          return {
            timing: '近日中に購入',
            reason: '価格が安定傾向で、購入の好機と判断されます。',
            urgency: 'medium',
          };
        } else if (score >= 40) {
          return {
            timing: '様子見',
            reason:
              '価格変動が予想されるため、しばらく様子を見ることをお勧めします。',
            urgency: 'low',
          };
        } else {
          return {
            timing: '購入を待機',
            reason: '価格が上昇傾向で、購入を待つことをお勧めします。',
            urgency: 'wait',
          };
        }
      }

      async function updatePurchaseTiming() {
        const predictionDays = parseInt(
          document.getElementById('purchase-timing-period-select').value
        );
        const cardsContainer = document.getElementById('purchase-timing-cards');
        if (!cardsContainer) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 各モデルの予測データを取得
        const modelPredictions = {};
        for (const modelId in priceData) {
          try {
            const predictionData = await fetchPricePrediction(
              modelId,
              predictionDays
            );
            modelPredictions[modelId] = predictionData;
          } catch (error) {
            console.error(`Error fetching prediction for ${modelId}:`, error);
            modelPredictions[modelId] = null;
          }
        }

        // スコアの計算とソート
        const models = Object.values(priceData).map(model => {
          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];
          const score = calculatePurchaseTimingScore(predictionData);
          const recommendation = getPurchaseTimingRecommendation(
            score,
            predictionData
          );

          return {
            ...model,
            score,
            recommendation,
            predictionData,
          };
        });

        models.sort((a, b) => b.score - a.score);

        // 提案カードの表示
        cardsContainer.innerHTML = '';
        models.slice(0, 3).forEach((model, index) => {
          const card = document.createElement('div');
          card.className = `purchase-timing-card ${model.recommendation.urgency}`;

          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];

          card.innerHTML = `
            <div class="purchase-timing-model">${model.series} ${
            model.capacity
          } ${model.color}</div>
            <div class="purchase-timing-details">
              <div class="purchase-timing-detail">
                <span class="purchase-timing-label">現在の価格差</span>
                <span class="purchase-timing-value ${
                  model.difference >= 0 ? 'positive' : 'negative'
                }">
                  ¥${Math.abs(model.difference).toLocaleString()} (${
            model.differencePercentage
          }%)
                </span>
              </div>
              ${
                predictionData
                  ? `
                <div class="purchase-timing-detail">
                  <span class="purchase-timing-label">予測トレンド</span>
                  <span class="purchase-timing-value ${
                    predictionData.trend === 'down' ? 'positive' : 'negative'
                  }">
                    ${predictionData.trend === 'down' ? '下落傾向' : '上昇傾向'}
                  </span>
                </div>
                <div class="purchase-timing-detail">
                  <span class="purchase-timing-label">予測信頼度</span>
                  <span class="purchase-timing-value">
                    ${Math.round(
                      (1 -
                        predictionData.predictions[0].confidence_interval /
                          model.kaitoriPrice) *
                        100
                    )}%
                  </span>
                </div>
              `
                  : ''
              }
            </div>
            <div class="purchase-timing-recommendation">
              <strong>推奨アクション:</strong> ${
                model.recommendation.timing
              }<br>
              <strong>理由:</strong> ${model.recommendation.reason}
            </div>
            <div class="purchase-timing-score">
              提案スコア: ${model.score}/100
            </div>
          `;

          cardsContainer.appendChild(card);
        });
      }

      // ページ読み込み時に購入タイミングセクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createPurchaseTimingSection();
        updatePurchaseTiming();
      });

      // 価格アラート設定の処理
      document
        .getElementById('alertForm')
        .addEventListener('submit', async function (e) {
          e.preventDefault();
          const threshold = document.getElementById('alertThreshold').value;

          try {
            const response = await fetch('/set-alert', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ threshold: threshold }),
            });

            if (response.ok) {
              alert('アラートを設定しました');
            } else {
              alert('アラートの設定に失敗しました');
            }
          } catch (error) {
            console.error('Error:', error);
            alert('エラーが発生しました');
          }
        });
    </script>
  </body>
</html>
