This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
    docker-build-and-push.yml
    renovate.yaml
    scrape_prices.yml
    terraform.yml
  pull_request_template.md
artifacts/
  .gitkeep
config/
  __init__.py
  config.development.yaml
  config.production.yaml
  local_config.yaml
  manager.py
data/
  kaitori-rudea_prices.json
  official_prices.json
  price_history.json
  price_predictions.json
lambdas/
  check_prices_lambda/
    check_prices.py
  compare_prices_lambda/
    compare_prices.py
  deployment_verification_lambda/
    deployment_verification.py
  get_price_history_lambda/
    get_price_history.py
  get_prices_lambda/
    __init__.py
    lambda_function.py
    requirements.txt
    scraper.py
  line_notification_lambda/
    main.py
  predict_prices_lambda/
    predict_prices.py
  save_price_history_lambda/
    save_price_history.py
  smoke_test_lambda/
    smoke_test.py
  __init__.py
scripts/
  cleanup_api_gateway.py
  cleanup.py
  debug_check.sh
  deploy_lambda.sh
  deploy.py
  deployment-verification.py
  load_dynamodb_data.py
  local_dev.sh
  migrate_to_dynamodb.py
  README.md
  run_local.sh
  run_smoke_tests.py
  smoke-test.py
  test_line_notification.py
  test-line-connect.py
  verify_deployment.py
services/
  dynamodb_service.py
src/
  lambda_functions/
    get_prices_lambda/
      config/
        __init__.py
        config.production.yaml
        config.yaml
        manager.py
      scraper.py
  apple_scraper_for_rudea.py
templates/
  index.html
terraform/
  policies/
    terraform-policy.json
    trust-policy.json
  scripts/
    load_dynamodb_data.py
    package_lambda.py
    requirements.txt
  api_gateway.tf
  backup.tf
  cost_monitoring.tf
  disaster_recovery.tf
  dr_plan.tf
  dynamodb.tf
  iam.tf
  lambda.tf
  main.tf
  maintenance.tf
  monitoring.tf
  outputs.tf
  provider.tf
  requirements.txt
  security.tf
  terraform.tfvars
  variables.tf
terraform-render/
  main.tf
  variables.tf
tests/
  integration/
    test_config_integration.py
  unit/
    __init__.py
    scraper.py
    test_config_manager.py
    test_scraper.py
    test_validators.py
  __init__.py
  conftest.py
  pytest.ini
  test_config_manager.py
  test_scraper.py
.bandit
.dockerignore
.env.example
.gitignore
.python-version
app.py
bandit-results.json
create_patch.py
Dockerfile
options-integration-template.json
Procfile
README.md
renovate.json
repomix-output.txt
requirements-base.txt
requirements-test.txt
requirements-web.txt
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/pull_request_template.md">
## Issue

close #{IssueNumber}

### 作成内容

- [Issue](https://github.com/KonishiKenji/test-various-tools/issues/{IssueNumber})

## 確認事項

〜特になければ項目自体削除

## 備考
</file>

<file path="artifacts/.gitkeep">
# gitkeepファイル - artifactsディレクトリを維持するためのもの
# function_latest.zipのシンボリックリンクを保持するためのディレクトリ
</file>

<file path="config/__init__.py">
from .manager import AppConfig, ConfigManager, ScraperConfig, config

__all__ = ['AppConfig', 'ConfigManager', 'ScraperConfig', 'config']
</file>

<file path="config/config.development.yaml">
app:
  debug: true
  log_level: DEBUG
  secret_key: dev-secret-key

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
    - https://kaitori-rudeya.com/category/detail/205 # iPhone 16 e
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 30
  retry_count: 3
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
</file>

<file path="config/manager.py">
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Literal, Optional, Union
from urllib.parse import urlparse

import yaml
from dotenv import load_dotenv


@dataclass(frozen=True)
class ScraperConfig:
    """スクレイピング関連の設定を管理するデータクラス"""
    KAITORI_RUDEA_URLS: list  # 複数形に変更し、型をlistに
    APPLE_STORE_URL: str
    REQUEST_TIMEOUT: int
    RETRY_COUNT: int
    USER_AGENT: str

    # ScraperConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_urls()
        self._validate_timeout()
        self._validate_retry_count()
        # 型チェック
        if not isinstance(self.KAITORI_RUDEA_URLS, list):
            raise TypeError("KAITORI_RUDEA_URLS must be a list of strings")
        if not isinstance(self.APPLE_STORE_URL, str):
            raise TypeError("APPLE_STORE_URL must be a string")
        if not isinstance(self.REQUEST_TIMEOUT, int):
            raise TypeError("REQUEST_TIMEOUT must be an integer")
        if not isinstance(self.RETRY_COUNT, int):
            raise TypeError("RETRY_COUNT must be an integer")
        if not isinstance(self.USER_AGENT, str):
            raise TypeError("USER_AGENT must be a string")

    def _validate_urls(self) -> None:
        """URLの形式を検証"""
        for url in self.KAITORI_RUDEA_URLS + [self.APPLE_STORE_URL]:
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                raise ValueError(f"Invalid URL format: {url}")

    def _validate_timeout(self) -> None:
        """タイムアウト値の検証"""
        if not isinstance(self.REQUEST_TIMEOUT, int) or self.REQUEST_TIMEOUT <= 0:
            raise ValueError(f"REQUEST_TIMEOUT must be a positive integer, got {self.REQUEST_TIMEOUT}")

    def _validate_retry_count(self) -> None:
        """リトライ回数の検証"""
        if not isinstance(self.RETRY_COUNT, int) or self.RETRY_COUNT < 0:
            raise ValueError(f"RETRY_COUNT must be a non-negative integer, got {self.RETRY_COUNT}")

@dataclass(frozen=True)
class AppConfig:
    """アプリケーション全体の設定を管理するデータクラス"""
    DEBUG: bool
    SECRET_KEY: str
    LOG_LEVEL: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
    # AppConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_secret_key()
        self._validate_log_level()
        # 型チェック
        if not isinstance(self.DEBUG, bool):
            raise TypeError("DEBUG must be a boolean")
        if not isinstance(self.SECRET_KEY, str):
            raise TypeError("SECRET_KEY must be a string")
        if not isinstance(self.LOG_LEVEL, str):
            raise TypeError("LOG_LEVEL must be a string")

    def _validate_secret_key(self) -> None:
        """シークレットキーの検証"""
        if not self.SECRET_KEY or len(self.SECRET_KEY) < 16:
            raise ValueError("SECRET_KEY must be at least 16 characters long")

    def _validate_log_level(self) -> None:
        """ログレベルの検証"""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if self.LOG_LEVEL not in valid_levels:
            raise ValueError(f"LOG_LEVEL must be one of {valid_levels}")

class ConfigManager:
    """設定を一元管理するクラス"""
    def __init__(self, config_dir=None):
        self._config: Optional[dict] = None
        self._scraper_config: Optional[ScraperConfig] = None
        self._app_config: Optional[AppConfig] = None
        
        self.load_environment()
        self.load_config_file(config_dir)

    def load_environment(self) -> None:
        """環境変数を読み込む"""
        load_dotenv()
        self.env: str = os.getenv('FLASK_ENV', 'development')
        
    def load_config_file(self, config_dir=None) -> None:
        """設定ファイルを読み込む"""
        if config_dir is None:
            config_dir = Path(__file__).parent
        else:
            config_dir = Path(config_dir)
        
        config_file = config_dir / f'config.{self.env}.yaml'
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
            
        with open(config_file, 'r') as f:
            self._config = yaml.safe_load(f)

    @property
    def scraper(self) -> ScraperConfig:
        """スクレイピング設定を取得"""
        if self._scraper_config is None:
            self._scraper_config = ScraperConfig(
                KAITORI_RUDEA_URLS=self._config['scraper']['kaitori_rudea_urls'],
                APPLE_STORE_URL=self._config['scraper']['apple_store_url'],
                REQUEST_TIMEOUT=self._config['scraper']['request_timeout'],
                RETRY_COUNT=self._config['scraper']['retry_count'],
                USER_AGENT=self._config['scraper']['user_agent']
            )
        return self._scraper_config

    @property
    def app(self) -> AppConfig:
        """アプリケーション設定を取得"""
        if self._app_config is None:
            self._app_config = AppConfig(
                DEBUG=self._config['app']['debug'],
                SECRET_KEY=os.getenv('SECRET_KEY', 'default-secret-key'),
                LOG_LEVEL=self._config['app']['log_level']
            )
        return self._app_config

# シングルトンインスタンスを作成
config = ConfigManager()
</file>

<file path="scripts/cleanup_api_gateway.py">
import logging
import time

import boto3
from botocore.exceptions import ClientError

# ロガーの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def delete_api_with_retry(apigw, api, max_retries=5, initial_wait=5):
    """指数バックオフを使用してAPIを削除する"""
    for attempt in range(max_retries):
        try:
            apigw.delete_rest_api(restApiId=api['id'])
            logger.info(f"Successfully deleted API: {api['name']}")
            return True
        except ClientError as e:
            if e.response['Error']['Code'] == 'TooManyRequestsException':
                wait_time = initial_wait * (2 ** attempt)  # 指数バックオフ
                if attempt < max_retries - 1:
                    logger.warning(f"Rate limit reached. Waiting {wait_time} seconds before retry {attempt + 1}/{max_retries}...")
                    time.sleep(wait_time)
                else:
                    logger.error(f"Failed to delete API {api['name']} after {max_retries} retries")
                    return False
            else:
                logger.error(f"Error deleting API {api['name']}: {str(e)}")
                return False
        except Exception as e:
            logger.error(f"Unexpected error deleting API {api['name']}: {str(e)}")
            return False
    return False

def cleanup_api_gateway():
    try:
        # API Gatewayクライアントの作成
        apigw = boto3.client('apigateway')
        
        # 既存のAPIを取得
        apis = apigw.get_rest_apis()['items']
        logger.info(f"Found {len(apis)} APIs")
        
        # 現在使用中のAPIを除外
        current_api_id = 'l8l7v5xw9d'  # 現在使用中のAPI ID
        apis_to_delete = [api for api in apis if api['id'] != current_api_id]
        
        logger.info(f"Deleting {len(apis_to_delete)} old APIs")
        
        # 各APIを削除
        success_count = 0
        failed_apis = []
        
        for api in apis_to_delete:
            logger.info(f"Deleting API: {api['name']} (ID: {api['id']})")
            if delete_api_with_retry(apigw, api):
                success_count += 1
                time.sleep(3)  # 成功後も少し待機
            else:
                failed_apis.append(api)
        
        # 結果の表示
        logger.info(f"Cleanup completed. Successfully deleted {success_count} APIs.")
        if failed_apis:
            logger.warning(f"Failed to delete {len(failed_apis)} APIs:")
            for api in failed_apis:
                logger.warning(f"  - {api['name']} (ID: {api['id']})")
    
    except Exception as e:
        logger.error(f"Error during API Gateway cleanup: {str(e)}")

if __name__ == "__main__":
    cleanup_api_gateway()
</file>

<file path="scripts/debug_check.sh">
read -p "スクリプトを開始しますか？ (yes/no): " response
if [[ $response =~ ^([yY][eE][sS]|[yY])$ ]]
then
    read -p "ログを残しますか？ (yes/no): " log_response
    if [[ $log_response =~ ^([yY][eE][sS]|[yY])$ ]]
    then
        script lambda-deploy.log
    else
        script ex-log.log
    fi
    ls -la artifacts/lambda/
    ls -la artifacts/lambda/function_latest.zip
    # スクリプトに実行権限を付与（初回のみ）
    chmod +x scripts/deploy_lambda.sh

    # デプロイパッケージを作成
    if ./scripts/deploy_lambda.sh; then
        aws lambda update-function-code \
            --function-name get_prices_lambda \
            --zip-file fileb://artifacts/lambda/function_latest
    else
        echo "デプロイパッケージの作成に失敗しました。処理を終了します。"
        exit 1
    fi
else
    echo "スクリプトを開始しない"
fi
</file>

<file path="scripts/deploy_lambda.sh">
<<COMMENT 
# ディレクトリ構造
project/
├── src/
│   ├── apple_scraper_for_rudea.py
│   └── apple_scraper.py
├── services/
│   └── dynamodb_service.py
├── lambda/
│   ├── get_prices_lambda.py
│   └── lambda_handler.py
├── scripts/
│   └── deploy_lambda.sh
├── artifacts/
│   └── lambda/
│       ├── function_20240318_123456.zip
│       ├── function_20240318_234567.zip
│       └── function_latest.zip -> function_20240318_234567.zip
└── requirements.txt

# デプロイスクリプト

## デプロイパッケージを作成してアップロード
./scripts/deploy_lambda.sh

COMMENT

#!/bin/bash

# スクリプトのディレクトリを取得
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"

# プロジェクトのルートディレクトリに移動
cd "$PROJECT_ROOT"

# デプロイパッケージの保存ディレクトリ
ARTIFACTS_DIR="artifacts/lambda"
mkdir -p $ARTIFACTS_DIR

# タイムスタンプ付きのファイル名を生成
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
FUNCTION_ZIP="function_${TIMESTAMP}.zip"
FUNCTION_PATH="$ARTIFACTS_DIR/$FUNCTION_ZIP"

# デプロイ用の一時ディレクトリを作成
DEPLOY_DIR="deploy_tmp"
rm -rf $DEPLOY_DIR
mkdir -p $DEPLOY_DIR

echo "必要なファイルをコピー中..."
# Lambda関数のコードをコピー
cp lambda/get_prices_lambda/lambda_function.py $DEPLOY_DIR/
cp -r src $DEPLOY_DIR/
cp -r services $DEPLOY_DIR/
cp -r config $DEPLOY_DIR/  # 設定ファイルをコピー

echo "依存関係をインストール中..."
# 依存関係をインストール
pip3 install requests beautifulsoup4 boto3 pyyaml -t $DEPLOY_DIR/

echo "デプロイパッケージを作成中..."
# デプロイパッケージを作成
cd $DEPLOY_DIR
zip -r ../$FUNCTION_PATH .

# プロジェクトルートに戻る
cd "$PROJECT_ROOT"

# 一時ディレクトリを削除
rm -rf $DEPLOY_DIR

echo "デプロイパッケージ $FUNCTION_PATH が作成されました"

# 最新のzipファイルへのシンボリックリンクを作成
cd $ARTIFACTS_DIR
ln -sf $FUNCTION_ZIP function_latest.zip
cd "$PROJECT_ROOT"

echo "シンボリックリンク $ARTIFACTS_DIR/function_latest.zip が更新されました"

# IAMロールの作成（存在しない場合）
aws iam create-role \
    --role-name get_prices_lambda_role \
    --assume-role-policy-document '{
        "Version": "2012-10-17",
        "Statement": [{
            "Effect": "Allow",
            "Principal": {
                "Service": "lambda.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }]
    }' || true

# DynamoDB アクセス権限の追加
aws iam put-role-policy \
    --role-name get_prices_lambda_role \
    --policy-name dynamodb-access \
    --policy-document '{
        "Version": "2012-10-17",
        "Statement": [{
            "Effect": "Allow",
            "Action": [
                "dynamodb:GetItem",
                "dynamodb:Query"
            ],
            "Resource": "arn:aws:dynamodb:ap-northeast-1:*:table/iphone_prices"
        }]
    }' || true

# CloudWatch Logs アクセス権限の追加
aws iam attach-role-policy \
    --role-name get_prices_lambda_role \
    --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole || true

# Lambda関数の更新
aws lambda update-function-code \
    --function-name get_prices_lambda \
    --zip-file fileb://$ARTIFACTS_DIR/function_latest.zip

# Lambda関数の設定更新
aws lambda update-function-configuration \
    --function-name get_prices_lambda \
    --handler lambda_function.lambda_handler \
    --role "arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/get_prices_lambda_role" \
    --timeout 30 \
    --memory-size 256

echo "Lambda関数が更新されました"

# DynamoDBテーブルの作成（存在しない場合）
aws dynamodb create-table \
    --table-name iphone_prices \
    --attribute-definitions \
        AttributeName=series,AttributeType=S \
    --key-schema \
        AttributeName=series,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST || true

# テーブルが作成されるのを待機
aws dynamodb wait table-exists --table-name iphone_prices

# サンプルデータの投入
aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16"},
        "prices": {"M": {
            "128GB": {"S": "124800"},
            "256GB": {"S": "139800"},
            "512GB": {"S": "169800"}
        }}
    }'

aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16 Pro"},
        "prices": {"M": {
            "128GB": {"S": "159800"},
            "256GB": {"S": "174800"},
            "512GB": {"S": "204800"},
            "1TB": {"S": "234800"}
        }}
    }'

aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16 Pro Max"},
        "prices": {"M": {
            "256GB": {"S": "189800"},
            "512GB": {"S": "219800"},
            "1TB": {"S": "249800"}
        }}
    }'
</file>

<file path="scripts/migrate_to_dynamodb.py">
import json

import boto3

# AWS DynamoDBクライアントの初期化
dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-1')
table = dynamodb.Table('official_prices')

# JSONファイルの読み込み
with open('data/official_prices.json', 'r', encoding='utf-8') as file:
    data = json.load(file)

# DynamoDBにデータを挿入
for series, capacities in data.items():
    for capacity, colors in capacities.items():
        item = {
            'series': series,
            'capacity': capacity,
            'color_prices': colors  # 各カラーの価格情報を保存
        }
        table.put_item(Item=item)
        print(f"Inserted: {series} - {capacity}")

print("データ移行完了！")
</file>

<file path="services/dynamodb_service.py">
import boto3
from boto3.dynamodb.conditions import Key

# DynamoDBテーブル名を指定
DYNAMODB_TABLE_NAME = "official_prices"

def get_prices_by_series(series_name):
    """指定されたシリーズの買取価格を取得"""
    try:
        dynamodb = boto3.resource("dynamodb")
        table = dynamodb.Table(DYNAMODB_TABLE_NAME)

        # クエリ実行
        response = table.query(
            KeyConditionExpression=Key("series").eq(series_name)
        )
        return response.get("Items", [])
    except Exception as e:
        print(f"Error querying DynamoDB: {str(e)}")
        raise
</file>

<file path="src/apple_scraper_for_rudea.py">
import json
import logging
import os
import re
import traceback
from decimal import Decimal
from pathlib import Path

import boto3
import requests
import yaml
from bs4 import BeautifulSoup

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Decimalを処理するJSONエンコーダを追加
class DecimalEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Decimal):
            return int(obj) if obj % 1 == 0 else float(obj)
        return super(DecimalEncoder, self).default(obj)

def load_config():
    try:
        # Lambda環境での設定ファイルのパスを確認
        lambda_config_path = '/var/task/config/config.production.yaml'
        local_config_path = Path(__file__).parent.parent / 'config' / 'config.production.yaml'
        
        if os.path.exists(lambda_config_path):
            logger.info(f"Loading config from Lambda path: {lambda_config_path}")
            with open(lambda_config_path, 'r') as f:
                return yaml.safe_load(f)
        elif os.path.exists(local_config_path):
            logger.info(f"Loading config from local path: {local_config_path}")
            with open(local_config_path, 'r') as f:
                return yaml.safe_load(f)
        else:
            logger.error("Config file not found in either Lambda or local path")
            return None
    except Exception as e:
        logger.error(f"Error loading config: {e}")
        logger.error(f"Current working directory: {os.getcwd()}")
        logger.error(f"Directory contents: {os.listdir()}")
        return None

def get_official_prices(series):
    try:
        dynamodb = boto3.resource('dynamodb')
        table = dynamodb.Table('official_prices')
        
        # Handle both "iPhone 16e" and "iPhone 16 e" formats
        lookup_series = series.replace(' e', 'e') if ' e' in series else series
        logger.info(f"Looking up official prices for {lookup_series} (original request: {series})")
        
        # 各容量の価格を取得
        formatted_prices = {}
        capacities = ['128GB', '256GB', '512GB', '1TB']
        
        for capacity in capacities:
            try:
                response = table.get_item(
                    Key={
                        'series': lookup_series,
                        'capacity': capacity
                    }
                )
                
                if 'Item' in response:
                    # 各色の価格から最小値を取得
                    colors = response['Item'].get('colors', {})
                    if colors:
                        min_price = min(Decimal(str(price)) for price in colors.values())
                        formatted_prices[capacity] = str(min_price)
                        logger.info(f"Found price for {lookup_series} {capacity}: {min_price}")
                    else:
                        logger.warning(f"No color prices found for {lookup_series} {capacity}")
                else:
                    logger.warning(f"No data found for {lookup_series} {capacity}")
            except Exception as e:
                logger.error(f"Error getting price for {capacity}: {e}")
                logger.error(f"Stack trace: {traceback.format_exc()}")
                continue
        
        if not formatted_prices:
            logger.warning(f"No official prices found for {lookup_series}")
        else:
            logger.info(f"Found official prices for {lookup_series}: {formatted_prices}")
        return formatted_prices
            
    except Exception as e:
        logger.error(f"Error getting official prices: {e}")
        logger.error(f"Stack trace: {traceback.format_exc()}")
        return {}

def get_kaitori_prices(series):
    try:
        logger.info(f"Starting price fetch for series: {series}")
        config = load_config()
        
        if not config:
            logger.error("Failed to load configuration, using fallback URLs")
            # フォールバックURLを使用
            fallback_urls = {
                'iPhone 16': 'https://www.rudea.net/iphone16',
                'iPhone 16 Pro': 'https://www.rudea.net/iphone16pro',
                'iPhone 16 Pro Max': 'https://www.rudea.net/iphone16promax',
                'iPhone 16 e': 'https://www.rudea.net/iphone16e',
                'iPhone 16e': 'https://www.rudea.net/iphone16e'
            }
            series_url_map = fallback_urls
        else:
            series_url_map = {
                'iPhone 16': config['scraper']['kaitori_rudea_urls'][0],
                'iPhone 16 Pro': config['scraper']['kaitori_rudea_urls'][1],
                'iPhone 16 Pro Max': config['scraper']['kaitori_rudea_urls'][2],
                'iPhone 16 e': config['scraper']['kaitori_rudea_urls'][3],
                'iPhone 16e': config['scraper']['kaitori_rudea_urls'][3]
            }
        
        logger.info(f"Looking up URL for series: {series}, Available mappings: {list(series_url_map.keys())}")
        
        if series not in series_url_map:
            logger.warning(f"No URL configured for series: {series}")
            return {
                series: {
                    'kaitori': {},
                    'official': get_official_prices(series)
                }
            }

        url = series_url_map[series]
        headers = {
            'User-Agent': config.get('scraper', {}).get('user_agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')
        }
        timeout = config.get('scraper', {}).get('request_timeout', 10)
        
        logger.info(f"Fetching data from URL: {url} with timeout: {timeout}")
        
        try:
            response = requests.get(url, headers=headers, timeout=timeout)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            logger.info(f"HTML content length: {len(response.text)}")
            
            # デバッグ用にHTML構造を解析
            main_content = soup.find('div', class_='main-content')
            if main_content:
                logger.info("Found main-content div")
                logger.info(f"Main content structure: {[elem.name for elem in main_content.children if elem.name]}")
            else:
                logger.warning("Main content div not found")
                logger.info(f"Available top-level divs: {[div.get('class', []) for div in soup.find_all('div', recursive=False)]}")
            
            # 買取価格データを抽出
            kaitori_prices = {}
            
            # 価格情報を含む要素を探す
            price_elements = soup.find_all('div', class_='tr')
            if price_elements:
                logger.info(f"Found {len(price_elements)} price elements")
                for elem in price_elements:
                    try:
                        # 容量を探す
                        capacity_elem = elem.find('h2') or elem.find('div', class_='ttl')
                        # 価格を探す
                        price_elem = elem.find('div', class_='td2wrap') or elem.find('div', class_='td td2')
                        
                        if capacity_elem and price_elem:
                            capacity_text = capacity_elem.text.strip()
                            capacity_match = re.search(r'(\d+)\s*(GB|TB)', capacity_text, re.IGNORECASE)
                            if capacity_match:
                                capacity_num = capacity_match.group(1)
                                capacity_unit = capacity_match.group(2).upper()
                                capacity = f"{capacity_num}{capacity_unit}"
                                price = re.sub(r'[^\d]', '', price_elem.text.strip())
                                if price:
                                    kaitori_prices[capacity] = price
                                    logger.info(f"Found price for {capacity}: {price}")
                                else:
                                    logger.warning(f"Empty price found for {capacity}")
                            else:
                                logger.warning(f"Could not extract capacity from: {capacity_text}")
                        else:
                            logger.warning(f"Missing capacity or price element in: {elem}")
                    except Exception as e:
                        logger.error(f"Error processing price element: {e}")
                        logger.error(f"Element content: {elem}")
                        continue
                
                if not kaitori_prices:
                    logger.warning("No valid price data found in elements")
            else:
                logger.warning("No price elements found")
                logger.info(f"Page title: {soup.title.string if soup.title else 'No title'}")
            
            # 公式価格を取得
            official_prices = get_official_prices(series)
            
            result = {
                series: {
                    'kaitori': kaitori_prices,
                    'official': official_prices
                }
            }
            
            logger.info(f"Returning data for {series}: {json.dumps(result, indent=4, cls=DecimalEncoder)}")
            return result
            
        except requests.RequestException as e:
            logger.error(f"Failed to fetch data from URL: {e}")
            logger.error(f"Response status code: {getattr(e.response, 'status_code', 'N/A')}")
            logger.error(f"Response content: {getattr(e.response, 'text', 'N/A')[:500]}")
            return {
                series: {
                    'kaitori': {},
                    'official': get_official_prices(series)
                }
            }
            
    except Exception as e:
        logger.error(f"Error in get_kaitori_prices: {e}")
        logger.error(f"Stack trace: {traceback.format_exc()}")
        return {
            series: {
                'kaitori': {},
                'official': get_official_prices(series)
            }
        }
</file>

<file path="terraform-render/main.tf">
resource "render_postgresql" "price-comparison-app" {
  name     = var.db_name
  database = var.db_name
  user     = var.db_user
  password = var.db_password
  region   = var.db_region
  version  = var.db_version
}

output "database_url" {
  value = render_postgresql.price-comparison-app.connection_string
}
</file>

<file path="terraform-render/variables.tf">
variable "db_name" {
  default     = "price-comparison-app"
  description = "The name of the PostgreSQL database"
}

variable "db_user" {
  default     = "app_user"
  description = "The username for the PostgreSQL database"
}

variable "db_password" {
  description = "The password for the PostgreSQL user"
  type        = string
}

variable "db_region" {
  default     = "oregon"
  description = "The region where the database will be hosted"
}

variable "db_version" {
  default     = "16"
  description = "The PostgreSQL version"
}
</file>

<file path=".env.example">
FLASK_ENV=development
SECRET_KEY=your-secret-key-here
</file>

<file path="create_patch.py">
import json
import subprocess

patch_data = {
    "op": "replace",
    "path": "/accessLogSettings/format",
    "value": json.dumps({  # Convert value to string here
        "requestId": "$context.requestId",
        "ip": "$context.identity.sourceIp",
        "requestTime": "$context.requestTime",
        "httpMethod": "$context.httpMethod",
        "resourcePath": "$context.resourcePath",
        "status": "$context.status",
        "protocol": "$context.protocol",
        "responseLength": "$context.responseLength"
    })
}

json_patch_string = json.dumps([patch_data])

try:
    result = subprocess.run(
        [
            "aws",
            "apigateway",
            "update-stage",
            "--rest-api-id",
            "qow3wyg1nj",
            "--stage-name",
            "prod",
            "--patch-operations",
            json_patch_string,
        ],
        check=True,
        capture_output=True,
        text=True,
    )
    print("API Gateway stage updated successfully!")
    print(result.stdout)
except subprocess.CalledProcessError as e:
    print(f"Error updating API Gateway stage: {e.stderr}")
    print(f"Return code: {e.returncode}")
except json.JSONEncoderError as e:
    print(f"Error encoding JSON: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
</file>

<file path="options-integration-template.json">
{
  "application/json": "{\"statusCode\": 200}"
}
</file>

<file path="Procfile">
web: gunicorn app:app
</file>

<file path="renovate.json">
{
  "extends": ["config:recommended", ":timezone(Asia/Tokyo)"],
  "labels": ["dependencies", "renovate"],
  "automerge": true,
  "pin": {
    "automerge": true
  },
  "packageRules": [
    {
      "packagePatterns": ["^@types/"],
      "automerge": true,
      "major": {
        "automerge": false
      }
    },
    {
      "groupName": "jest",
      "automerge": true,
      "sourceUrlPrefixes": [
        "https://github.com/facebook/jest",
        "https://github.com/kulshekhar/ts-jest"
      ]
    },
    {
      "groupName": "linters",
      "automerge": true,
      "extends": ["packages:linters"],
      "packageNames": ["prettier"],
      "packagePatterns": ["^@typescript-eslint/"]
    },
    {
      "matchDepTypes": ["githubActionsForWorkflows"],
      "groupName": "actions for github actions workflows",
      "automerge": true,
      "groupSlug": "actions-update-for-github-actions-workflows"
    },
    {
      "matchDepTypes": ["dockerImageForWorkflows"],
      "groupName": "docker image for github actions workflows",
      "automerge": true,
      "groupSlug": "docker-image-update-for-github-actions-workflows"
    },
    {
      "matchUpdateTypes": ["minor", "patch"],
      "automerge": true,
      "automergeType": "pr",
      "prConcurrentLimit": 10,
      "prPriority": -1,
      "matchPackageNames": [
        "!/@*/",
        "!/some-risky-package/",
        "!/another-risky-package/"
      ]
    },
    {
      "matchUpdateTypes": ["major"],
      "automerge": false,
      "prConcurrentLimit": 5,
      "prPriority": 1
    }
  ],
  "prConcurrentLimit": 10
}
</file>

<file path="repomix-output.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    deploy.yml
    docker-build-and-push.yml
config/
  __init__.py
  config.development.yaml
  config.production.yaml
  manager.py
data/
  official_prices.json
lambda/
  get_prices_lambda/
    lambda_function.py
  get_prices_lambda.py
scripts/
  debug_check.sh
  deploy_lambda.sh
  migrate_to_dynamodb.py
services/
  dynamodb_service.py
src/
  apple_scraper_for_rudea.py
  apple_scraper.py
templates/
  index.html
terraform-render/
  main.tf
  variables.tf
tests/
  integration/
    test_config_integration.py
  unit/
    test_validators.py
  conftest.py
  pytest.ini
  test_config_manager.py
.env.example
.gitignore
.python-version
app.py
create_patch.py
Dockerfile
options-integration-template.json
Procfile
README.md
renovate.json
requirements.txt

================================================================
Files
================================================================

================
File: .github/workflows/deploy.yml
================
name: Deploy to Render

on:
  push:
    branches:
      - main  # `main`ブランチへのプッシュをトリガー

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # コードをチェックアウト
      - name: Checkout code
        uses: actions/checkout@v4

      # Terraformのセットアップ
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      # Terraformの初期化
      - name: Initialize Terraform
        env:
          TF_VAR_db_password: ${{ secrets.RENDER_POSTGRESQL_DB_PASSWORD }}  # GitHub Secretsからパスワードを取得
        run: terraform init

      # Terraform構成の適用
      - name: Apply Terraform configuration
        env:
          TF_VAR_db_password: ${{ secrets.RENDER_POSTGRESQL_DB_PASSWORD }}  # GitHub Secretsからパスワードを取得
        run: terraform apply -auto-approve -input=false  # `input=false`を追加して自動承認

================
File: .github/workflows/docker-build-and-push.yml
================
name: Build, Push, and Deploy

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    name: Build, Push, and Deploy to Render
    runs-on: ubuntu-latest

    steps:
      # リポジトリをチェックアウト
      - name: Checkout repository
        uses: actions/checkout@v4

      # Dockerにログイン
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Dockerイメージをビルド＆プッシュ
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: |
            koninji/price-comparison-app:latest

      # Renderのサービス一覧からサービスIDを取得
      - name: Fetch Render Service ID
        id: fetch-service-id
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          SERVICE_ID=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            https://api.render.com/v1/services \
            | jq -r '.[] | select(.service.name=="price-comparison-app:latest") | .service.id')

          if [ -z "$SERVICE_ID" ]; then
            echo "Service ID not found for 'price-comparison-app:latest'."
            exit 1
          fi

          echo "SERVICE_ID=$SERVICE_ID" >> $GITHUB_ENV

      # Renderでデプロイをトリガー
      - name: Trigger Render Deploy
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          curl -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Content-Type: application/json" \
            https://api.render.com/v1/services/$SERVICE_ID/deploys

================
File: config/__init__.py
================
from .manager import AppConfig, ConfigManager, ScraperConfig, config

__all__ = ['AppConfig', 'ConfigManager', 'ScraperConfig', 'config']

================
File: config/config.development.yaml
================
app:
  debug: true
  log_level: DEBUG
  secret_key: dev-secret-key

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 30
  retry_count: 3
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'

================
File: config/config.production.yaml
================
app:
  debug: false
  log_level: INFO
  # secret_keyは環境変数から取得するため、ここには記載しない

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 60
  retry_count: 5
  user_agent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'

================
File: config/manager.py
================
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Literal, Optional, Union
from urllib.parse import urlparse

import yaml
from dotenv import load_dotenv


@dataclass(frozen=True)
class ScraperConfig:
    """スクレイピング関連の設定を管理するデータクラス"""
    KAITORI_RUDEA_URLS: list  # 複数形に変更し、型をlistに
    APPLE_STORE_URL: str
    REQUEST_TIMEOUT: int
    RETRY_COUNT: int
    USER_AGENT: str

    # ScraperConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_urls()
        self._validate_timeout()
        self._validate_retry_count()
        # 型チェック
        if not isinstance(self.KAITORI_RUDEA_URLS, list):
            raise TypeError("KAITORI_RUDEA_URLS must be a list of strings")
        if not isinstance(self.APPLE_STORE_URL, str):
            raise TypeError("APPLE_STORE_URL must be a string")
        if not isinstance(self.REQUEST_TIMEOUT, int):
            raise TypeError("REQUEST_TIMEOUT must be an integer")
        if not isinstance(self.RETRY_COUNT, int):
            raise TypeError("RETRY_COUNT must be an integer")
        if not isinstance(self.USER_AGENT, str):
            raise TypeError("USER_AGENT must be a string")

    def _validate_urls(self) -> None:
        """URLの形式を検証"""
        for url in self.KAITORI_RUDEA_URLS + [self.APPLE_STORE_URL]:
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                raise ValueError(f"Invalid URL format: {url}")

    def _validate_timeout(self) -> None:
        """タイムアウト値の検証"""
        if not isinstance(self.REQUEST_TIMEOUT, int) or self.REQUEST_TIMEOUT <= 0:
            raise ValueError(f"REQUEST_TIMEOUT must be a positive integer, got {self.REQUEST_TIMEOUT}")

    def _validate_retry_count(self) -> None:
        """リトライ回数の検証"""
        if not isinstance(self.RETRY_COUNT, int) or self.RETRY_COUNT < 0:
            raise ValueError(f"RETRY_COUNT must be a non-negative integer, got {self.RETRY_COUNT}")

@dataclass(frozen=True)
class AppConfig:
    """アプリケーション全体の設定を管理するデータクラス"""
    DEBUG: bool
    SECRET_KEY: str
    LOG_LEVEL: Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
    # AppConfig 型検証を __post_init__ メソッド内で実装
    def __post_init__(self):
        self._validate_secret_key()
        self._validate_log_level()
        # 型チェック
        if not isinstance(self.DEBUG, bool):
            raise TypeError("DEBUG must be a boolean")
        if not isinstance(self.SECRET_KEY, str):
            raise TypeError("SECRET_KEY must be a string")
        if not isinstance(self.LOG_LEVEL, str):
            raise TypeError("LOG_LEVEL must be a string")

    def _validate_secret_key(self) -> None:
        """シークレットキーの検証"""
        if not self.SECRET_KEY or len(self.SECRET_KEY) < 16:
            raise ValueError("SECRET_KEY must be at least 16 characters long")

    def _validate_log_level(self) -> None:
        """ログレベルの検証"""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if self.LOG_LEVEL not in valid_levels:
            raise ValueError(f"LOG_LEVEL must be one of {valid_levels}")

class ConfigManager:
    """設定を一元管理するクラス"""
    def __init__(self, config_dir=None):
        self._config: Optional[dict] = None
        self._scraper_config: Optional[ScraperConfig] = None
        self._app_config: Optional[AppConfig] = None
        
        self.load_environment()
        self.load_config_file(config_dir)

    def load_environment(self) -> None:
        """環境変数を読み込む"""
        load_dotenv()
        self.env: str = os.getenv('FLASK_ENV', 'development')
        
    def load_config_file(self, config_dir=None) -> None:
        """設定ファイルを読み込む"""
        if config_dir is None:
            config_dir = Path(__file__).parent
        else:
            config_dir = Path(config_dir)
        
        config_file = config_dir / f'config.{self.env}.yaml'
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
            
        with open(config_file, 'r') as f:
            self._config = yaml.safe_load(f)

    @property
    def scraper(self) -> ScraperConfig:
        """スクレイピング設定を取得"""
        if self._scraper_config is None:
            self._scraper_config = ScraperConfig(
                KAITORI_RUDEA_URLS=self._config['scraper']['kaitori_rudea_urls'],
                APPLE_STORE_URL=self._config['scraper']['apple_store_url'],
                REQUEST_TIMEOUT=self._config['scraper']['request_timeout'],
                RETRY_COUNT=self._config['scraper']['retry_count'],
                USER_AGENT=self._config['scraper']['user_agent']
            )
        return self._scraper_config

    @property
    def app(self) -> AppConfig:
        """アプリケーション設定を取得"""
        if self._app_config is None:
            self._app_config = AppConfig(
                DEBUG=self._config['app']['debug'],
                SECRET_KEY=os.getenv('SECRET_KEY', 'default-secret-key'),
                LOG_LEVEL=self._config['app']['log_level']
            )
        return self._app_config

# シングルトンインスタンスを作成
config = ConfigManager()

================
File: data/official_prices.json
================
{
  "iPhone 16": {
    "128GB": {
      "black 黒 MYDQ3J/A 未開封 SIMフリー": 124800,
      "pink 桃 MYDT3J/A 未開封 SIMフリー": 124800,
      "teal 緑 MYDV3J/A 未開封 SIMフリー": 124800,
      "ultramarine 青 MYDU3J/A 未開封 SIMフリー": 124800,
      "white 白 MYDR3J/A 未開封 SIMフリー": 124800
    },
    "256GB": {
      "black 黒 MYDW3J/A 未開封 SIMフリー": 139800,
      "pink 桃 MYDY3J/A 未開封 SIMフリー": 139800,
      "teal 緑 MYDZ3J/A 未開封 SIMフリー": 139800,
      "ultramarine 青 MYDX3J/A 未開封 SIMフリー": 139800,
      "white 白 MYDW3J/A 未開封 SIMフリー": 139800
    },
    "512GB": {
      "black 黒 MYDQ3J/A 未開封 SIMフリー": 169800,
      "pink 桃 MYDT3J/A 未開封 SIMフリー": 169800,
      "teal 緑 MYDV3J/A 未開封 SIMフリー": 169800,
      "ultramarine 青 MYDU3J/A 未開封 SIMフリー": 169800,
      "white 白 MYDR3J/A 未開封 SIMフリー": 169800
    }
  },
  "iPhone 16 Pro": {
    "128GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 161000,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 161000,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 161000,
      "white 白 MYWK3J/A 未開封 SIMフリー": 161000
    },
    "256GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 177500,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 177500,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 177500,
      "white 白 MYWK3J/A 未開封 SIMフリー": 177500
    },
    "512GB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 204000,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 204000,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 204000,
      "white 白 MYWR3J/A 未開封 SIMフリー": 204000
    },
    "1TB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 234000,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 234000,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 234000,
      "white 白 MYWR3J/A 未開封 SIMフリー": 234000
    }
  },
  "iPhone 16 Pro Max": {
    "256GB": {
      "black 黒 MYWG3J/A 未開封 SIMフリー": 189800,
      "desert 金 MYWH3J/A 未開封 SIMフリー": 189800,
      "natural 灰 MYWJ3J/A 未開封 SIMフリー": 189800,
      "white 白 MYWK3J/A 未開封 SIMフリー": 189800
    },
    "512GB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 219800,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 219800,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 219800,
      "white 白 MYWR3J/A 未開封 SIMフリー": 219800
    },
    "1TB": {
      "black 黒 MYWQ3J/A 未開封 SIMフリー": 249800,
      "desert 金 MYWT3J/A 未開封 SIMフリー": 249800,
      "natural 灰 MYWU3J/A 未開封 SIMフリー": 249800,
      "white 白 MYWR3J/A 未開封 SIMフリー": 249800
    }
  }
}

================
File: lambda/get_prices_lambda/lambda_function.py
================
import json
import logging
import os
import sys

# srcディレクトリをPythonパスに追加
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(os.path.dirname(current_dir))
sys.path.append(project_root)

from src.apple_scraper_for_rudea import get_kaitori_prices

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    try:
        logger.info("Lambda function started")
        logger.info(f"Event: {json.dumps(event)}")
        
        # クエリパラメータからseriesを取得
        query_params = event.get('queryStringParameters', {})
        if not query_params:
            logger.error("No query parameters found")
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET,OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
                },
                'body': json.dumps({'error': 'Query parameters are required'})
            }

        series = query_params.get('series')
        if not series:
            logger.error("Series parameter is missing")
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET,OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
                },
                'body': json.dumps({'error': 'series parameter is required'})
            }

        logger.info(f"Fetching prices for series: {series}")
        
        # 価格データを取得
        prices = get_kaitori_prices(series=series)
        
        logger.info(f"Retrieved prices: {prices}")
        
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET,OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
            },
            'body': json.dumps(prices)
        }

    except Exception as e:
        logger.error(f"Error: {str(e)}")
        logger.error(f"Error type: {type(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET,OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
            },
            'body': json.dumps({
                'error': str(e),
                'detail': 'An error occurred while processing your request'
            })
        }

================
File: lambda/get_prices_lambda.py
================
import json
import logging

from src.apple_scraper_for_rudea import get_kaitori_prices

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    try:
        # クエリパラメータからseriesを取得
        query_params = event.get('queryStringParameters', {})
        if not query_params:
            logger.error("No query parameters found")
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET,OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
                },
                'body': json.dumps({'error': 'Query parameters are required'})
            }

        series = query_params.get('series')
        if not series:
            logger.error("Series parameter is missing")
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET,OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
                },
                'body': json.dumps({'error': 'series parameter is required'})
            }

        logger.info(f"Fetching prices for series: {series}")
        
        # 価格データを取得（seriesパラメータを明示的に渡す）
        prices = get_kaitori_prices(series=series)  # キーワード引数として渡す
        
        logger.info(f"Retrieved prices: {prices}")
        
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET,OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
            },
            'body': json.dumps(prices)
        }

    except Exception as e:
        logger.error(f"Error: {str(e)}")
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET,OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
            },
            'body': json.dumps({
                'error': str(e),
                'detail': 'An error occurred while processing your request'
            })
        }

================
File: scripts/debug_check.sh
================
read -p "スクリプトを開始しますか？ (yes/no): " response
if [[ $response =~ ^([yY][eE][sS]|[yY])$ ]]
then
    read -p "ログを残しますか？ (yes/no): " log_response
    if [[ $log_response =~ ^([yY][eE][sS]|[yY])$ ]]
    then
        script lambda-deploy.log
    else
        script ex-log.log
    fi
    ls -la artifacts/lambda/
    ls -la artifacts/lambda/function_latest.zip
    # スクリプトに実行権限を付与（初回のみ）
    chmod +x scripts/deploy_lambda.sh

    # デプロイパッケージを作成
    if ./scripts/deploy_lambda.sh; then
        aws lambda update-function-code \
            --function-name get_prices_lambda \
            --zip-file fileb://artifacts/lambda/function_latest
    else
        echo "デプロイパッケージの作成に失敗しました。処理を終了します。"
        exit 1
    fi
else
    echo "スクリプトを開始しない"
fi

================
File: scripts/deploy_lambda.sh
================
<<COMMENT 
# ディレクトリ構造
project/
├── src/
│   ├── apple_scraper_for_rudea.py
│   └── apple_scraper.py
├── services/
│   └── dynamodb_service.py
├── lambda/
│   ├── get_prices_lambda.py
│   └── lambda_handler.py
├── scripts/
│   └── deploy_lambda.sh
├── artifacts/
│   └── lambda/
│       ├── function_20240318_123456.zip
│       ├── function_20240318_234567.zip
│       └── function_latest.zip -> function_20240318_234567.zip
└── requirements.txt

# デプロイスクリプト

## デプロイパッケージを作成してアップロード
./scripts/deploy_lambda.sh

COMMENT

#!/bin/bash

# スクリプトのディレクトリを取得
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"

# プロジェクトのルートディレクトリに移動
cd "$PROJECT_ROOT"

# デプロイパッケージの保存ディレクトリ
ARTIFACTS_DIR="artifacts/lambda"
mkdir -p $ARTIFACTS_DIR

# タイムスタンプ付きのファイル名を生成
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
FUNCTION_ZIP="function_${TIMESTAMP}.zip"
FUNCTION_PATH="$ARTIFACTS_DIR/$FUNCTION_ZIP"

# デプロイ用の一時ディレクトリを作成
DEPLOY_DIR="deploy_tmp"
rm -rf $DEPLOY_DIR
mkdir -p $DEPLOY_DIR

echo "必要なファイルをコピー中..."
# Lambda関数のコードをコピー
cp lambda/get_prices_lambda/lambda_function.py $DEPLOY_DIR/
cp -r src $DEPLOY_DIR/
cp -r services $DEPLOY_DIR/
cp -r config $DEPLOY_DIR/  # 設定ファイルをコピー

echo "依存関係をインストール中..."
# 依存関係をインストール
pip3 install requests beautifulsoup4 boto3 pyyaml -t $DEPLOY_DIR/

echo "デプロイパッケージを作成中..."
# デプロイパッケージを作成
cd $DEPLOY_DIR
zip -r ../$FUNCTION_PATH .

# プロジェクトルートに戻る
cd "$PROJECT_ROOT"

# 一時ディレクトリを削除
rm -rf $DEPLOY_DIR

echo "デプロイパッケージ $FUNCTION_PATH が作成されました"

# 最新のzipファイルへのシンボリックリンクを作成
cd $ARTIFACTS_DIR
ln -sf $FUNCTION_ZIP function_latest.zip
cd "$PROJECT_ROOT"

echo "シンボリックリンク $ARTIFACTS_DIR/function_latest.zip が更新されました"

# IAMロールの作成（存在しない場合）
aws iam create-role \
    --role-name get_prices_lambda_role \
    --assume-role-policy-document '{
        "Version": "2012-10-17",
        "Statement": [{
            "Effect": "Allow",
            "Principal": {
                "Service": "lambda.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }]
    }' || true

# DynamoDB アクセス権限の追加
aws iam put-role-policy \
    --role-name get_prices_lambda_role \
    --policy-name dynamodb-access \
    --policy-document '{
        "Version": "2012-10-17",
        "Statement": [{
            "Effect": "Allow",
            "Action": [
                "dynamodb:GetItem",
                "dynamodb:Query"
            ],
            "Resource": "arn:aws:dynamodb:ap-northeast-1:*:table/iphone_prices"
        }]
    }' || true

# CloudWatch Logs アクセス権限の追加
aws iam attach-role-policy \
    --role-name get_prices_lambda_role \
    --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole || true

# Lambda関数の更新
aws lambda update-function-code \
    --function-name get_prices_lambda \
    --zip-file fileb://$ARTIFACTS_DIR/function_latest.zip

# Lambda関数の設定更新
aws lambda update-function-configuration \
    --function-name get_prices_lambda \
    --handler lambda_function.lambda_handler \
    --role "arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/get_prices_lambda_role" \
    --timeout 30 \
    --memory-size 256

echo "Lambda関数が更新されました"

# DynamoDBテーブルの作成（存在しない場合）
aws dynamodb create-table \
    --table-name iphone_prices \
    --attribute-definitions \
        AttributeName=series,AttributeType=S \
    --key-schema \
        AttributeName=series,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST || true

# テーブルが作成されるのを待機
aws dynamodb wait table-exists --table-name iphone_prices

# サンプルデータの投入
aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16"},
        "prices": {"M": {
            "128GB": {"S": "124800"},
            "256GB": {"S": "139800"},
            "512GB": {"S": "169800"}
        }}
    }'

aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16 Pro"},
        "prices": {"M": {
            "128GB": {"S": "159800"},
            "256GB": {"S": "174800"},
            "512GB": {"S": "204800"},
            "1TB": {"S": "234800"}
        }}
    }'

aws dynamodb put-item \
    --table-name iphone_prices \
    --item '{
        "series": {"S": "iPhone 16 Pro Max"},
        "prices": {"M": {
            "256GB": {"S": "189800"},
            "512GB": {"S": "219800"},
            "1TB": {"S": "249800"}
        }}
    }'

================
File: scripts/migrate_to_dynamodb.py
================
import json

import boto3

# AWS DynamoDBクライアントの初期化
dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-1')
table = dynamodb.Table('official_prices')

# JSONファイルの読み込み
with open('data/official_prices.json', 'r', encoding='utf-8') as file:
    data = json.load(file)

# DynamoDBにデータを挿入
for series, capacities in data.items():
    for capacity, colors in capacities.items():
        item = {
            'series': series,
            'capacity': capacity,
            'color_prices': colors  # 各カラーの価格情報を保存
        }
        table.put_item(Item=item)
        print(f"Inserted: {series} - {capacity}")

print("データ移行完了！")

================
File: services/dynamodb_service.py
================
import boto3
from boto3.dynamodb.conditions import Key

# DynamoDBテーブル名を指定
DYNAMODB_TABLE_NAME = "official_prices"

def get_prices_by_series(series_name):
    """指定されたシリーズの買取価格を取得"""
    try:
        dynamodb = boto3.resource("dynamodb")
        table = dynamodb.Table(DYNAMODB_TABLE_NAME)

        # クエリ実行
        response = table.query(
            KeyConditionExpression=Key("series").eq(series_name)
        )
        return response.get("Items", [])
    except Exception as e:
        print(f"Error querying DynamoDB: {str(e)}")
        raise

================
File: src/apple_scraper_for_rudea.py
================
import json
import logging
import os
import re
from pathlib import Path

import boto3
import requests
import yaml
from bs4 import BeautifulSoup

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def load_config():
    try:
        config_path = Path(__file__).parent.parent / 'config' / 'config.production.yaml'
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"Error loading config: {e}")
        return None

def get_official_prices(series):
    try:
        dynamodb = boto3.resource('dynamodb')
        table = dynamodb.Table('iphone_prices')
        
        response = table.get_item(
            Key={'series': series}
        )
        
        if 'Item' in response:
            logger.info(f"Found official prices for {series}: {response['Item']}")
            # pricesマップから価格データを取得
            return response['Item'].get('prices', {})
        else:
            logger.warning(f"No official prices found for {series}")
            return {}
            
    except Exception as e:
        logger.error(f"Error getting official prices: {e}")
        logger.error(f"Error details: {str(e)}")  # より詳細なエラー情報
        return {}

def get_kaitori_prices(series):
    try:
        logger.info(f"Starting price fetch for series: {series}")
        config = load_config()
        
        if not config:
            raise Exception("Failed to load configuration")

        # シリーズに対応するURLを取得
        series_url_map = {
            'iPhone 16': config['scraper']['kaitori_rudea_urls'][0],
            'iPhone 16 Pro': config['scraper']['kaitori_rudea_urls'][1],
            'iPhone 16 Pro Max': config['scraper']['kaitori_rudea_urls'][2]
        }
        
        if series not in series_url_map:
            logger.warning(f"No URL configured for series: {series}")
            return {}

        url = series_url_map[series]
        headers = {'User-Agent': config['scraper']['user_agent']}
        
        logger.info(f"Fetching data from URL: {url}")
        
        try:
            response = requests.get(
                url,
                headers=headers,
                timeout=config['scraper']['request_timeout']
            )
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            logger.info(f"HTML content length: {len(response.text)}")
            
            # デバッグ用にHTML�造を解析
            main_content = soup.find('div', class_='main-content')
            if main_content:
                logger.info("Found main-content div")
                logger.info(f"Main content first 500 chars: {str(main_content)[:500]}")
            
            # 買取価格データを抽出
            kaitori_prices = {}
            
            # 価格情報を含む要素を探す（実際のサイトの構造に合わせて修正）
            price_elements = soup.find_all('div', class_='tr') # idは"product4898"のように最後の4桁が行ごとに違ったため使用できず
            if price_elements:
                for elem in price_elements:
                    # 容量を探す（例: "128GB"などのテキストを含む要素）
                    capacity_elem = elem.find('h2') or \
                                  elem.find('div', class_='ttl')
                    # 価格を探す
                    price_elem = elem.find('div', class_='td2wrap') or \
                               elem.find('div', class_='td td2')
                    
                    if capacity_elem and price_elem:
                        capacity_text = capacity_elem.text.strip()
                        # 容量のフォーマットを統一（GB/TB両方に対応）
                        capacity_match = re.search(r'(\d+)\s*(GB|TB)', capacity_text, re.IGNORECASE)
                        if capacity_match:
                            # 容量の数値と単位を取得
                            capacity_num = capacity_match.group(1)
                            capacity_unit = capacity_match.group(2).upper()
                            capacity = f"{capacity_num}{capacity_unit}"
                            # 価格から不要な文字を削除
                            price = re.sub(r'[^\d]', '', price_elem.text.strip())
                            kaitori_prices[capacity] = price
                            logger.info(f"Found price for {capacity}: {price}")
                        else:
                            logger.warning(f"Could not extract capacity from: {capacity_text}")
                
                if not kaitori_prices:
                    logger.warning("No valid price data found in elements")
                    logger.info(f"Found {len(price_elements)} price elements")
                    # 最初の要素の構造をログ出力
                    if price_elements:
                        logger.info(f"First price element structure: {str(price_elements[0])}")
            else:
                logger.warning("No price elements found")
                # ページ構造の確認のため、主要な要素をログ出力
                main_elements = soup.find_all('div', class_=['main', 'content', 'product-list'])
                logger.info(f"Found main elements: {[elem.get('class', []) for elem in main_elements]}")
            
            # 公式価格を取得
            official_prices = get_official_prices(series)
            
            result = {
                series: {
                    'kaitori': kaitori_prices,
                    'official': official_prices
                }
            }
            
            logger.info(f"Returning data for {series}: {json.dumps(result, indent=4)}")
            return result
            
        except requests.RequestException as e:
            logger.error(f"Failed to fetch data from URL: {e}")
            logger.error(f"Response status code: {getattr(e.response, 'status_code', 'N/A')}")
            logger.error(f"Response content: {getattr(e.response, 'text', 'N/A')[:500]}")
            return {
                series: {
                    'kaitori': {},
                    'official': get_official_prices(series)
                }
            }
            
    except Exception as e:
        logger.error(f"Error in get_kaitori_prices: {e}")
        logger.error(f"Error details: {str(e)}")
        return {
            series: {
                'kaitori': {},
                'official': get_official_prices(series)
            }
        }

================
File: src/apple_scraper.py
================
import requests
from bs4 import BeautifulSoup

# iPhone 16, iPhone 16 Plusの購入ページURL
url_iphone16 = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16'
# iPhone 16 Pro, iPhone 16 Pro Maxの購入ページURL
url_iphone16_pro = 'https://www.apple.com/jp/shop/buy-iphone/iphone-16-pro'

# ページから価格情報を取得する関数
def get_prices(url):
    # ページを取得
    response = requests.get(url)
    
    # レスポンスの内容を確認
    print(response.text)  # ここでHTMLの内容を表示
    
    # BeautifulSoupでHTML解析
    soup = BeautifulSoup(response.text, 'html.parser')

    # 価格情報を取得するためのセレクタ
    prices = soup.select('span.price-point.price-point-fullPrice > span.nowrap')

    # 取得した価格情報をリストに格納
    price_list = [price.get_text() for price in prices]
    return price_list

# iPhone 16シリーズの価格取得
print("iPhone 16シリーズの価格:")
iphone16_prices = get_prices(url_iphone16)
for price in iphone16_prices:
    print(price)

# iPhone 16 Proシリーズの価格取得
print("\niPhone 16 Proシリーズの価格:")
iphone16_pro_prices = get_prices(url_iphone16_pro)
for price in iphone16_pro_prices:
    print(price)

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPhone 16シリーズ 買取価格比較</title>
    <style>
      /* ローディングスピナーのスタイル */
      .loader {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #priceTable {
        display: none;
      }

      .tables-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin: 20px auto;
        max-width: 1400px;
        padding: 0 20px;
      }

      .price-table {
        min-width: 300px;
        width: 100%;
        border-collapse: collapse;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .price-table caption {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .price-table th,
      .price-table td {
        padding: 8px 15px;
        border: 1px solid #ddd;
        text-align: left;
        white-space: nowrap;
      }

      .price-table th {
        background-color: #f2f2f2;
      }

      .price-table td:last-child {
        text-align: right;
      }

      .price-table td[style*='color: green'] {
        font-weight: bold;
      }

      .price-table td[style*='color: red'] {
        font-weight: bold;
      }

      .series-section {
        flex: 1 1 100%;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .series-section h2 {
        text-align: center;
        color: #333;
        margin-bottom: 15px;
      }

      /* 収支の色分け */
      .price-diff-negative {
        color: red;
        font-weight: bold;
      }

      .price-diff-positive {
        color: green;
        font-weight: bold;
      }

      /* ブレークポイントの調整 */
      @media (min-width: 576px) {
        .series-section {
          padding: 0 10px;
        }
      }

      @media (min-width: 768px) {
        .series-section {
          flex: 0 1 calc(50% - 20px);
        }
      }

      @media (min-width: 992px) {
        .series-section {
          flex: 0 1 calc(33.333% - 20px);
        }
      }

      @media (max-width: 576px) {
        .price-table {
          font-size: 0.85em;
        }
        .price-table th,
        .price-table td {
          padding: 6px 10px;
        }
      }

      /* テーブルラッパーを追加 */
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
        margin-bottom: 15px;
      }

      /* スマートフォン向けの調整 */
      @media (max-width: 414px) {
        .series-section {
          flex: 1 1 100%;
          max-width: 100%;
          padding: 0 10px;
        }

        .tables-container {
          gap: 20px;
          padding: 0 5px;
        }

        .table-wrapper {
          max-width: calc(100vw - 20px); /* 画面幅からパディングを引いた幅 */
        }

        .price-table {
          min-width: 300px; /* テーブルの最小幅を設定 */
          font-size: 0.85em; /* フォントサイズを縮小 */
        }

        .price-table th,
        .price-table td {
          padding: 6px 10px; /* セルのパディングを縮小 */
          white-space: nowrap; /* テキストの折り返しを防止 */
        }

        /* テーブルのキャプションスタイルを調整 */
        .series-section h2 {
          font-size: 1.1em;
          margin-bottom: 10px;
        }
      }

      /* さらに小さい画面向けの微調整 */
      @media (max-width: 374px) {
        .price-table {
          font-size: 0.8em;
        }

        .price-table th,
        .price-table td {
          padding: 5px 8px;
        }
      }
    </style>
  </head>
  <body>
    <h1>iPhone 16シリーズ 買取価格比較</h1>

    <!-- ローディング中の表示 -->
    <div id="loading" style="display: none">
      <p>データを読み込んでいます...</p>
      <div class="loader"></div>
    </div>

    <!-- エラーメッセージ表示エリア -->
    <div id="error-message" style="display: none; color: red"></div>

    <!-- 価格テーブル -->
    <div id="content">
      <div id="priceTablesContainer" class="tables-container">
        <!-- iPhone 16 -->
        <div class="series-section">
          <h2>iPhone 16</h2>
          <div class="table-wrapper">
            <table id="iPhone16-prices" class="price-table">
              <thead>
                <tr>
                  <th>容量</th>
                  <th>公式価格</th>
                  <th>買取価格</th>
                  <th>収支</th>
                  <th>楽天錬金時収支</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <!-- iPhone 16 Pro -->
        <div class="series-section">
          <h2>iPhone 16 Pro</h2>
          <div class="table-wrapper">
            <table id="iPhone16Pro-prices" class="price-table">
              <thead>
                <tr>
                  <th>容量</th>
                  <th>公式価格</th>
                  <th>買取価格</th>
                  <th>収支</th>
                  <th>楽天錬金時収支</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <!-- iPhone 16 Pro Max -->
        <div class="series-section">
          <h2>iPhone 16 Pro Max</h2>
          <div class="table-wrapper">
            <table id="iPhone16ProMax-prices" class="price-table">
              <thead>
                <tr>
                  <th>容量</th>
                  <th>公式価格</th>
                  <th>買取価格</th>
                  <th>収支</th>
                  <th>楽天錬金時収支</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const API_ENDPOINT =
          'https://qow3wyg1nj.execute-api.ap-northeast-1.amazonaws.com/prod/get_prices';
        const series = ['iPhone 16', 'iPhone 16 Pro', 'iPhone 16 Pro Max'];

        // ローディング状態を管理する要素
        const loadingElement = document.getElementById('loading');
        const contentElement = document.getElementById('content');
        const priceTablesContainer = document.getElementById(
          'priceTablesContainer'
        );

        // データ取得と表示の処理
        async function fetchPrices() {
          try {
            // ローディング表示
            if (loadingElement) loadingElement.style.display = 'block';
            if (contentElement) contentElement.style.display = 'none';

            const results = await Promise.all(
              series.map(series =>
                fetch(
                  `${API_ENDPOINT}?series=${encodeURIComponent(series)}`
                ).then(response => {
                  if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                  }
                  return response.json();
                })
              )
            );

            console.log('Raw response data from Lambda:', results);

            results.forEach((data, index) => {
              if (data && Object.keys(data).length > 0) {
                const seriesName = Object.keys(data)[0];
                const priceData = data[seriesName];

                const tableId = seriesName.replace(/\s+/g, '') + '-prices';
                const tableBody = document.querySelector(`#${tableId} tbody`);

                if (tableBody && priceData) {
                  // DocumentFragment を使用
                  const fragment = document.createDocumentFragment();

                  // 容量配列の作成（既存のソートロジックを維持）
                  const capacities = Array.from(
                    new Set([
                      ...Object.keys(priceData.official || {}),
                      ...Object.keys(priceData.kaitori || {}),
                    ])
                  ).sort((a, b) => {
                    const [aNum, aUnit] = a.match(/(\d+)(GB|TB)/).slice(1);
                    const [bNum, bUnit] = b.match(/(\d+)(GB|TB)/).slice(1);
                    const aValue =
                      aUnit === 'TB' ? parseInt(aNum) * 1024 : parseInt(aNum);
                    const bValue =
                      bUnit === 'TB' ? parseInt(bNum) * 1024 : parseInt(bNum);
                    return aValue - bValue;
                  });

                  // 一度のループで全ての行を生成
                  capacities.forEach(capacity => {
                    const row = document.createElement('tr');
                    const officialPrice = parseInt(
                      priceData.official?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const kaitoriPrice = parseInt(
                      priceData.kaitori?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const priceDiff = kaitoriPrice - officialPrice;
                    const rakutenPriceDiff = kaitoriPrice - officialPrice * 0.9;

                    row.innerHTML = `
                      <td>${capacity}</td>
                      <td>¥${officialPrice.toLocaleString()}</td>
                      <td>¥${kaitoriPrice.toLocaleString()}</td>
                      <td class="${
                        priceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${priceDiff.toLocaleString()}
                      </td>
                      <td class="${
                        rakutenPriceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${Math.round(rakutenPriceDiff).toLocaleString()}
                      </td>
                    `;
                    fragment.appendChild(row);
                  });

                  // まとめてDOM更新
                  tableBody.innerHTML = '';
                  tableBody.appendChild(fragment);
                }
              }
            });

            // データ表示後にテーブルを表示
            if (priceTablesContainer)
              priceTablesContainer.style.display = 'flex';
          } catch (error) {
            console.error('Fetch Error:', error);
            // エラーメッセージを表示
            const errorElement = document.getElementById('error-message');
            if (errorElement) {
              errorElement.textContent = `データの取得に失敗しました: ${error.message}`;
              errorElement.style.display = 'block';
            }
          } finally {
            // ローディング非表示
            if (loadingElement) loadingElement.style.display = 'none';
            if (contentElement) contentElement.style.display = 'block';
          }
        }

        // 初期データ取得
        fetchPrices();
      });
    </script>
  </body>
</html>

================
File: terraform-render/main.tf
================
resource "render_postgresql" "price-comparison-app" {
  name     = var.db_name
  database = var.db_name
  user     = var.db_user
  password = var.db_password
  region   = var.db_region
  version  = var.db_version
}

output "database_url" {
  value = render_postgresql.price-comparison-app.connection_string
}

================
File: terraform-render/variables.tf
================
variable "db_name" {
  default     = "price-comparison-app"
  description = "The name of the PostgreSQL database"
}

variable "db_user" {
  default     = "app_user"
  description = "The username for the PostgreSQL database"
}

variable "db_password" {
  description = "The password for the PostgreSQL user"
  type        = string
}

variable "db_region" {
  default     = "oregon"
  description = "The region where the database will be hosted"
}

variable "db_version" {
  default     = "16"
  description = "The PostgreSQL version"
}

================
File: tests/integration/test_config_integration.py
================
from pathlib import Path

import pytest

from config import ConfigManager


def test_config_environment_integration(mock_env_vars, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 環境変数からの値
    assert config.app.SECRET_KEY == mock_env_vars["SECRET_KEY"]
    
    # 設定ファイルからの値
    assert isinstance(config.app.DEBUG, bool)
    assert config.app.LOG_LEVEL in ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

def test_scraper_config_integration(mock_env_vars, test_config_file):
    """スクレイパー設定の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    assert config.scraper.REQUEST_TIMEOUT > 0
    assert config.scraper.RETRY_COUNT >= 0
    assert all("http" in url for url in config.scraper.KAITORI_RUDEA_URLS)
    assert "http" in config.scraper.APPLE_STORE_URL

# ConfigManager の統合テスト: 設定ファイルと環境変数が正しく統合されるか確認
def test_config_integration_with_file_and_env(monkeypatch, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    monkeypatch.setenv("FLASK_ENV", "testing")
    monkeypatch.setenv("SECRET_KEY", "env-secret-key-16ch")  # 16文字以上に変更
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 統合後の ConfigManager が正しく値を取得しているか確認
    assert config.app.SECRET_KEY == "env-secret-key-16ch"  # 環境変数が優先される
    assert config.app.DEBUG is True  # 設定ファイルから取得
    assert config.scraper.REQUEST_TIMEOUT == 30  # 設定ファイルから取得

# 設定ファイルが存在しない場合のテスト
def test_config_file_not_found():
    """設定ファイルが見つからない場合のエラーハンドリング"""
    # 存在しないディレクトリを指定して ConfigManager を初期化
    with pytest.raises(FileNotFoundError, match="Configuration file not found"):
        ConfigManager(config_dir="non_existent_directory")

def test_iphone16_pro_url_integration(mock_env_vars, test_config_file):
    """iPhone 16 Pro URLの統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 全てのiPhoneモデルのURLが含まれているか確認
    expected_urls = [
        "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
        "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
        "https://kaitori-rudeya.com/category/detail/186"   # iPhone 16 Pro Max
    ]
    
    # URLの数が正しいか確認
    assert len(config.scraper.KAITORI_RUDEA_URLS) == len(expected_urls)
    
    # 各URLが正しく含まれているか確認
    for url in expected_urls:
        assert url in config.scraper.KAITORI_RUDEA_URLS
        
    # URLの順序が正しいか確認
    assert config.scraper.KAITORI_RUDEA_URLS == expected_urls

================
File: tests/unit/test_validators.py
================
import pytest

from config import AppConfig, ScraperConfig
from config.manager import ConfigManager


class TestAppConfigValidation:
    def test_valid_app_config(self):
        """有効なアプリケーション設定のテスト"""
        config = AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="DEBUG"
        )
        assert config.DEBUG is True
        assert config.SECRET_KEY == "valid-secret-key-12345"
        assert config.LOG_LEVEL == "DEBUG"

    def test_invalid_secret_key(self):
        """無効なシークレットキーのテスト"""
        with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="short",
                LOG_LEVEL="DEBUG"
            )

    def test_invalid_log_level(self):
        """無効なログレベルのテスト"""
        with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="valid-secret-key-12345",
                LOG_LEVEL="INVALID"
            )

class TestScraperConfigValidation:
    def test_valid_scraper_config(self):
        """有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 1
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori"

    def test_invalid_url_format(self):
        """無効なURL形式のテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["invalid-url"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_invalid_timeout(self):
        """無効なタイムアウト値のテスト"""
        with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=0,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_valid_scraper_config_with_multiple_urls(self):
        """複数のURLを持つ有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori1", "https://example.com/kaitori2"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 2
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori1"
        assert config.KAITORI_RUDEA_URLS[1] == "https://example.com/kaitori2"

    def test_invalid_kaitori_rudea_urls(self):
        """無効なkaitori_rudea_urlsのテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com", "invalid-url"],
                APPLE_STORE_URL="https://example.com/apple",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

# 境界値テスト: REQUEST_TIMEOUT が 0 以下の場合はエラーを出す必要があります
def test_scraper_request_timeout_boundary():
    """REQUEST_TIMEOUT の境界値テスト"""
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=-1,  # 境界値（0 以下はエラー）
            RETRY_COUNT=1,
            USER_AGENT="Test Agent"
        )

# 無効な LOG_LEVEL を渡した場合のテスト
def test_app_log_level_invalid():
    """LOG_LEVEL が無効な場合のテスト"""
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        # LOG_LEVEL に無効な値 "INVALID" を指定し、エラーハンドリングを確認
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"  # 無効な LOG_LEVEL
        )

# SECRET_KEY が設定されていない場合、デフォルト値が使用されるかのテスト
def test_config_environment_with_missing_secret_key(monkeypatch):
    """SECRET_KEY が存在しない場合のテスト"""
    # SECRET_KEY を削除して、デフォルト値が設定されるか確認
    monkeypatch.delenv("SECRET_KEY", raising=False)
    config = ConfigManager()
    # デフォルトのシークレットキーが使用されるか確認
    assert config.app.SECRET_KEY == "default-secret-key"  # デフォルト値として設定されている

# FLASK_ENV が production の場合に正しく設定されるか確認
def test_config_environment_with_different_env(monkeypatch):
    """異なる FLASK_ENV のテスト"""
    # FLASK_ENV を production に設定
    monkeypatch.setenv("FLASK_ENV", "production")
    config = ConfigManager()
    # 環境が production になっているか確認
    assert config.env == "production"

# 無効な SECRET_KEY を渡した場合のエラーハンドリングテスト
def test_invalid_secret_key_length(monkeypatch):
    """SECRET_KEY が無効な場合のテスト"""
    monkeypatch.setenv("SECRET_KEY", "short")
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        config = ConfigManager()
        _ = config.app  # app プロパティにアクセスして初期化を強制

def test_config_manager_with_multiple_urls(monkeypatch, tmp_path):
    """複数のURLを持つConfigManagerのテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://test1.example.com/kaitori
        - https://test2.example.com/kaitori
      apple_store_url: https://test.example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 2
    assert "https://test1.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://test2.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS

def test_scraper_config_with_iphone16_pro_url():
    """iPhone 16 Pro URLを含むスクレイパー設定のテスト"""
    config = ScraperConfig(
        KAITORI_RUDEA_URLS=[
            "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
            "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
            "https://kaitori-rudeya.com/category/detail/186"   # iPhone 16 Pro Max
        ],
        APPLE_STORE_URL="https://example.com/apple",
        REQUEST_TIMEOUT=30,
        RETRY_COUNT=3,
        USER_AGENT="Test Agent"
    )
    assert len(config.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/185" in config.KAITORI_RUDEA_URLS

def test_config_manager_loads_iphone16_pro_url(mock_env_vars, tmp_path):
    """ConfigManagerがiPhone 16 Pro URLを正しく読み込むかテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://kaitori-rudeya.com/category/detail/183
        - https://kaitori-rudeya.com/category/detail/185
        - https://kaitori-rudeya.com/category/detail/186
      apple_store_url: https://example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch = mock_env_vars
    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS

================
File: tests/conftest.py
================
import pytest
from pathlib import Path
import shutil

@pytest.fixture(scope="function")
def mock_env_vars(monkeypatch):
    """環境変数をモックするフィクスチャ"""
    test_vars = {
        "FLASK_ENV": "testing",
        "SECRET_KEY": "test-secret-key-16ch",  # 16文字以上に変更
        "LOG_LEVEL": "DEBUG"
    }
    for key, value in test_vars.items():
        monkeypatch.setenv(key, value)
    return test_vars

@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    """テスト用の設定ファイルを作成するフィクスチャ"""
    config_content = """
app:
  debug: true
  log_level: DEBUG
  secret_key: test-secret-key-16

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183  # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185  # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186  # iPhone 16 Pro Max
  apple_store_url: https://test.example.com/apple
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    dest_dir.mkdir(exist_ok=True)
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

================
File: tests/pytest.ini
================
[pytest]
pythonpath = .
testpaths = tests
python_files = test_*.py
addopts = -v -s --cov=config --cov-report=term-missing

================
File: tests/test_config_manager.py
================
import sys
from pathlib import Path
import shutil
import pytest

# プロジェクトのルートディレクトリをPYTHONPATHに追加
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import pytest

from config import AppConfig, ConfigManager, ScraperConfig

@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    config_content = """
app:
  debug: true
  log_level: "DEBUG"

scraper:
  kaitori_rudea_urls:
    - "https://kaitori-rudeya.com/category/detail/183"  # iPhone 16
    - "https://kaitori-rudeya.com/category/detail/185"  # iPhone 16 Pro
    - "https://kaitori-rudeya.com/category/detail/186"  # iPhone 16 Pro Max
  apple_store_url: "https://example.com/apple"
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

def test_config_manager_initialization(mock_env_vars, test_config_file):
    """ConfigManagerの初期化テスト"""
    config = ConfigManager()
    assert config.env == "testing"
    assert isinstance(config.app, AppConfig)
    assert isinstance(config.scraper, ScraperConfig)

def test_app_config_validation():
    """AppConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="short",
            LOG_LEVEL="DEBUG"
        )
    
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"
        )

def test_scraper_config_validation():
    """ScraperConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="Invalid URL format"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["invalid-url"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
    
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=0,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )

def test_scraper_config_multiple_urls(mock_env_vars, test_config_file):
    """複数のkaitori_rudea_urlsを持つScraperConfigのテスト"""
    config = ConfigManager()
    assert isinstance(config.scraper.KAITORI_RUDEA_URLS, list)
    assert len(config.scraper.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/183" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/186" in config.scraper.KAITORI_RUDEA_URLS

================
File: .env.example
================
FLASK_ENV=development
SECRET_KEY=your-secret-key-here

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# ... existing code ...
artifacts/lambda/*
!artifacts/lambda/function_latest.zip
# ... existing code ...

================
File: .python-version
================
3.13.2

================
File: app.py
================
import logging
import os
import re

from flask import Flask, jsonify, render_template, send_from_directory
from playwright.sync_api import sync_playwright

from config import config
from services.dynamodb_service import get_prices_by_series


def create_app():
    app = Flask(__name__)

    # アプリケーション設定の適用
    app.config['DEBUG'] = config.app.DEBUG
    app.config['SECRET_KEY'] = config.app.SECRET_KEY

    # Playwrightのタイムアウト設定
    app.config['PLAYWRIGHT_TIMEOUT'] = config.scraper.REQUEST_TIMEOUT * 1000  # ミリ秒単位に変換

    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    @app.route("/favicon.ico")
    def favicon():
        try:
            return send_from_directory(
                os.path.join(app.root_path, "static"),
                "favicon.ico",
                mimetype="image/vnd.microsoft.icon"
            )
        except Exception as e:
            app.logger.error(f"Favicon error: {str(e)}")
            return "", 204  # No Content

    return app

# アプリケーションインスタンスの作成
app = create_app()

def price_text_to_int(price_text):
    """価格テキストを整数に変換する"""
    try:
        # "123,456円" → 123456
        return int(price_text.replace("円", "").replace(",", ""))
    except (ValueError, AttributeError):
        return 0

def get_kaitori_prices():
    """買取価格データをスクレイピングで取得"""
    all_product_details = {
        "iPhone 16": {},
        "iPhone 16 Pro": {},
        "iPhone 16 Pro Max": {},
    }

    with sync_playwright() as p:
        browser = p.chromium.launch(chromium_sandbox=False)
        page = browser.new_page()

        for url in config.scraper.KAITORI_RUDEA_URLS:
            page.goto(url)
            page.wait_for_load_state("networkidle")

            items = page.query_selector_all(".tr")

            for item in items:
                try:
                    model_element = item.query_selector(".ttl h2")
                    model_name = model_element.inner_text().strip() if model_element else ""

                    # モデル名からシリーズを判定
                    if "Pro Max" in model_name:
                        series = "iPhone 16 Pro Max"
                    elif "Pro" in model_name:
                        series = "iPhone 16 Pro"
                    elif "16" in model_name:
                        series = "iPhone 16"
                    else:
                        continue

                    # 容量を抽出（例: "128GB" または "1TB"）
                    capacity_match = re.search(r"(\d+)(GB|TB)", model_name)
                    if not capacity_match:
                        continue
                    capacity = capacity_match.group(0)  # "128GB" or "1TB"

                    price_element = item.query_selector(".td.td2 .td2wrap")
                    price_text = price_element.inner_text().strip() if price_element else ""

                    if model_name and price_text and "円" in price_text:
                        # カラーを抽出
                        color_match = re.search(r"(黒|白|桃|緑|青|金|灰)", model_name)
                        color = color_match.group(1) if color_match else "不明"

                        # 容量ごとのデータを初期化・更新
                        if capacity not in all_product_details[series]:
                            all_product_details[series][capacity] = {
                                "colors": {},
                                "kaitori_price_min": None,
                                "kaitori_price_max": None,
                            }

                        # 色ごとの価格を保存
                        price_value = price_text_to_int(price_text)
                        all_product_details[series][capacity]["colors"][color] = {
                            "price_text": price_text,
                            "price_value": price_value,
                        }

                        # 最小・最大価格を更新
                        current_min = all_product_details[series][capacity]["kaitori_price_min"]
                        current_max = all_product_details[series][capacity]["kaitori_price_max"]

                        if current_min is None or price_value < current_min:
                            all_product_details[series][capacity]["kaitori_price_min"] = price_value
                        if current_max is None or price_value > current_max:
                            all_product_details[series][capacity]["kaitori_price_max"] = price_value

                except Exception as e:
                    app.logger.error(f"データ取得エラー: {str(e)}")
                    continue

        browser.close()

    return all_product_details

@app.route("/")
def home():
    return render_template("index.html")

@app.route("/get_prices")
def get_prices():
    """買取価格と公式価格を取得して統合"""
    try:
        kaitori_prices = get_kaitori_prices()
        official_prices = get_prices_by_series()  # DynamoDBから公式価格を取得

        # データ統合処理
        for series, capacities in kaitori_prices.items():
            if series in official_prices:
                for capacity, details in capacities.items():
                    if capacity in official_prices[series]:
                        official_price = min(official_prices[series][capacity].values())
                        details["official_price"] = official_price
                        details["profit_min"] = details["kaitori_price_min"] - official_price
                        details["profit_max"] = details["kaitori_price_max"] - official_price

        return jsonify(kaitori_prices), 200

    except Exception as e:
        app.logger.error(f"エラー: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 5000)))

================
File: create_patch.py
================
import json
import subprocess

patch_data = {
    "op": "replace",
    "path": "/accessLogSettings/format",
    "value": json.dumps({  # Convert value to string here
        "requestId": "$context.requestId",
        "ip": "$context.identity.sourceIp",
        "requestTime": "$context.requestTime",
        "httpMethod": "$context.httpMethod",
        "resourcePath": "$context.resourcePath",
        "status": "$context.status",
        "protocol": "$context.protocol",
        "responseLength": "$context.responseLength"
    })
}

json_patch_string = json.dumps([patch_data])

try:
    result = subprocess.run(
        [
            "aws",
            "apigateway",
            "update-stage",
            "--rest-api-id",
            "qow3wyg1nj",
            "--stage-name",
            "prod",
            "--patch-operations",
            json_patch_string,
        ],
        check=True,
        capture_output=True,
        text=True,
    )
    print("API Gateway stage updated successfully!")
    print(result.stdout)
except subprocess.CalledProcessError as e:
    print(f"Error updating API Gateway stage: {e.stderr}")
    print(f"Return code: {e.returncode}")
except json.JSONEncoderError as e:
    print(f"Error encoding JSON: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

================
File: Dockerfile
================
# Dockerのイメージ名: price-comparison-app:latest

# ベースイメージ
FROM python:3.13-slim

# 必要なシステムパッケージとPlaywrightの依存ライブラリをインストール
RUN apt-get update && apt-get install -y \
    libnss3 \
    libnspr4 \
    libatk1.0-0 \
    libatk-bridge2.0-0 \
    libatspi2.0-0 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libxkbcommon0 \
    libgdk-pixbuf2.0-0 \
    libgtk-3-0 \
    libpango-1.0-0 \
    libxshmfence1 \
    libgbm1 \
    libasound2 \
    libcurl4 \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# 作業ディレクトリを設定
WORKDIR /app

# プロジェクトのファイルをコピー
COPY . /app

# Pythonパッケージのインストール
RUN pip install -r requirements.txt

# Playwrightの環境変数を設定
ENV PLAYWRIGHT_BROWSERS_PATH=/opt/render/.cache/ms-playwright

# Playwrightブラウザのインストール
RUN playwright install chromium

# アプリケーションを起動
CMD ["gunicorn", "app:app", "--bind", "0.0.0.0:5000", "--workers=3", "--timeout=60"]

================
File: options-integration-template.json
================
{
  "application/json": "{\"statusCode\": 200}"
}

================
File: Procfile
================
web: gunicorn app:app

================
File: README.md
================
# **`priceComparisonAppForIphone`リポジトリについて**

# Claude や ChatGPT にリポジトリを丸ごと読み込ませるコマンド

以下のコマンドを実行することでリポジトリ一式をテキストファイル（`repomix-output.txt`, 旧：`repopack-output.txt`）を出力することができます。

```
npx repomix
// 2024/12/20 `repopack`からupgrade
```

chat へ最初に取り込ませることでコード修正に役立ちます。

### 読み込ませるポイント

ファイルと合わせて以下のプロンプトで始めるとスムーズに改修を始めやすい

```
このファイルはリポジトリのファイルを1つにしたものです。コードのリファクタなどをしたいのでまず添付のコードを確認してください。
```

# About setting to "Renovate"

## 説明:

- extends: ["config:base"]: デフォルト設定に基づきます。
- labels: ["dependencies"]: すべての PR に "dependencies" ラベルが付与されます。
- packageRules:
  - minor と patch の自動マージ: 自動的に PR がマージされます（automergeType: "pr"）。
  - 大規模なマイナー変更（特定のパッケージ）やメジャーアップデートは自動マージされません\*\*。
- prConcurrentLimit: 一度に開かれる PR の上限(number)。

この設定で、メジャーアップデートと大規模なマイナー変更は手動でマージすることができ、それ以外の更新は自動的にマージされます。

# `AWS`の設定について

## credentials について

以下`~/.aws/credentials`のサンプルになります(2024/12/20 時点のもの。セキュリティ面から 2,3 週間ごとに変更予定のため流用はほぼ不可)

```
[default]
aws_access_key_id = ********************
aws_secret_access_key = ****************************************
# 格納方法は別途検討中
```

※ MFA を有効にする場合、`aws cli`は追加対応が必要になるため注意が必要（AI に聞くなり「aws-cli mfa」などで調べてください。大体は「一時的なアクセス情報を発行する」や`aws sts`コマンドに行き着くかと思います）

※ `aws configure` は `--profile`オプションを追加して名前つきのプロファイルを設定することができます（上記同様 AI に聞くなりして調べてください）

## config について

以下`~/.aws/config`のサンプルになります。こちらは管理者が日本以外に帰化しない限りは以下のままかと思います。

```
[default]
region = ap-northeast-1
output = json
# outputについて、`yaml`等が良ければ必要に応じて変更してください
```

## DynamoDB create command

上記`aws configure`の設定は前提

```
aws dynamodb create-table \
  --table-name official_prices \
  --attribute-definitions \
      AttributeName=series,AttributeType=S \
      AttributeName=capacity,AttributeType=S \
  --key-schema \
      AttributeName=series,KeyType=HASH \
      AttributeName=capacity,KeyType=RANGE \
  --billing-mode PAY_PER_REQUEST
```

実際に保存したい情報（`2024/12/20`時点のもの）は`data/official_prices.json`に残っていたりもする（以前は`json`ファイルから描写していた名残）

## ディレクトリ構成について（`2024/12/20`時点）

```
priceComparisonAppForIphone/
│
├── scripts/  # スクリプト関連
│   ├── migrate_to_dynamodb.py  # データ移行用
│
├── services/  # AWSサービスごとの処理
│   ├── dynamodb_service.py  # DynamoDB操作
│   ├── lambda_handler.py  # Lambda関数のエントリーポイント
│
├── templates/  # HTMLテンプレート
│   ├── index.html  # フロントエンド
│
├── app.py  # Flaskサーバー
├── requirements.txt
└── README.md
```

# ローカル環境での実行手順

1. まず、必要な環境変数を設定します。`.env.example`をコピーして`.env`ファイルを作成：

```bash
cp .env.example .env
```

2. 必要な Python パッケージをインストール：

```bash
pip install -r requirements.txt
```

3. Playwright のブラウザをインストール：

```bash
playwright install chromium
```

4. アプリケーションの実行：

開発モード（デバッグ有効）での実行：

```bash
python app.py
```

または、本番モードでの実行（Gunicorn を使用）：

```bash
gunicorn app:app --bind 0.0.0.0:5000 --workers=3 --timeout=60
```

Docker を使用する場合：

```bash
# イメージのビルド
docker build -t price-comparison-app:latest .

# コンテナの実行
docker run -p 5000:5000 price-comparison-app:latest
```

アプリケーションが起動したら、ブラウザで以下の URL にアクセスできます：

```
http://localhost:5000
```

注意点：

- AWS 関連の機能を使用する場合は、AWS 認証情報の設定が必要です
- DynamoDB を使用する場合は、`~/.aws/credentials`の設定が必要です
- 開発環境では`config/config.development.yaml`の設定が使用されます

エラーが発生した場合は、ログを確認することで詳細な情報を得ることができます。

================
File: renovate.json
================
{
  "extends": [
    "config:recommended"
  ],
  "labels": [
    "dependencies"
  ],
  "packageRules": [
    {
      "matchUpdateTypes": [
        "minor",
        "patch"
      ],
      "automerge": true,
      "automergeType": "pr",
      "prConcurrentLimit": 10,
      "prPriority": -1,
      "matchPackageNames": [
        "!/@*/",
        "!/some-risky-package/",
        "!/another-risky-package/"
      ]
    },
    {
      "matchUpdateTypes": [
        "major"
      ],
      "automerge": false,
      "prConcurrentLimit": 5,
      "prPriority": 1
    },
    {
      "matchUpdateTypes": [
        "minor"
      ],
      "automerge": false,
      "prPriority": 1,
      "matchPackageNames": [
        "/@*/"
      ]
    }
  ],
  "prConcurrentLimit": 10
}

================
File: requirements.txt
================
attrs==24.3.0
beautifulsoup4==4.13.3
blinker==1.9.0
boto3==1.26.148
certifi==2024.12.14
charset-normalizer==3.3.2
click==8.1.8
exceptiongroup==1.2.2
flask==3.1.0
greenlet==3.1.1
gunicorn==23.0.0
h11==0.14.0
idna==3.10
importlib_metadata==8.5.0
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
outcome==1.3.0.post0
packaging==24.1
playwright==1.50.0
pyee==12.1.1
PySocks==1.7.1
pytest-cov==6.0.0
pytest==7.4.4
python-dotenv==1.0.1
PyYAML==6.0.1
requests==2.32.3
selenium==4.27.1
sniffio==1.3.1
sortedcontainers==2.4.0
soupsieve==2.6
trio-websocket==0.11.1
trio==0.26.2
typing_extensions==4.12.2
urllib3>=1.26,<2.0
webdriver-manager==4.0.2
websocket-client==1.8.0
wsproto==1.2.0
zipp==3.21.0



================================================================
End of Codebase
================================================================
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to Render

on:
  push:
    branches:
      - main  # `main`ブランチへのプッシュをトリガー

env:
  AWS_REGION: ap-northeast-1

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # コードをチェックアウト
      - name: Checkout code
        uses: actions/checkout@v4

      # Terraformのセットアップ
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActionsSession

      # Terraformの初期化
      - name: Initialize Terraform
        run: |
          cd terraform
          terraform init

      # Terraform構成の適用
      - name: Apply Terraform configuration
        run: |
          cd terraform
          terraform apply -auto-approve -input=false  # `input=false`を追加して自動承認
</file>

<file path=".github/workflows/docker-build-and-push.yml">
name: Build, Push, and Deploy

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    name: Build, Push, and Deploy to Render
    runs-on: ubuntu-latest

    steps:
      # リポジトリをチェックアウト
      - name: Checkout repository
        uses: actions/checkout@v4

      # Dockerにログイン
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Dockerイメージをビルド＆プッシュ
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: koninji/price-comparison-app:latest
          cache-from: type=registry,ref=koninji/price-comparison-app:latest
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      # Renderのサービス一覧からサービスIDを取得
      - name: Fetch Render Service ID
        id: fetch-service-id
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          SERVICE_ID=$(curl -s -X GET \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            https://api.render.com/v1/services \
            | jq -r '.[] | select(.service.name=="price-comparison-app:latest") | .service.id')

          if [ -z "$SERVICE_ID" ]; then
            echo "Service ID not found for 'price-comparison-app:latest'."
            exit 1
          fi

          echo "SERVICE_ID=$SERVICE_ID" >> $GITHUB_ENV

      # Renderでデプロイをトリガー
      - name: Trigger Render Deploy
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          curl -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Content-Type: application/json" \
            https://api.render.com/v1/services/$SERVICE_ID/deploys
</file>

<file path="config/config.production.yaml">
app:
  debug: false
  log_level: INFO
  # secret_keyは環境変数から取得するため、ここには記載しない

scraper:
  kaitori_rudea_urls:
    - https://kaitori-rudeya.com/category/detail/183 # iPhone 16
    - https://kaitori-rudeya.com/category/detail/185 # iPhone 16 Pro
    - https://kaitori-rudeya.com/category/detail/186 # iPhone 16 Pro Max
    - https://kaitori-rudeya.com/category/detail/205 # iPhone 16 e
  apple_store_url: https://www.apple.com/jp/shop/buy-iphone
  request_timeout: 60
  retry_count: 5
  user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"

price_alert:
  check_interval: 3600 # 1時間ごとにチェック
  notification:
    enabled: true
    # LINE Notifyトークンは環境変数から取得するため、ここには記載しない
</file>

<file path="config/local_config.yaml">
scraper:
  user_agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
  request_timeout: 10
  kaitori_rudea_urls:
    - "https://example.com/kaitori1"
    - "https://example.com/kaitori2"
  apple_store_url: "https://example.com/apple"
  cache:
    enabled: true
    duration: 3600
    directory: "cache"

dynamodb:
  region: "ap-northeast-1"
  table_name: "iphone_prices"
  endpoint_url: "http://localhost:8000"  # DynamoDB Localを使用する場合
</file>

<file path="data/kaitori-rudea_prices.json">
{
  "iPhone 16": {
    "128GB": {
      "colors": {
        "Black": 65000,
        "White": 65000,
        "Blue": 65000,
        "Green": 65000
      },
      "source": "kaitori-rudea"
    },
    "256GB": {
      "colors": {
        "Black": 70000,
        "White": 70000,
        "Blue": 70000,
        "Green": 70000
      },
      "source": "kaitori-rudea"
    },
    "512GB": {
      "colors": {
        "Black": 80000,
        "White": 80000,
        "Blue": 80000,
        "Green": 80000
      },
      "source": "kaitori-rudea"
    }
  },
  "iPhone 16 Plus": {
    "128GB": {
      "colors": {
        "Black": 70000,
        "White": 70000,
        "Blue": 70000,
        "Green": 70000
      },
      "source": "kaitori-rudea"
    },
    "256GB": {
      "colors": {
        "Black": 75000,
        "White": 75000,
        "Blue": 75000,
        "Green": 75000
      },
      "source": "kaitori-rudea"
    },
    "512GB": {
      "colors": {
        "Black": 85000,
        "White": 85000,
        "Blue": 85000,
        "Green": 85000
      },
      "source": "kaitori-rudea"
    }
  },
  "iPhone 16 Pro": {
    "128GB": {
      "colors": {
        "Natural Titanium": 85000,
        "Blue Titanium": 85000,
        "White Titanium": 85000,
        "Black Titanium": 85000
      },
      "source": "kaitori-rudea"
    },
    "256GB": {
      "colors": {
        "Natural Titanium": 90000,
        "Blue Titanium": 90000,
        "White Titanium": 90000,
        "Black Titanium": 90000
      },
      "source": "kaitori-rudea"
    },
    "512GB": {
      "colors": {
        "Natural Titanium": 100000,
        "Blue Titanium": 100000,
        "White Titanium": 100000,
        "Black Titanium": 100000
      },
      "source": "kaitori-rudea"
    },
    "1TB": {
      "colors": {
        "Natural Titanium": 110000,
        "Blue Titanium": 110000,
        "White Titanium": 110000,
        "Black Titanium": 110000
      },
      "source": "kaitori-rudea"
    }
  },
  "iPhone 16 Pro Max": {
    "256GB": {
      "colors": {
        "Natural Titanium": 95000,
        "Blue Titanium": 95000,
        "White Titanium": 95000,
        "Black Titanium": 95000
      },
      "source": "kaitori-rudea"
    },
    "512GB": {
      "colors": {
        "Natural Titanium": 105000,
        "Blue Titanium": 105000,
        "White Titanium": 105000,
        "Black Titanium": 105000
      },
      "source": "kaitori-rudea"
    },
    "1TB": {
      "colors": {
        "Natural Titanium": 115000,
        "Blue Titanium": 115000,
        "White Titanium": 115000,
        "Black Titanium": 115000
      },
      "source": "kaitori-rudea"
    }
  },
  "iPhone 16 e": {
    "128GB": {
      "colors": {
        "Black": 55000,
        "White": 55000
      },
      "source": "kaitori-rudea"
    },
    "256GB": {
      "colors": {
        "Black": 60000,
        "White": 60000
      },
      "source": "kaitori-rudea"
    },
    "512GB": {
      "colors": {
        "Black": 70000,
        "White": 70000
      },
      "source": "kaitori-rudea"
    }
  }
}
</file>

<file path="data/price_history.json">
{
  "iPhone 16-128GB-Black": {
    "prices": [
      {
        "timestamp": 1746368793,
        "price": 85000,
        "source": "kaitori"
      }
    ]
  },
  "iPhone 16 Pro-256GB-Natural Titanium": {
    "prices": [
      {
        "timestamp": 1746368793,
        "price": 120000,
        "source": "kaitori"
      }
    ]
  }
}
</file>

<file path="data/price_predictions.json">
{
  "iPhone 16": {
    "predictions": [
      {
        "timestamp": "1746368793",
        "predicted_price": 85000,
        "confidence": "0.85",
        "factors": {
          "market_trend": "stable",
          "seasonal_factor": "high",
          "model_age": "new"
        }
      }
    ]
  },
  "iPhone 16 Pro": {
    "predictions": [
      {
        "timestamp": "1746368793",
        "predicted_price": 120000,
        "confidence": "0.82",
        "factors": {
          "market_trend": "stable",
          "seasonal_factor": "high",
          "model_age": "new"
        }
      }
    ]
  }
}
</file>

<file path="lambdas/check_prices_lambda/check_prices.py">
import json
import os
from datetime import datetime

import boto3
import requests


def lambda_handler(event, context):
    try:
        # Get environment variables
        dynamodb_table = os.environ.get('DYNAMODB_TABLE')
        environment = os.environ.get('ENVIRONMENT')
        line_notify_token = os.environ.get('LINE_NOTIFY_TOKEN')
        
        # Initialize AWS clients
        dynamodb = boto3.resource('dynamodb')
        table = dynamodb.Table(dynamodb_table)
        
        # Get current prices
        response = table.scan()
        current_prices = response.get('Items', [])
        
        # Get official prices
        official_table = dynamodb.Table('official_prices')
        official_response = official_table.scan()
        official_prices = official_response.get('Items', [])
        
        # Compare prices
        price_changes = []
        for current_price in current_prices:
            model = current_price.get('model')
            current_price_value = current_price.get('price', 0)
            
            # Find matching official price
            official_price = next(
                (p for p in official_prices if p.get('model') == model),
                None
            )
            
            if official_price:
                official_price_value = official_price.get('price', 0)
                if current_price_value != official_price_value:
                    price_changes.append({
                        'model': model,
                        'current_price': current_price_value,
                        'official_price': official_price_value,
                        'difference': current_price_value - official_price_value
                    })
        
        # Send notification if there are price changes
        if price_changes and line_notify_token:
            message = f"Price changes detected:\n"
            for change in price_changes:
                message += f"Model: {change['model']}\n"
                message += f"Current Price: {change['current_price']}\n"
                message += f"Official Price: {change['official_price']}\n"
                message += f"Difference: {change['difference']}\n\n"
            
            # Send LINE notification
            headers = {
                'Authorization': f'Bearer {line_notify_token}',
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            data = {
                'message': message
            }
            requests.post('https://notify-api.line.me/api/notify', headers=headers, data=data)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Price check completed',
                'environment': environment,
                'price_changes': price_changes
            })
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': 'Price check failed',
                'error': str(e)
            })
        }
</file>

<file path="lambdas/compare_prices_lambda/compare_prices.py">
import json
from datetime import datetime, timedelta
from typing import Any, Dict, List

import boto3

dynamodb = boto3.resource('dynamodb')
price_history_table = dynamodb.Table('price_history')

def get_price_history(model_id: str, days: int = 30) -> List[Dict[str, Any]]:
    """指定されたモデルの価格履歴を取得"""
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)
    
    response = price_history_table.query(
        IndexName='DateIndex',
        KeyConditionExpression='model = :model AND #date BETWEEN :start AND :end',
        ExpressionAttributeNames={
            '#date': 'date'
        },
        ExpressionAttributeValues={
            ':model': model_id,
            ':start': start_date.strftime('%Y-%m-%d'),
            ':end': end_date.strftime('%Y-%m-%d')
        }
    )
    
    return sorted(response['Items'], key=lambda x: x['date'])

def compare_prices(model_ids: List[str], days: int = 30) -> Dict[str, Any]:
    """複数モデルの価格を比較"""
    results = {}
    
    for model_id in model_ids:
        price_history = get_price_history(model_id, days)
        if not price_history:
            continue
            
        prices = [float(item['price']) for item in price_history]
        current_price = prices[-1]
        min_price = min(prices)
        max_price = max(prices)
        avg_price = sum(prices) / len(prices)
        
        # 価格変動率の計算
        if len(prices) > 1:
            price_change = ((current_price - prices[0]) / prices[0]) * 100
        else:
            price_change = 0
            
        results[model_id] = {
            'current_price': current_price,
            'min_price': min_price,
            'max_price': max_price,
            'avg_price': avg_price,
            'price_change': price_change,
            'price_history': price_history
        }
    
    return results

def lambda_handler(event, context):
    try:
        # クエリパラメータからモデルIDを取得
        models = event.get('queryStringParameters', {}).get('models', '')
        if not models:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Model IDs are required'})
            }
            
        model_ids = models.split(',')
        
        # 比較期間を取得（デフォルト30日）
        days = int(event.get('queryStringParameters', {}).get('days', 30))
        
        # 価格比較を実行
        results = compare_prices(model_ids, days)
        
        return {
            'statusCode': 200,
            'body': json.dumps(results)
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
</file>

<file path="lambdas/deployment_verification_lambda/deployment_verification.py">
import json
import os

import boto3


def lambda_handler(event, context):
    try:
        # Get environment variables
        api_id = os.environ.get('API_ID')
        dynamodb_tables = json.loads(os.environ.get('DYNAMODB_TABLES', '[]'))
        environment = os.environ.get('ENVIRONMENT')
        lambda_function_name = os.environ.get('LAMBDA_FUNCTION_NAME')
        
        # Initialize AWS clients
        apigateway = boto3.client('apigateway')
        dynamodb = boto3.client('dynamodb')
        lambda_client = boto3.client('lambda')
        
        # Verify API Gateway
        try:
            api_response = apigateway.get_rest_api(restApiId=api_id)
            print(f"API Gateway verification successful: {api_response['name']}")
        except Exception as e:
            print(f"API Gateway verification failed: {str(e)}")
            raise
        
        # Verify DynamoDB tables
        for table_name in dynamodb_tables:
            try:
                table_response = dynamodb.describe_table(TableName=table_name)
                print(f"DynamoDB table verification successful: {table_name}")
            except Exception as e:
                print(f"DynamoDB table verification failed for {table_name}: {str(e)}")
                raise
        
        # Verify Lambda function
        try:
            lambda_response = lambda_client.get_function(FunctionName=lambda_function_name)
            print(f"Lambda function verification successful: {lambda_function_name}")
        except Exception as e:
            print(f"Lambda function verification failed: {str(e)}")
            raise
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Deployment verification successful',
                'environment': environment,
                'verified_resources': {
                    'api_gateway': api_id,
                    'dynamodb_tables': dynamodb_tables,
                    'lambda_function': lambda_function_name
                }
            })
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': 'Deployment verification failed',
                'error': str(e)
            })
        }
</file>

<file path="lambdas/get_prices_lambda/__init__.py">
# This file makes the get_prices_lambda directory a Python package
</file>

<file path="lambdas/get_prices_lambda/scraper.py">
import json
import logging
import os
import re
import time
from datetime import datetime, timezone
from typing import Optional

import boto3
import requests
import yaml
from bs4 import BeautifulSoup
from pydantic import BaseModel, validator
from tenacity import (retry, retry_if_exception_type, stop_after_attempt,
                      wait_exponential)

logger = logging.getLogger()
logger.setLevel(logging.INFO)

class ScraperError(Exception):
    """スクレイピングエラーの基底クラス"""
    pass

class HTTPError(ScraperError):
    """HTTPリクエストエラー"""
    pass

class ParseError(ScraperError):
    """データパースエラー"""
    pass

class RetryTracker:
    def __init__(self):
        self.attempts = {}
    
    def track_attempt(self, url):
        if url not in self.attempts:
            self.attempts[url] = 0
        self.attempts[url] += 1
        return self.attempts[url]

retry_tracker = RetryTracker()

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    reraise=True
)
def safe_request(url, headers, timeout):
    try:
        response = requests.get(url, headers=headers, timeout=timeout)
        response.raise_for_status()
        return response
    except requests.exceptions.RequestException as e:
        logger.error(f"HTTP request failed: {str(e)}")
        raise HTTPError(f"Failed to fetch {url}: {str(e)}")

def notify_error(error_message):
    sns = boto3.client('sns')
    try:
        sns.publish(
            TopicArn=os.environ['ERROR_NOTIFICATION_TOPIC_ARN'],
            Message=json.dumps({
                'error': error_message,
                'timestamp': datetime.now(timezone.utc).isoformat()
            })
        )
    except Exception as e:
        logger.error(f"Failed to send error notification: {str(e)}")

def load_config():
    """
    設定ファイルを読み込む
    """
    config_path = os.path.join(os.path.dirname(__file__), '..', '..', 'config', 'config.production.yaml')
    try:
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"Error loading config: {str(e)}")
        raise

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    retry=retry_if_exception_type((HTTPError, ParseError)),
    before_sleep=lambda retry_state: logger.warning(
        f"Retrying {retry_state.fn.__name__} after {retry_state.attempt_number} attempts"
    )
)
def get_kaitori_prices():
    config = load_config()
    prices = {}
    
    for url in config['scraper']['kaitori_rudea_urls']:
        attempt = retry_tracker.track_attempt(url)
        try:
            response = safe_request(
                url,
                headers={'User-Agent': config['scraper']['user_agent']},
                timeout=config['scraper']['request_timeout']
            )
            # スクレイピングロジック
        except Exception as e:
            if attempt >= 3:
                notify_error(f"Failed to scrape {url} after {attempt} attempts: {str(e)}")
            raise
    
    return prices

def get_official_prices():
    """
    Apple Storeの公式価格を取得
    """
    config = load_config()
    prices = {}
    
    try:
        response = requests.get(
            config['scraper']['apple_store_url'],
            headers={'User-Agent': config['scraper']['user_agent']},
            timeout=config['scraper']['request_timeout']
        )
        response.raise_for_status()
        
        soup = BeautifulSoup(response.text, 'html.parser')
        # TODO: スクレイピングロジックの実装
        
    except Exception as e:
        logger.error(f"Error scraping Apple Store: {str(e)}")
    
    return prices 

class PriceData(BaseModel):
    model: str
    price: float
    currency: str = "JPY"
    source: str
    timestamp: datetime
    condition: Optional[str] = None
    
    @validator('price')
    def validate_price(cls, v):
        if v <= 0:
            raise ValueError("Price must be positive")
        return round(v, 2)
    
    @validator('model')
    def validate_model(cls, v):
        if not re.match(r'^iPhone \d{1,2}(?: Pro| Pro Max)? \d{1,3}GB$', v):
            raise ValueError("Invalid model format")
        return v

def normalize_price_data(raw_data):
    try:
        return PriceData(
            model=raw_data['model'],
            price=float(raw_data['price'].replace(',', '')),
            source=raw_data['source'],
            timestamp=datetime.now(timezone.utc),
            condition=raw_data.get('condition')
        )
    except Exception as e:
        logger.error(f"Failed to normalize price data: {str(e)}")
        raise ParseError(f"Data normalization failed: {str(e)}")
</file>

<file path="lambdas/line_notification_lambda/main.py">
import json
import logging
import os

from linebot import LineBotApi
from linebot.models import TextSendMessage

# ログ設定
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# LINE Bot APIの初期化
line_bot_api = LineBotApi(os.environ['LINE_CHANNEL_ACCESS_TOKEN'])

def lambda_handler(event, context):
    try:
        # イベントから通知内容を取得
        message = event.get('message', '')
        if not message:
            raise ValueError('メッセージが指定されていません')

        # LINEにメッセージを送信
        line_bot_api.broadcast(TextSendMessage(text=message))
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': '通知を送信しました'
            })
        }
        
    except Exception as e:
        logger.error(f'エラーが発生しました: {str(e)}')
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': str(e)
            })
        }
</file>

<file path="lambdas/predict_prices_lambda/predict_prices.py">
import json
from datetime import datetime, timedelta
from typing import Any, Dict, List

import boto3
import numpy as np

dynamodb = boto3.resource('dynamodb')
price_history_table = dynamodb.Table('price_history')
price_predictions_table = dynamodb.Table('price_predictions')

def calculate_linear_regression(x: List[float], y: List[float]) -> tuple:
    """単純な線形回帰を計算"""
    n = len(x)
    sum_x = sum(x)
    sum_y = sum(y)
    sum_xy = sum(xi * yi for xi, yi in zip(x, y))
    sum_x2 = sum(xi * xi for xi in x)
    
    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    intercept = (sum_y - slope * sum_x) / n
    
    return slope, intercept

def predict_prices(model_id: str, days: int = 7) -> Dict[str, Any]:
    """価格予測を実行"""
    # 過去30日分の価格データを取得
    end_date = datetime.now()
    start_date = end_date - timedelta(days=30)
    
    response = price_history_table.query(
        IndexName='DateIndex',
        KeyConditionExpression='model = :model AND #date BETWEEN :start AND :end',
        ExpressionAttributeNames={
            '#date': 'date'
        },
        ExpressionAttributeValues={
            ':model': model_id,
            ':start': start_date.strftime('%Y-%m-%d'),
            ':end': end_date.strftime('%Y-%m-%d')
        }
    )
    
    if not response['Items']:
        return {
            'error': 'No historical data available for prediction'
        }
    
    # データの準備
    prices = sorted(response['Items'], key=lambda x: x['date'])
    x = list(range(len(prices)))
    y = [float(item['price']) for item in prices]
    
    # 線形回帰の計算
    slope, intercept = calculate_linear_regression(x, y)
    
    # 予測の実行
    predictions = []
    last_date = datetime.strptime(prices[-1]['date'], '%Y-%m-%d')
    
    for i in range(1, days + 1):
        prediction_date = last_date + timedelta(days=i)
        predicted_price = slope * (len(prices) + i) + intercept
        
        # 信頼区間の計算（簡易版）
        std_dev = np.std(y)
        confidence_interval = 1.96 * std_dev / np.sqrt(len(y))
        
        predictions.append({
            'date': prediction_date.strftime('%Y-%m-%d'),
            'predicted_price': round(predicted_price, 2),
            'confidence_interval': round(confidence_interval, 2)
        })
        
        # 予測結果をキャッシュ
        price_predictions_table.put_item(
            Item={
                'model_id': model_id,
                'prediction_date': prediction_date.strftime('%Y-%m-%d'),
                'predicted_price': round(predicted_price, 2),
                'confidence_interval': round(confidence_interval, 2),
                'expiration_time': int((datetime.now() + timedelta(days=1)).timestamp())
            }
        )
    
    return {
        'model_id': model_id,
        'predictions': predictions,
        'trend': 'up' if slope > 0 else 'down' if slope < 0 else 'stable',
        'trend_strength': abs(slope)
    }

def lambda_handler(event, context):
    try:
        # クエリパラメータからモデルIDを取得
        model_id = event.get('queryStringParameters', {}).get('model')
        if not model_id:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Model ID is required'})
            }
        
        # 予測期間を取得（デフォルト7日）
        days = int(event.get('queryStringParameters', {}).get('days', 7))
        
        # 予測を実行
        result = predict_prices(model_id, days)
        
        return {
            'statusCode': 200,
            'body': json.dumps(result)
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
</file>

<file path="lambdas/smoke_test_lambda/smoke_test.py">
import json
import os

import boto3
import requests


def lambda_handler(event, context):
    try:
        # Get environment variables
        api_url = os.environ.get('API_URL')
        dynamodb_tables = json.loads(os.environ.get('DYNAMODB_TABLES', '[]'))
        environment = os.environ.get('ENVIRONMENT')
        lambda_function_name = os.environ.get('LAMBDA_FUNCTION_NAME')
        
        # Initialize AWS clients
        dynamodb = boto3.client('dynamodb')
        lambda_client = boto3.client('lambda')
        
        # Test API endpoint
        try:
            response = requests.get(api_url)
            response.raise_for_status()
            print(f"API endpoint test successful: {api_url}")
        except Exception as e:
            print(f"API endpoint test failed: {str(e)}")
            raise
        
        # Test DynamoDB tables
        for table_name in dynamodb_tables:
            try:
                table_response = dynamodb.describe_table(TableName=table_name)
                print(f"DynamoDB table test successful: {table_name}")
            except Exception as e:
                print(f"DynamoDB table test failed for {table_name}: {str(e)}")
                raise
        
        # Test Lambda function
        try:
            lambda_response = lambda_client.invoke(
                FunctionName=lambda_function_name,
                InvocationType='RequestResponse'
            )
            print(f"Lambda function test successful: {lambda_function_name}")
        except Exception as e:
            print(f"Lambda function test failed: {str(e)}")
            raise
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Smoke test successful',
                'environment': environment,
                'tested_resources': {
                    'api_endpoint': api_url,
                    'dynamodb_tables': dynamodb_tables,
                    'lambda_function': lambda_function_name
                }
            })
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': 'Smoke test failed',
                'error': str(e)
            })
        }
</file>

<file path="lambdas/__init__.py">
# This file makes the lambda directory a Python package
</file>

<file path="scripts/cleanup.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、AWSリソースのクリーンアップを実行します。
以下のコマンドで実行します：
    python3 cleanup.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

クリーンアップ手順:
1. DynamoDBテーブルのデータ削除
2. Terraformによるリソースの削除
3. クリーンアップの検証
"""

import json
import logging
import os
import subprocess
import sys
import time

import boto3

# ロギングの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def run_command(command, cwd=None):
    """コマンドを実行し、結果を返す"""
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            check=True,
            capture_output=True,
            text=True
        )
        return True, result.stdout
    except subprocess.CalledProcessError as e:
        return False, f"Error executing command: {e.stderr}"

def cleanup_dynamodb_tables():
    """DynamoDBテーブルのデータを削除"""
    logger.info("Cleaning up DynamoDB tables...")
    
    dynamodb = boto3.client('dynamodb')
    tables = [
        'iphone_prices',
        'official_prices',
        'price_comparison',
        'price_history',
        'price_predictions',
        'kaitori_prices'
    ]

    for table_name in tables:
        try:
            # テーブルの存在確認
            try:
                dynamodb.describe_table(TableName=table_name)
            except dynamodb.exceptions.ResourceNotFoundException:
                logger.info(f"Table {table_name} does not exist, skipping...")
                continue

            # テーブルのスキャン
            response = dynamodb.scan(TableName=table_name)
            items = response.get('Items', [])

            # バッチ削除
            with dynamodb.batch_writer(TableName=table_name) as batch:
                for item in items:
                    batch.delete_item(Key={k: v for k, v in item.items() if k in ['model', 'timestamp']})

            logger.info(f"Cleaned up table {table_name}")
        except Exception as e:
            logger.error(f"Error cleaning up table {table_name}: {e}")
            return False

    return True

def run_terraform_destroy():
    """Terraformでリソースを削除"""
    logger.info("Running Terraform destroy...")
    
    success, output = run_command(["terraform", "destroy", "-auto-approve"], cwd="terraform")
    if not success:
        logger.error(f"Failed to destroy Terraform resources: {output}")
        return False
    logger.info("Terraform resources destroyed successfully")
    return True

def verify_cleanup():
    """クリーンアップを検証"""
    logger.info("Verifying cleanup...")
    
    dynamodb = boto3.client('dynamodb')
    tables = [
        'iphone_prices',
        'official_prices',
        'price_comparison',
        'price_history',
        'price_predictions',
        'kaitori_prices'
    ]

    for table_name in tables:
        try:
            # テーブルの存在確認
            try:
                response = dynamodb.describe_table(TableName=table_name)
                # テーブルが存在する場合、アイテム数を確認
                count = dynamodb.scan(TableName=table_name, Select='COUNT')
                if count['Count'] > 0:
                    logger.error(f"Table {table_name} still contains {count['Count']} items")
                    return False
            except dynamodb.exceptions.ResourceNotFoundException:
                logger.info(f"Table {table_name} does not exist (expected)")
                continue
        except Exception as e:
            logger.error(f"Error verifying table {table_name}: {e}")
            return False

    logger.info("Cleanup verification successful")
    return True

def main():
    """メイン関数"""
    try:
        # 必要な環境変数の確認
        required_env_vars = ['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_DEFAULT_REGION']
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]
        if missing_vars:
            logger.error(f"Missing required environment variables: {', '.join(missing_vars)}")
            return 1

        # クリーンアップ手順の実行
        steps = [
            ("Cleaning up DynamoDB tables", cleanup_dynamodb_tables),
            ("Running Terraform destroy", run_terraform_destroy),
            ("Verifying cleanup", verify_cleanup)
        ]

        for step_name, step_func in steps:
            logger.info(f"Starting: {step_name}")
            if not step_func():
                logger.error(f"Failed: {step_name}")
                return 1
            logger.info(f"Completed: {step_name}")

        logger.info("Cleanup completed successfully")
        return 0

    except Exception as e:
        logger.error(f"Unexpected error during cleanup: {str(e)}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="scripts/deploy.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、AWSリソースのデプロイメントを実行します。
以下のコマンドで実行します：
    python3 deploy.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

デプロイメント手順:
1. Lambda関数のパッケージング
2. Terraformの実行
3. デプロイメントの検証
"""

import json
import logging
import os
import subprocess
import sys
import time

# ロギングの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def run_command(command, cwd=None):
    """コマンドを実行し、結果を返す"""
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            check=True,
            capture_output=True,
            text=True
        )
        return True, result.stdout
    except subprocess.CalledProcessError as e:
        return False, f"Error executing command: {e.stderr}"

def package_lambda_functions():
    """Lambda関数をパッケージング"""
    logger.info("Packaging Lambda functions...")
    success, output = run_command(["python3", "package_lambda.py"], cwd="scripts")
    if not success:
        logger.error(f"Failed to package Lambda functions: {output}")
        return False
    logger.info("Lambda functions packaged successfully")
    return True

def run_terraform():
    """Terraformを実行"""
    logger.info("Running Terraform...")
    
    # Terraformの初期化
    success, output = run_command(["terraform", "init"], cwd="terraform")
    if not success:
        logger.error(f"Failed to initialize Terraform: {output}")
        return False
    logger.info("Terraform initialized successfully")

    # Terraformの実行
    success, output = run_command(["terraform", "apply", "-auto-approve"], cwd="terraform")
    if not success:
        logger.error(f"Failed to apply Terraform: {output}")
        return False
    logger.info("Terraform applied successfully")
    return True

def verify_deployment():
    """デプロイメントを検証"""
    logger.info("Verifying deployment...")
    success, output = run_command(["python3", "deployment-verification.py"], cwd="scripts")
    if not success:
        logger.error(f"Deployment verification failed: {output}")
        return False

    try:
        result = json.loads(output)
        if result['status'] == 'success':
            logger.info("Deployment verification successful")
            return True
        else:
            logger.error(f"Deployment verification failed: {result['message']}")
            return False
    except json.JSONDecodeError:
        logger.error("Failed to parse verification output")
        return False

def main():
    """メイン関数"""
    try:
        # 必要な環境変数の確認
        required_env_vars = ['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_DEFAULT_REGION']
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]
        if missing_vars:
            logger.error(f"Missing required environment variables: {', '.join(missing_vars)}")
            return 1

        # デプロイメント手順の実行
        steps = [
            ("Packaging Lambda functions", package_lambda_functions),
            ("Running Terraform", run_terraform),
            ("Verifying deployment", verify_deployment)
        ]

        for step_name, step_func in steps:
            logger.info(f"Starting: {step_name}")
            if not step_func():
                logger.error(f"Failed: {step_name}")
                return 1
            logger.info(f"Completed: {step_name}")

        logger.info("Deployment completed successfully")
        return 0

    except Exception as e:
        logger.error(f"Unexpected error during deployment: {str(e)}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
</file>

<file path="scripts/deployment-verification.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、デプロイメント検証の実装に使用されます。
以下のコマンドで実行します：
    python3 deployment-verification.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

検証内容:
1. Lambda関数の状態確認
2. DynamoDBテーブルの状態確認
3. API Gatewayの状態確認
"""

import json
import logging
import os
import time

import boto3

# ロギングの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_api_id():
    """API GatewayのIDを取得"""
    try:
        apigateway = boto3.client('apigateway')
        response = apigateway.get_rest_apis()
        if not response['items']:
            logger.error("No API Gateway found")
            return None
        return response['items'][0]['id']
    except Exception as e:
        logger.error(f"Error getting API ID: {e}")
        return None

def verify_lambda_function(lambda_client, function_name):
    """Lambda関数の状態を確認"""
    try:
        response = lambda_client.get_function(FunctionName=function_name)
        state = response['Configuration']['State']
        logger.info(f"Lambda function {function_name} is {state}")
        return state == 'Active'
    except Exception as e:
        logger.error(f"Error verifying Lambda function {function_name}: {e}")
        return False

def verify_dynamodb_tables(dynamodb_client, table_names):
    """DynamoDBテーブルの状態を確認"""
    results = {}
    for table_name in table_names:
        try:
            response = dynamodb_client.describe_table(TableName=table_name)
            status = response['Table']['TableStatus']
            logger.info(f"DynamoDB table {table_name} is {status}")
            results[table_name] = status == 'ACTIVE'
        except Exception as e:
            logger.error(f"Error verifying DynamoDB table {table_name}: {e}")
            results[table_name] = False
    return all(results.values())

def verify_api_gateway(apigateway_client, api_id):
    """API Gatewayの状態を確認"""
    if not api_id:
        logger.error("API ID is not available")
        return False

    try:
        response = apigateway_client.get_rest_api(restApiId=api_id)
        logger.info(f"API Gateway {api_id} is active")
        return True
    except Exception as e:
        logger.error(f"Error verifying API Gateway {api_id}: {e}")
        return False

def main():
    """メイン関数"""
    try:
        # AWSクライアントの初期化
        lambda_client = boto3.client('lambda')
        dynamodb_client = boto3.client('dynamodb')
        apigateway_client = boto3.client('apigateway')

        # 検証対象のリソース
        lambda_functions = ['get_prices']
        dynamodb_tables = ['iphone_prices', 'official_prices']
        api_id = get_api_id()

        # 最大10回のリトライ
        max_retries = 10
        retry_interval = 30  # 秒

        for attempt in range(max_retries):
            logger.info(f"Verification attempt {attempt + 1}/{max_retries}")

            # 各リソースの状態を確認
            lambda_status = all(verify_lambda_function(lambda_client, func) for func in lambda_functions)
            dynamodb_status = verify_dynamodb_tables(dynamodb_client, dynamodb_tables)
            api_status = verify_api_gateway(apigateway_client, api_id)

            # すべてのリソースが正常な場合
            if lambda_status and dynamodb_status and api_status:
                logger.info("All resources are active and ready")
                return {
                    'status': 'success',
                    'message': 'All resources are active and ready'
                }

            # 最後の試行でない場合は待機
            if attempt < max_retries - 1:
                logger.info(f"Waiting {retry_interval} seconds before next attempt...")
                time.sleep(retry_interval)

        # 最大リトライ回数を超えた場合
        error_message = "Verification failed after maximum retries"
        logger.error(error_message)
        return {
            'status': 'error',
            'message': error_message
        }

    except Exception as e:
        error_message = f"Error during verification: {str(e)}"
        logger.error(error_message)
        return {
            'status': 'error',
            'message': error_message
        }

if __name__ == "__main__":
    result = main()
    print(json.dumps(result))
</file>

<file path="scripts/local_dev.sh">
#!/bin/bash

# スクリプトのディレクトリを取得
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"

# プロジェクトのルートディレクトリに移動
cd "$PROJECT_ROOT"

# 必要なディレクトリの作成
echo "必要なディレクトリを作成中..."
mkdir -p logs
mkdir -p cache
mkdir -p config
mkdir -p src/lambda_functions/get_prices_lambda

# 仮想環境の作成と有効化
echo "仮想環境を作成中..."
python3 -m venv venv
source venv/bin/activate

# 依存関係のインストール
echo "依存関係をインストール中..."
pip install -r requirements.txt
pip install requests beautifulsoup4 boto3 pyyaml pytest pytest-cov

# ローカル開発用の設定ファイルを作成
echo "ローカル開発用の設定ファイルを作成中..."
cat > config/local_config.yaml << EOL
scraper:
  user_agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
  request_timeout: 10
  kaitori_rudea_urls:
    - "https://example.com/kaitori1"
    - "https://example.com/kaitori2"
  apple_store_url: "https://example.com/apple"
  cache:
    enabled: true
    duration: 3600
    directory: "cache"

dynamodb:
  region: "ap-northeast-1"
  table_name: "iphone_prices"
  endpoint_url: "http://localhost:8000"  # DynamoDB Localを使用する場合
EOL

# テストの実行
echo "テストを実行中..."
export PYTHONPATH=$PROJECT_ROOT
pytest tests/ --cov=src --cov-report=term-missing

# ローカル開発用のDynamoDB Localのセットアップ（オプション）
echo "DynamoDB Localのセットアップ（オプション）..."
if [ ! -f "dynamodb_local_latest.tar.gz" ]; then
    echo "DynamoDB Localをダウンロード中..."
    curl -L -o dynamodb_local_latest.tar.gz https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz
    mkdir -p dynamodb_local
    tar xf dynamodb_local_latest.tar.gz -C dynamodb_local
fi

# 開発用のヘルパースクリプトを作成
echo "開発用のヘルパースクリプトを作成中..."
cat > scripts/run_local.sh << EOL
#!/bin/bash
source venv/bin/activate
export PYTHONPATH=\$(pwd)
python src/lambda_functions/get_prices_lambda/scraper.py
EOL
chmod +x scripts/run_local.sh

echo "ローカル開発環境のセットアップが完了しました！"
echo "以下のコマンドで開発を開始できます："
echo "1. 仮想環境の有効化: source venv/bin/activate"
echo "2. スクレイパーの実行: ./scripts/run_local.sh"
echo "3. テストの実行: PYTHONPATH=\$(pwd) pytest tests/"
</file>

<file path="scripts/README.md">
# スクリプト使用方法

このディレクトリには、AWS リソースのデプロイメント、検証、クリーンアップに使用するスクリプトが含まれています。

## 前提条件

以下の環境変数が設定されている必要があります：

```bash
export AWS_ACCESS_KEY_ID="your_access_key"
export AWS_SECRET_ACCESS_KEY="your_secret_key"
export AWS_DEFAULT_REGION="your_region"
```

## スクリプト一覧

### 1. デプロイメントスクリプト (`deploy.py`)

AWS リソースのデプロイメントを実行します。

```bash
python3 deploy.py
```

実行手順：

1. Lambda 関数のパッケージング
2. Terraform の実行
3. デプロイメントの検証

### 2. デプロイメント検証スクリプト (`deployment-verification.py`)

デプロイされたリソースの状態を確認します。

```bash
python3 deployment-verification.py
```

検証内容：

1. Lambda 関数の状態確認
2. DynamoDB テーブルの状態確認
3. API Gateway の状態確認

### 3. クリーンアップスクリプト (`cleanup.py`)

AWS リソースのクリーンアップを実行します。

```bash
python3 cleanup.py
```

クリーンアップ手順：

1. DynamoDB テーブルのデータ削除
2. Terraform によるリソースの削除
3. クリーンアップの検証

### 4. Lambda 関数パッケージングスクリプト (`package_lambda.py`)

Lambda 関数をパッケージングします。

```bash
python3 package_lambda.py
```

### 5. データロードスクリプト (`load_dynamodb_data.py`)

DynamoDB テーブルにデータをロードします。

```bash
python3 load_dynamodb_data.py
```

### 6. スモークテストスクリプト (`smoke-test.py`)

デプロイされたリソースの基本的な機能テストを実行します。

```bash
python3 smoke-test.py
```

## エラーハンドリング

各スクリプトは以下のエラー処理を行います：

1. 環境変数の不足
2. AWS 認証エラー
3. リソースの存在確認
4. 操作の成功/失敗の検証

エラーが発生した場合は、ログに詳細な情報が出力されます。

## ログ出力

すべてのスクリプトは、以下の情報をログに出力します：

1. 実行開始/終了
2. 各ステップの進行状況
3. エラー情報
4. 検証結果

## 注意事項

1. クリーンアップスクリプトは、すべてのリソースを削除します。実行前に確認してください。
2. デプロイメントスクリプトは、既存のリソースを上書きします。
3. スモークテストは、実際の API エンドポイントを呼び出します。
</file>

<file path="scripts/run_local.sh">
#!/bin/bash
source venv/bin/activate
export PYTHONPATH=$(pwd)
python src/lambda_functions/get_prices_lambda/scraper.py
</file>

<file path="scripts/run_smoke_tests.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、スモークテストの実行に使用されます。
以下のコマンドで実行します：
    python3 run_smoke_tests.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION
- LAMBDA_FUNCTION_NAME: テスト対象のLambda関数名
- DYNAMODB_TABLES: テスト対象のDynamoDBテーブル名のJSON配列
- API_URL: テスト対象のAPIエンドポイントURL

テスト内容:
1. Lambda関数の呼び出しテスト
2. DynamoDBの基本操作テスト
3. APIエンドポイントのテスト
"""

import json
import logging
import os

import boto3
import requests

# ロギングの設定
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# AWSクライアントの初期化
lambda_client = boto3.client('lambda')
dynamodb_client = boto3.client('dynamodb')

def test_lambda_invocation(function_name):
    """Lambda関数の呼び出しテスト"""
    try:
        response = lambda_client.invoke(
            FunctionName=function_name,
            InvocationType='RequestResponse'
        )
        if response['StatusCode'] == 200:
            logger.info(f"Lambda function {function_name} invocation successful")
            return True
        else:
            logger.error(f"Lambda function {function_name} invocation failed")
            return False
    except Exception as e:
        logger.error(f"Error testing Lambda function {function_name}: {str(e)}")
        return False

def test_dynamodb_operations(table_names):
    """DynamoDBの基本操作テスト"""
    try:
        for table_name in table_names:
            # テーブルの状態確認
            response = dynamodb_client.describe_table(TableName=table_name)
            if response['Table']['TableStatus'] != 'ACTIVE':
                logger.error(f"DynamoDB table {table_name} is not active")
                return False

            # サンプルデータのスキャン
            response = dynamodb_client.scan(
                TableName=table_name,
                Limit=1
            )
            logger.info(f"DynamoDB table {table_name} scan successful")
        return True
    except Exception as e:
        logger.error(f"Error testing DynamoDB operations: {str(e)}")
        return False

def test_api_endpoint(api_url):
    """APIエンドポイントのテスト"""
    try:
        response = requests.get(api_url)
        if response.status_code == 200:
            logger.info(f"API endpoint {api_url} test successful")
            return True
        else:
            logger.error(f"API endpoint {api_url} test failed with status code {response.status_code}")
            return False
    except Exception as e:
        logger.error(f"Error testing API endpoint {api_url}: {str(e)}")
        return False

def main():
    """メイン関数"""
    try:
        # 環境変数から設定を取得
        lambda_function_name = os.environ['LAMBDA_FUNCTION_NAME']
        dynamodb_tables = json.loads(os.environ['DYNAMODB_TABLES'])
        api_url = os.environ['API_URL']

        # 各テストを実行
        lambda_test = test_lambda_invocation(lambda_function_name)
        dynamodb_test = test_dynamodb_operations(dynamodb_tables)
        api_test = test_api_endpoint(api_url)

        # すべてのテストが成功した場合
        if lambda_test and dynamodb_test and api_test:
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'message': 'All smoke tests passed',
                    'lambda_function': lambda_function_name,
                    'dynamodb_tables': dynamodb_tables,
                    'api_url': api_url
                })
            }
        else:
            return {
                'statusCode': 500,
                'body': json.dumps({
                    'message': 'Some smoke tests failed',
                    'lambda_function': lambda_function_name,
                    'dynamodb_tables': dynamodb_tables,
                    'api_url': api_url
                })
            }

    except Exception as e:
        logger.error(f"Error in smoke testing process: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': f'Smoke testing failed: {str(e)}'
            })
        }

if __name__ == "__main__":
    result = main()
    print(json.dumps(result))
</file>

<file path="scripts/smoke-test.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、スモークテストの実装に使用されます。
以下のコマンドで実行します：
    python3 smoke-test.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

テスト内容:
1. Lambda関数の呼び出しテスト
2. DynamoDBの基本操作テスト
3. APIエンドポイントのテスト（APIキー認証付き）
"""

import json
import logging
import os
import time

import boto3
import requests

# ロギングの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_api_key():
    """API GatewayのAPIキーを取得"""
    try:
        apigateway = boto3.client('apigateway')
        
        # APIキーが存在しない場合は作成
        response = apigateway.get_api_keys(includeValues=True)
        if not response['items']:
            logger.info("Creating new API key...")
            response = apigateway.create_api_key(
                name="SmokeTestKey",
                enabled=True,
                generateDistinctId=True
            )
            api_key = response['value']
            
            # 使用計画を作成
            usage_plan = apigateway.create_usage_plan(
                name="SmokeTestPlan",
                description="Plan for smoke tests",
                apiStages=[{
                    'apiId': get_api_id(),
                    'stage': 'prod'
                }]
            )
            
            # APIキーを使用計画に関連付け
            apigateway.create_usage_plan_key(
                usagePlanId=usage_plan['id'],
                keyId=response['id'],
                keyType='API_KEY'
            )
            
            return api_key
            
        return response['items'][0]['value']
    except Exception as e:
        logger.error(f"Error getting API key: {e}")
        return None

def get_api_id():
    """API GatewayのIDを取得"""
    try:
        apigateway = boto3.client('apigateway')
        response = apigateway.get_rest_apis()
        if not response['items']:
            logger.error("No API Gateway found")
            return None
        return response['items'][0]['id']
    except Exception as e:
        logger.error(f"Error getting API ID: {e}")
        return None

def get_api_endpoint():
    """API GatewayのエンドポイントURLを取得"""
    try:
        api_id = get_api_id()
        if not api_id:
            return None
            
        region = os.environ.get('AWS_DEFAULT_REGION', 'ap-northeast-1')
        return f"https://{api_id}.execute-api.{region}.amazonaws.com/prod/prices"
    except Exception as e:
        logger.error(f"Error getting API endpoint: {e}")
        return None

def test_lambda_invocation(lambda_client, function_name):
    """Lambda関数の呼び出しテスト"""
    try:
        response = lambda_client.invoke(
            FunctionName=function_name,
            Payload=json.dumps({})
        )
        status_code = response['StatusCode']
        logger.info(f"Lambda function {function_name} invocation status: {status_code}")
        return status_code == 200
    except Exception as e:
        logger.error(f"Error testing Lambda function {function_name}: {e}")
        return False

def test_dynamodb_operations(dynamodb_client, table_name):
    """DynamoDBの基本操作テスト"""
    try:
        # テーブルの状態を確認
        response = dynamodb_client.describe_table(TableName=table_name)
        status = response['Table']['TableStatus']
        logger.info(f"DynamoDB table {table_name} status: {status}")

        # サンプルデータのスキャン
        response = dynamodb_client.scan(
            TableName=table_name,
            Limit=1
        )
        logger.info(f"Successfully scanned {table_name}")
        return True
    except Exception as e:
        logger.error(f"Error testing DynamoDB table {table_name}: {e}")
        return False

def test_api_endpoint(api_url, api_key=None):
    """APIエンドポイントのテスト"""
    if not api_url:
        logger.error("API endpoint URL is not available")
        return False

    try:
        headers = {}
        if api_key:
            headers['x-api-key'] = api_key

        response = requests.get(api_url, headers=headers)
        status_code = response.status_code
        logger.info(f"API endpoint {api_url} status: {status_code}")
        
        if status_code == 403:
            logger.error("Access denied. Please check API Gateway authentication settings.")
            return False
            
        return status_code == 200
    except requests.exceptions.RequestException as e:
        logger.error(f"Error testing API endpoint {api_url}: {e}")
        return False

def main():
    """メイン関数"""
    try:
        # AWSクライアントの初期化
        lambda_client = boto3.client('lambda')
        dynamodb_client = boto3.client('dynamodb')

        # テスト対象のリソース
        lambda_function = 'get_prices'
        dynamodb_tables = ['iphone_prices', 'official_prices']
        api_url = get_api_endpoint()
        api_key = get_api_key()

        # Lambda関数のテスト
        lambda_result = test_lambda_invocation(lambda_client, lambda_function)

        # DynamoDBテーブルのテスト
        dynamodb_results = [test_dynamodb_operations(dynamodb_client, table) for table in dynamodb_tables]
        dynamodb_result = all(dynamodb_results)

        # APIエンドポイントのテスト
        api_result = test_api_endpoint(api_url, api_key)

        # すべてのテストが成功した場合
        if lambda_result and dynamodb_result and api_result:
            logger.info("All smoke tests passed successfully")
            return {
                'status': 'success',
                'message': 'All smoke tests passed successfully'
            }
        else:
            error_message = "Some smoke tests failed"
            logger.error(error_message)
            return {
                'status': 'error',
                'message': error_message
            }

    except Exception as e:
        error_message = f"Error during smoke tests: {str(e)}"
        logger.error(error_message)
        return {
            'status': 'error',
            'message': error_message
        }

if __name__ == "__main__":
    result = main()
    print(json.dumps(result))
</file>

<file path="scripts/test_line_notification.py">
import base64
import json
import logging
import os
import re
import sys

from linebot.v3.messaging import (ApiClient, Configuration, MessagingApi,
                                  TextMessage)
from linebot.v3.messaging.exceptions import ApiException

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def validate_token(token):
    """チャネルアクセストークンの形式を検証"""
    if not token:
        return False
    
    # Base64エンコードされたトークンのパターン
    base64_pattern = r'^[A-Za-z0-9+/=]+$'
    
    # トークンがBase64エンコードされているか確認
    if re.match(base64_pattern, token):
        try:
            # Base64デコードを試みる
            decoded = base64.b64decode(token)
            # デコードされたトークンが適切な長さか確認
            return len(decoded) >= 32
        except:
            return False
    
    # 通常のトークンの形式（43文字の英数字）
    return len(token) == 43 and token.isalnum()

def test_line_notification():
    try:
        # 環境変数からアクセストークンを取得
        channel_access_token = os.getenv('LINE_CHANNEL_ACCESS_TOKEN')
        
        if not channel_access_token:
            logger.error("LINE_CHANNEL_ACCESS_TOKEN 環境変数が設定されていません")
            logger.info("以下のコマンドで環境変数を設定してください：")
            logger.info("export LINE_CHANNEL_ACCESS_TOKEN='your_channel_access_token'")
            return False
            
        if not validate_token(channel_access_token):
            logger.error("無効なチャネルアクセストークン形式です")
            logger.info("LINE Developers コンソールから正しいアクセストークンを取得してください")
            logger.info("現在のトークン: %s", channel_access_token)
            return False

        logger.info("チャネルアクセストークンの検証に成功しました")
        
        # LINE Bot APIの初期化（v3）
        configuration = Configuration(
            access_token=channel_access_token
        )
        
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            
            # テストメッセージの送信
            message = TextMessage(text='テスト通知: iPhone価格アラートシステムが正常に動作しています。')
            line_bot_api.broadcast(
                broadcast_request={
                    'messages': [message]
                }
            )
            
            logger.info("通知が正常に送信されました")
            return True
    except ApiException as e:
        logger.error(f"LINE APIエラー: {str(e)}")
        logger.error(f"エラー詳細: {e.body}")
        logger.error("以下の点を確認してください：")
        logger.error("1. チャネルアクセストークンが正しいか")
        logger.error("2. トークンが有効期限内か")
        logger.error("3. トークンに必要な権限があるか")
        return False
    except Exception as e:
        logger.error(f"予期せぬエラー: {str(e)}")
        return False

if __name__ == "__main__":
    # 環境変数の設定（テスト用）
    # 実際のチャネルアクセストークンを設定してください
    if not os.getenv('LINE_CHANNEL_ACCESS_TOKEN'):
        logger.error("LINE_CHANNEL_ACCESS_TOKEN 環境変数が設定されていません")
        logger.info("以下のコマンドで環境変数を設定してください：")
        logger.info("export LINE_CHANNEL_ACCESS_TOKEN='your_channel_access_token'")
        sys.exit(1)
    
    # テスト実行
    success = test_line_notification()
    if success:
        print("✅ テストが正常に完了しました")
    else:
        print("❌ テストが失敗しました")
</file>

<file path="scripts/test-line-connect.py">
import json
import logging
import os

from linebot import LineBotApi
from linebot.exceptions import LineBotApiError
from linebot.models import TextSendMessage

# ログ設定
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    try:
        # LINE Bot APIの初期化
        line_bot_api = LineBotApi(os.environ['LINE_CHANNEL_ACCESS_TOKEN'])
        
        # テストメッセージの送信
        message = TextSendMessage(text='テスト通知: iPhone価格アラートシステムが正常に動作しています。')
        line_bot_api.broadcast(message)
        
        return {
            'statusCode': 200,
            'body': json.dumps('通知が正常に送信されました')
        }
    except LineBotApiError as e:
        logger.error(f"LINE APIエラー: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps(f'通知の送信に失敗しました: {str(e)}')
        }
    except Exception as e:
        logger.error(f"予期せぬエラー: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps(f'予期せぬエラーが発生しました: {str(e)}')
        }
</file>

<file path="scripts/verify_deployment.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、デプロイメントの検証に使用されます。
以下のコマンドで実行します：
    python3 verify_deployment.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION
- LAMBDA_FUNCTION_NAME: 検証対象のLambda関数名
- DYNAMODB_TABLES: 検証対象のDynamoDBテーブル名のJSON配列
- API_ID: 検証対象のAPI Gateway ID

検証内容:
1. Lambda関数の状態確認
2. DynamoDBテーブルの状態確認
3. API Gatewayのデプロイメント状態確認
"""

import json
import logging
import os
import time

import boto3

# ロギングの設定
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# AWSクライアントの初期化
lambda_client = boto3.client('lambda')
dynamodb_client = boto3.client('dynamodb')
apigateway_client = boto3.client('apigateway')

def verify_lambda_function(function_name):
    """Lambda関数の状態を確認"""
    try:
        response = lambda_client.get_function(FunctionName=function_name)
        if response['Configuration']['State'] == 'Active':
            logger.info(f"Lambda function {function_name} is active")
            return True
        else:
            logger.error(f"Lambda function {function_name} is not active")
            return False
    except Exception as e:
        logger.error(f"Error verifying Lambda function {function_name}: {str(e)}")
        return False

def verify_dynamodb_tables(table_names):
    """DynamoDBテーブルの状態を確認"""
    try:
        for table_name in table_names:
            response = dynamodb_client.describe_table(TableName=table_name)
            if response['Table']['TableStatus'] == 'ACTIVE':
                logger.info(f"DynamoDB table {table_name} is active")
            else:
                logger.error(f"DynamoDB table {table_name} is not active")
                return False
        return True
    except Exception as e:
        logger.error(f"Error verifying DynamoDB tables: {str(e)}")
        return False

def verify_api_gateway(api_id):
    """API Gatewayのデプロイメント状態を確認"""
    try:
        response = apigateway_client.get_stage(
            restApiId=api_id,
            stageName='production'
        )
        if response['deploymentId']:
            logger.info(f"API Gateway {api_id} is deployed")
            return True
        else:
            logger.error(f"API Gateway {api_id} is not deployed")
            return False
    except Exception as e:
        logger.error(f"Error verifying API Gateway: {str(e)}")
        return False

def main():
    """メイン関数"""
    try:
        # 環境変数から設定を取得
        lambda_function_name = os.environ['LAMBDA_FUNCTION_NAME']
        dynamodb_tables = json.loads(os.environ['DYNAMODB_TABLES'])
        api_id = os.environ['API_ID']

        # 最大10回のリトライ
        max_retries = 10
        retry_interval = 30  # 秒

        for attempt in range(max_retries):
            logger.info(f"Verification attempt {attempt + 1}/{max_retries}")

            # 各リソースの状態を確認
            lambda_status = verify_lambda_function(lambda_function_name)
            dynamodb_status = verify_dynamodb_tables(dynamodb_tables)
            api_status = verify_api_gateway(api_id)

            # すべてのリソースが正常な場合
            if lambda_status and dynamodb_status and api_status:
                return {
                    'statusCode': 200,
                    'body': json.dumps({
                        'message': 'All resources are active and deployed',
                        'lambda_function': lambda_function_name,
                        'dynamodb_tables': dynamodb_tables,
                        'api_gateway': api_id
                    })
                }

            # 最後の試行でない場合は待機
            if attempt < max_retries - 1:
                logger.info(f"Waiting {retry_interval} seconds before next attempt...")
                time.sleep(retry_interval)

        # 最大リトライ回数を超えた場合
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': 'Verification failed after maximum retries',
                'lambda_function': lambda_function_name,
                'dynamodb_tables': dynamodb_tables,
                'api_gateway': api_id
            })
        }

    except Exception as e:
        logger.error(f"Error in verification process: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': f'Verification failed: {str(e)}'
            })
        }

if __name__ == "__main__":
    result = main()
    print(json.dumps(result))
</file>

<file path="src/lambda_functions/get_prices_lambda/config/__init__.py">
"""
Configuration management for the price comparison application.
"""
</file>

<file path="src/lambda_functions/get_prices_lambda/config/config.production.yaml">
scraper:
  selectors:
    price_item: ".price-item"
    model: ".model"
    price: ".price"
    condition: ".condition"
  headers:
    User-Agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
    Accept-Language: "ja,en-US;q=0.7,en;q=0.3"
    Connection: "keep-alive"
    Upgrade-Insecure-Requests: "1"
  user_agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
  max_retries: 3
  timeout: 30
  cache_duration: 3600
urls:
  kaitori:
    - "https://www.apple.com/jp/shop/buy-iphone"
  official:
    - "https://www.apple.com/jp/shop/buy-iphone"
</file>

<file path="src/lambda_functions/get_prices_lambda/config/config.yaml">
scraper:
  selectors:
    price_item: ".price-item"
    model: ".model"
    price: ".price"
    condition: ".condition"
  headers:
    User-Agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
    Accept-Language: "ja,en-US;q=0.7,en;q=0.3"
    Connection: "keep-alive"
    Upgrade-Insecure-Requests: "1"
  user_agent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
  max_retries: 3
  timeout: 30
  cache_duration: 3600

urls:
  kaitori:
    - "https://example.com/kaitori"
  official:
    - "https://example.com/official"

dynamodb:
  table_name: "price_data"
  region: "ap-northeast-1"
</file>

<file path="terraform/policies/terraform-policy.json">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:*",
        "dynamodb:*",
        "lambda:*",
        "apigateway:*",
        "iam:*",
        "cloudwatch:*",
        "logs:*",
        "ec2:*"
      ],
      "Resource": "*"
    }
  ]
}
</file>

<file path="terraform/policies/trust-policy.json">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::273354647319:oidc-provider/token.actions.githubusercontent.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringLike": {
          "token.actions.githubusercontent.com:sub": "repo:PheasantDevil/priceComparisonAppForIphone:*"
        },
        "StringEquals": {
          "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
        }
      }
    }
  ]
}
</file>

<file path="terraform/outputs.tf">
output "api_gateway_url" {
  description = "API GatewayのエンドポイントURL"
  value       = "${aws_api_gateway_stage.production.invoke_url}/${aws_api_gateway_resource.prices.path_part}"
}

output "dynamodb_table_name" {
  description = "DynamoDBテーブルの名前"
  value       = aws_dynamodb_table.price_comparison.name
}

output "lambda_function_name" {
  description = "Lambda関数の名前"
  value       = aws_lambda_function.get_prices.function_name
}

output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "dynamodb_table_arn" {
  value = aws_dynamodb_table.iphone_prices.arn
}

output "official_prices_table_arn" {
  value = aws_dynamodb_table.official_prices.arn
}

output "lambda_function_arn" {
  value = aws_lambda_function.get_prices.arn
}

output "lambda_role_arn" {
  description = "ARN of the Lambda role"
  value       = aws_iam_role.lambda_execution_role.arn
}
</file>

<file path="terraform/provider.tf">
provider "aws" {
  region = "ap-northeast-1"

  default_tags {
    tags = {
      Environment = "production"
      Project     = "iphone_price_tracker"
    }
  }
}
</file>

<file path="tests/integration/test_config_integration.py">
from pathlib import Path

import pytest

from config import ConfigManager


def test_config_environment_integration(mock_env_vars, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 環境変数からの値
    assert config.app.SECRET_KEY == mock_env_vars["SECRET_KEY"]
    
    # 設定ファイルからの値
    assert isinstance(config.app.DEBUG, bool)
    assert config.app.LOG_LEVEL in ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

def test_scraper_config_integration(mock_env_vars, test_config_file):
    """スクレイパー設定の統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    assert config.scraper.REQUEST_TIMEOUT > 0
    assert config.scraper.RETRY_COUNT >= 0
    assert all("http" in url for url in config.scraper.KAITORI_RUDEA_URLS)
    assert "http" in config.scraper.APPLE_STORE_URL

# ConfigManager の統合テスト: 設定ファイルと環境変数が正しく統合されるか確認
def test_config_integration_with_file_and_env(monkeypatch, test_config_file):
    """設定ファイルと環境変数の統合テスト"""
    monkeypatch.setenv("FLASK_ENV", "testing")
    monkeypatch.setenv("SECRET_KEY", "env-secret-key-16ch")  # 16文字以上に変更
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 統合後の ConfigManager が正しく値を取得しているか確認
    assert config.app.SECRET_KEY == "env-secret-key-16ch"  # 環境変数が優先される
    assert config.app.DEBUG is True  # 設定ファイルから取得
    assert config.scraper.REQUEST_TIMEOUT == 30  # 設定ファイルから取得

# 設定ファイルが存在しない場合のテスト
def test_config_file_not_found():
    """設定ファイルが見つからない場合のエラーハンドリング"""
    # 存在しないディレクトリを指定して ConfigManager を初期化
    with pytest.raises(FileNotFoundError, match="Configuration file not found"):
        ConfigManager(config_dir="non_existent_directory")

def test_iphone16_pro_url_integration(mock_env_vars, test_config_file):
    """iPhone 16 Pro URLの統合テスト"""
    config = ConfigManager(config_dir=test_config_file.parent)
    
    # 全てのiPhoneモデルのURLが含まれているか確認
    expected_urls = [
        "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
        "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
        "https://kaitori-rudeya.com/category/detail/186",  # iPhone 16 Pro Max
        "https://kaitori-rudeya.com/category/detail/205"   # iPhone 16 e
    ]
    
    # URLの数が正しいか確認
    assert len(config.scraper.KAITORI_RUDEA_URLS) == len(expected_urls)
    
    # 各URLが正しく含まれているか確認
    for url in expected_urls:
        assert url in config.scraper.KAITORI_RUDEA_URLS
        
    # URLの順序が正しいか確認
    assert config.scraper.KAITORI_RUDEA_URLS == expected_urls
</file>

<file path="tests/unit/__init__.py">
# This file makes the unit directory a Python package
</file>

<file path="tests/unit/scraper.py">
from datetime import datetime, timezone
from unittest.mock import MagicMock, patch

import pytest

from lambdas.get_prices_lambda.scraper import (PriceData, ScraperError,
                                               get_kaitori_prices,
                                               get_official_prices)


@pytest.fixture
def mock_response():
    response = MagicMock()
    response.text = """
    <div class="price">¥120,000</div>
    <div class="model">iPhone 15 128GB</div>
    """
    return response

def test_get_kaitori_prices_success(mock_response):
    with patch('requests.get', return_value=mock_response):
        prices = get_kaitori_prices()
        assert len(prices) > 0
        assert isinstance(prices[0], PriceData)

def test_get_kaitori_prices_retry():
    with patch('requests.get', side_effect=Exception("Connection error")):
        with pytest.raises(ScraperError):
            get_kaitori_prices()

def test_price_data_validation():
    valid_data = {
        'model': 'iPhone 15 128GB',
        'price': '120000',
        'source': 'test_source',
        'timestamp': datetime.now(timezone.utc)
    }
    price_data = PriceData(**valid_data)
    assert price_data.price == 120000.00
    assert price_data.currency == "JPY"

def test_price_data_invalid_model():
    invalid_data = {
        'model': 'Invalid Model',
        'price': '120000',
        'source': 'test_source',
        'timestamp': datetime.now(timezone.utc)
    }
    with pytest.raises(ValueError):
        PriceData(**invalid_data)
</file>

<file path="tests/unit/test_config_manager.py">
import os
from pathlib import Path
from unittest.mock import mock_open, patch

import pytest

from src.lambda_functions.get_prices_lambda.config.manager import ConfigManager


@pytest.fixture
def mock_config_data():
    return """
    scraper:
      timeout: 30
      max_retries: 3
      cache_expiry: 3600
      user_agent: "Mozilla/5.0"
    
    dynamodb:
      table_name: "price_comparison"
      region: "ap-northeast-1"
    
    urls:
      kaitori_rudea:
        - "https://example.com/kaitori1"
        - "https://example.com/kaitori2"
      official:
        - "https://example.com/official1"
        - "https://example.com/official2"
    """

@pytest.fixture
def config_manager():
    return ConfigManager()

def test_config_manager_initialization():
    """ConfigManagerの初期化テスト"""
    manager = ConfigManager()
    assert manager.config is None
    assert manager.config_path is not None

def test_load_config_success(config_manager, mock_config_data):
    """設定ファイルの読み込み成功テスト"""
    with patch("builtins.open", mock_open(read_data=mock_config_data)):
        config_manager.load_config()
        assert config_manager.config is not None
        assert "scraper" in config_manager.config
        assert "dynamodb" in config_manager.config
        assert "urls" in config_manager.config

def test_load_config_file_not_found(config_manager):
    """設定ファイルが存在しない場合のテスト"""
    with pytest.raises(FileNotFoundError):
        config_manager.load_config()

def test_load_config_invalid_yaml(config_manager):
    """無効なYAML形式のテスト"""
    invalid_yaml = "invalid: yaml: content:"
    with patch("builtins.open", mock_open(read_data=invalid_yaml)):
        with pytest.raises(Exception):
            config_manager.load_config()

def test_get_scraper_config(config_manager, mock_config_data):
    """スクレイパー設定の取得テスト"""
    with patch("builtins.open", mock_open(read_data=mock_config_data)):
        config_manager.load_config()
        scraper_config = config_manager.get_scraper_config()
        assert scraper_config["timeout"] == 30
        assert scraper_config["max_retries"] == 3
        assert scraper_config["cache_expiry"] == 3600
        assert scraper_config["user_agent"] == "Mozilla/5.0"

def test_get_dynamodb_config(config_manager, mock_config_data):
    """DynamoDB設定の取得テスト"""
    with patch("builtins.open", mock_open(read_data=mock_config_data)):
        config_manager.load_config()
        dynamodb_config = config_manager.get_dynamodb_config()
        assert dynamodb_config["table_name"] == "price_comparison"
        assert dynamodb_config["region"] == "ap-northeast-1"

def test_get_urls_config(config_manager, mock_config_data):
    """URL設定の取得テスト"""
    with patch("builtins.open", mock_open(read_data=mock_config_data)):
        config_manager.load_config()
        urls_config = config_manager.get_urls_config()
        assert "kaitori_rudea" in urls_config
        assert "official" in urls_config
        assert len(urls_config["kaitori_rudea"]) == 2
        assert len(urls_config["official"]) == 2

def test_get_config_without_loading(config_manager):
    """設定を読み込まずに取得しようとした場合のテスト"""
    with pytest.raises(Exception):
        config_manager.get_scraper_config()

def test_custom_config_path():
    """カスタム設定ファイルパスのテスト"""
    custom_path = "/path/to/custom/config.yaml"
    manager = ConfigManager(config_path=custom_path)
    assert manager.config_path == custom_path
</file>

<file path="tests/unit/test_validators.py">
import pytest

from config import AppConfig, ScraperConfig
from config.manager import ConfigManager


class TestAppConfigValidation:
    def test_valid_app_config(self):
        """有効なアプリケーション設定のテスト"""
        config = AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="DEBUG"
        )
        assert config.DEBUG is True
        assert config.SECRET_KEY == "valid-secret-key-12345"
        assert config.LOG_LEVEL == "DEBUG"

    def test_invalid_secret_key(self):
        """無効なシークレットキーのテスト"""
        with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="short",
                LOG_LEVEL="DEBUG"
            )

    def test_invalid_log_level(self):
        """無効なログレベルのテスト"""
        with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
            AppConfig(
                DEBUG=True,
                SECRET_KEY="valid-secret-key-12345",
                LOG_LEVEL="INVALID"
            )

class TestScraperConfigValidation:
    def test_valid_scraper_config(self):
        """有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 1
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori"

    def test_invalid_url_format(self):
        """無効なURL形式のテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["invalid-url"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_invalid_timeout(self):
        """無効なタイムアウト値のテスト"""
        with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com"],
                APPLE_STORE_URL="https://example.com",
                REQUEST_TIMEOUT=0,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

    def test_valid_scraper_config_with_multiple_urls(self):
        """複数のURLを持つ有効なスクレイパー設定のテスト"""
        config = ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com/kaitori1", "https://example.com/kaitori2"],
            APPLE_STORE_URL="https://example.com/apple",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
        assert len(config.KAITORI_RUDEA_URLS) == 2
        assert config.KAITORI_RUDEA_URLS[0] == "https://example.com/kaitori1"
        assert config.KAITORI_RUDEA_URLS[1] == "https://example.com/kaitori2"

    def test_invalid_kaitori_rudea_urls(self):
        """無効なkaitori_rudea_urlsのテスト"""
        with pytest.raises(ValueError, match="Invalid URL format"):
            ScraperConfig(
                KAITORI_RUDEA_URLS=["https://example.com", "invalid-url"],
                APPLE_STORE_URL="https://example.com/apple",
                REQUEST_TIMEOUT=30,
                RETRY_COUNT=3,
                USER_AGENT="Test Agent"
            )

# 境界値テスト: REQUEST_TIMEOUT が 0 以下の場合はエラーを出す必要があります
def test_scraper_request_timeout_boundary():
    """REQUEST_TIMEOUT の境界値テスト"""
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=-1,  # 境界値（0 以下はエラー）
            RETRY_COUNT=1,
            USER_AGENT="Test Agent"
        )

# 無効な LOG_LEVEL を渡した場合のテスト
def test_app_log_level_invalid():
    """LOG_LEVEL が無効な場合のテスト"""
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        # LOG_LEVEL に無効な値 "INVALID" を指定し、エラーハンドリングを確認
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"  # 無効な LOG_LEVEL
        )

# SECRET_KEY が設定されていない場合、デフォルト値が使用されるかのテスト
def test_config_environment_with_missing_secret_key(monkeypatch):
    """SECRET_KEY が存在しない場合のテスト"""
    # SECRET_KEY を削除して、デフォルト値が設定されるか確認
    monkeypatch.delenv("SECRET_KEY", raising=False)
    config = ConfigManager()
    # デフォルトのシークレットキーが使用されるか確認
    assert config.app.SECRET_KEY == "default-secret-key"  # デフォルト値として設定されている

# FLASK_ENV が production の場合に正しく設定されるか確認
def test_config_environment_with_different_env(monkeypatch):
    """異なる FLASK_ENV のテスト"""
    # FLASK_ENV を production に設定
    monkeypatch.setenv("FLASK_ENV", "production")
    config = ConfigManager()
    # 環境が production になっているか確認
    assert config.env == "production"

# 無効な SECRET_KEY を渡した場合のエラーハンドリングテスト
def test_invalid_secret_key_length(monkeypatch):
    """SECRET_KEY が無効な場合のテスト"""
    monkeypatch.setenv("SECRET_KEY", "short")
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        config = ConfigManager()
        _ = config.app  # app プロパティにアクセスして初期化を強制

def test_config_manager_with_multiple_urls(monkeypatch, tmp_path):
    """複数のURLを持つConfigManagerのテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://test1.example.com/kaitori
        - https://test2.example.com/kaitori
      apple_store_url: https://test.example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 2
    assert "https://test1.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://test2.example.com/kaitori" in config.scraper.KAITORI_RUDEA_URLS

def test_scraper_config_with_iphone16_pro_url():
    """iPhone 16 Pro URLを含むスクレイパー設定のテスト"""
    config = ScraperConfig(
        KAITORI_RUDEA_URLS=[
            "https://kaitori-rudeya.com/category/detail/183",  # iPhone 16
            "https://kaitori-rudeya.com/category/detail/185",  # iPhone 16 Pro
            "https://kaitori-rudeya.com/category/detail/186"   # iPhone 16 Pro Max
            "https://kaitori-rudeya.com/category/detail/205"   # iPhone 16 e
        ],
        APPLE_STORE_URL="https://example.com/apple",
        REQUEST_TIMEOUT=30,
        RETRY_COUNT=3,
        USER_AGENT="Test Agent"
    )
    assert len(config.KAITORI_RUDEA_URLS) == 3
    assert "https://kaitori-rudeya.com/category/detail/185" in config.KAITORI_RUDEA_URLS

def test_config_manager_loads_iphone16_pro_url(mock_env_vars, tmp_path, monkeypatch):
    """ConfigManagerがiPhone 16 Pro URLを正しく読み込むかテスト"""
    config_content = """
    app:
      debug: true
      log_level: DEBUG
      secret_key: test-secret-key-16ch

    scraper:
      kaitori_rudea_urls:
        - https://kaitori-rudeya.com/category/detail/183
        - https://kaitori-rudeya.com/category/detail/185
        - https://kaitori-rudeya.com/category/detail/186
        - https://kaitori-rudeya.com/category/detail/205
      apple_store_url: https://example.com/apple
      request_timeout: 30
      retry_count: 3
      user_agent: "Test User Agent"
    """
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)

    monkeypatch.setenv("FLASK_ENV", "testing")
    config = ConfigManager(config_dir=tmp_path)

    assert len(config.scraper.KAITORI_RUDEA_URLS) == 4
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS
</file>

<file path="tests/__init__.py">
# This file makes the tests directory a Python package
</file>

<file path="tests/test_config_manager.py">
import shutil
import sys
from pathlib import Path

import pytest

# プロジェクトのルートディレクトリをPYTHONPATHに追加
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import pytest

from config import AppConfig, ConfigManager, ScraperConfig


@pytest.fixture(scope="function")
def test_config_file(tmp_path):
    config_content = """
app:
  debug: true
  log_level: "DEBUG"

scraper:
  kaitori_rudea_urls:
    - "https://kaitori-rudeya.com/category/detail/183"  # iPhone 16
    - "https://kaitori-rudeya.com/category/detail/185"  # iPhone 16 Pro
    - "https://kaitori-rudeya.com/category/detail/186"  # iPhone 16 Pro Max
    - "https://kaitori-rudeya.com/category/detail/205"  # iPhone 16 e
  apple_store_url: "https://example.com/apple"
  request_timeout: 30
  retry_count: 3
  user_agent: "Test User Agent"
"""
    config_file = tmp_path / "config.testing.yaml"
    config_file.write_text(config_content)
    
    # ConfigManagerが参照するディレクトリにファイルをコピー
    dest_dir = Path(__file__).parent.parent / "config"
    dest_file = dest_dir / "config.testing.yaml"
    shutil.copy(str(config_file), str(dest_file))
    
    yield dest_file
    
    # テスト後にファイルを削除
    dest_file.unlink()

def test_config_manager_initialization(mock_env_vars, test_config_file):
    """ConfigManagerの初期化テスト"""
    config = ConfigManager()
    assert config.env == "testing"
    assert isinstance(config.app, AppConfig)
    assert isinstance(config.scraper, ScraperConfig)

def test_app_config_validation():
    """AppConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="SECRET_KEY must be at least 16 characters"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="short",
            LOG_LEVEL="DEBUG"
        )
    
    with pytest.raises(ValueError, match="LOG_LEVEL must be one of"):
        AppConfig(
            DEBUG=True,
            SECRET_KEY="valid-secret-key-12345",
            LOG_LEVEL="INVALID"
        )

def test_scraper_config_validation():
    """ScraperConfigのバリデーションテスト"""
    with pytest.raises(ValueError, match="Invalid URL format"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["invalid-url"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=30,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )
    
    with pytest.raises(ValueError, match="REQUEST_TIMEOUT must be a positive integer"):
        ScraperConfig(
            KAITORI_RUDEA_URLS=["https://example.com"],
            APPLE_STORE_URL="https://example.com",
            REQUEST_TIMEOUT=0,
            RETRY_COUNT=3,
            USER_AGENT="Test Agent"
        )

def test_scraper_config_multiple_urls(mock_env_vars, test_config_file):
    """複数のkaitori_rudea_urlsを持つScraperConfigのテスト"""
    config = ConfigManager()
    assert isinstance(config.scraper.KAITORI_RUDEA_URLS, list)
    assert len(config.scraper.KAITORI_RUDEA_URLS) == 4
    assert "https://kaitori-rudeya.com/category/detail/183" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/185" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/186" in config.scraper.KAITORI_RUDEA_URLS
    assert "https://kaitori-rudeya.com/category/detail/205" in config.scraper.KAITORI_RUDEA_URLS
</file>

<file path="tests/test_scraper.py">
import json
import time
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from src.lambda_functions.get_prices_lambda.scraper import (CacheError,
                                                            HTTPError,
                                                            ParseError,
                                                            Scraper,
                                                            ScraperError,
                                                            ValidationError)


def test_scraper_initialization(mock_config):
    """Test scraper initialization with default configuration."""
    scraper = Scraper(mock_config)
    assert scraper.config == mock_config['scraper']
    assert scraper.selectors == mock_config['scraper']['selectors']
    assert scraper.headers == mock_config['scraper']['headers']
    assert scraper.max_retries == mock_config['scraper']['max_retries']
    assert scraper.timeout == mock_config['scraper']['timeout']
    assert scraper.cache_duration == mock_config['scraper']['cache_duration']

def test_scraper_initialization_with_config_file(test_config_file):
    """Test scraper initialization with configuration file."""
    scraper = Scraper(config_file=test_config_file)
    assert scraper.config_file == test_config_file
    assert scraper.selectors is not None
    assert scraper.headers is not None
    assert scraper.max_retries is not None
    assert scraper.timeout is not None
    assert scraper.cache_duration is not None

@patch('requests.get')
def test_scrape_url(mock_get, mock_response, mock_config, mock_cache_dir):
    """Test scraping a URL and extracting price data."""
    mock_get.return_value = mock_response
    scraper = Scraper(mock_config)
    scraper.cache_dir = mock_cache_dir

    url = "https://example.com"
    results = scraper.scrape_url(url)

    assert len(results) == 2
    assert results[0]['model'] == "iPhone 15 Pro 256GB"
    assert results[0]['price'] == 150000
    assert results[0]['condition'] == "新品"
    assert results[1]['model'] == "iPhone 15 Pro Max 512GB"
    assert results[1]['price'] == 180000
    assert results[1]['condition'] == "中古"

@patch('requests.get')
def test_scrape_url_cache(mock_get, mock_response, mock_config, mock_cache_dir):
    """Test caching functionality of the scraper."""
    mock_get.return_value = mock_response
    scraper = Scraper(mock_config)
    scraper.cache_dir = mock_cache_dir

    url = "https://example.com"
    
    # First request - should make HTTP call
    results1 = scraper.scrape_url(url)
    assert mock_get.call_count == 1
    
    # Second request - should use cache
    results2 = scraper.scrape_url(url)
    assert mock_get.call_count == 1  # No additional HTTP calls
    assert results1 == results2

@patch('requests.get')
def test_scrape_urls_parallel(mock_get, mock_response, mock_config):
    """Test parallel URL scraping."""
    mock_get.return_value = mock_response
    scraper = Scraper(config=mock_config)
    urls = ['https://example.com/1', 'https://example.com/2']
    results = scraper.scrape_urls(urls)
    assert len(results) == 2
    assert all(len(result) == 2 for result in results.values())

@patch('requests.get')
def test_scrape_url_http_error(mock_get, mock_config):
    """Test handling of HTTP errors during scraping."""
    mock_get.side_effect = HTTPError("Failed to fetch URL")
    scraper = Scraper(mock_config)

    with pytest.raises(HTTPError):
        scraper.scrape_url("https://example.com")

@patch('requests.get')
def test_scrape_url_parse_error(mock_get, mock_config):
    """Test handling of parsing errors during scraping."""
    mock_response = MagicMock()
    mock_response.text = "<invalid>html"
    mock_get.return_value = mock_response
    scraper = Scraper(mock_config)

    with pytest.raises(ParseError):
        scraper.scrape_url("https://example.com")

@patch('requests.get')
def test_scrape_url_validation_error(mock_get, mock_config):
    """Test handling of validation errors during scraping."""
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">Invalid Model</div>
        <div class="price">invalid_price</div>
        <div class="condition">新品</div>
    </div>
    """
    mock_get.return_value = mock_response
    scraper = Scraper(mock_config)

    with pytest.raises(ValidationError):
        scraper.scrape_url("https://example.com")

def test_scrape_url_cache_error(mock_config, mock_cache_dir):
    """Test handling of cache errors during scraping."""
    scraper = Scraper(mock_config)
    scraper.cache_dir = mock_cache_dir / "nonexistent"  # Invalid cache directory

    with pytest.raises(CacheError):
        scraper.scrape_url("https://example.com")

def test_performance_metrics(mock_config):
    """Test performance metrics collection."""
    scraper = Scraper(mock_config)
    metrics = scraper.get_performance_metrics()

    assert isinstance(metrics, dict)
    assert 'total_requests' in metrics
    assert 'cache_hits' in metrics
    assert 'cache_misses' in metrics
    assert 'average_response_time' in metrics
    assert all(isinstance(v, (int, float)) for v in metrics.values())

def test_retry_logic(mock_config):
    """Test retry logic for failed requests."""
    mock_response = MagicMock()
    mock_response.raise_for_status.side_effect = [
        HTTPError('500 Internal Server Error'),
        HTTPError('500 Internal Server Error'),
        mock_response
    ]
    with patch('requests.get', return_value=mock_response):
        scraper = Scraper(config=mock_config)
        with pytest.raises(HTTPError):
            scraper.scrape_url('https://example.com')
        assert mock_response.raise_for_status.call_count == 3
</file>

<file path=".bandit">
{
  "exclude_dirs": [
    "tests",
    "venv",
    ".venv",
    ".git",
    ".github"
  ],
  "skips": [
    "B101"
  ],
  "targets": [
    "src"
  ],
  "output_format": "json",
  "output_file": "bandit-results.json"
}
</file>

<file path=".dockerignore">
# Git
.git
.gitignore

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Docker
Dockerfile
.dockerignore

# Terraform
.terraform/
*.tfstate
*.tfstate.*
*.tfvars
.terraform.lock.hcl

# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test
.coverage
coverage.xml
.pytest_cache/

# Logs
*.log

# Local development
local_config.yaml
config.development.yaml

# Lambda zip files
*.zip
</file>

<file path=".python-version">
3.13.3
</file>

<file path="bandit-results.json">
{
  "errors": [],
  "generated_at": "2025-04-28T13:00:08Z",
  "metrics": {
    "_totals": {
      "CONFIDENCE.HIGH": 0,
      "CONFIDENCE.LOW": 0,
      "CONFIDENCE.MEDIUM": 0,
      "CONFIDENCE.UNDEFINED": 0,
      "SEVERITY.HIGH": 0,
      "SEVERITY.LOW": 0,
      "SEVERITY.MEDIUM": 0,
      "SEVERITY.UNDEFINED": 0,
      "loc": 1017,
      "nosec": 0,
      "skipped_tests": 0
    },
    "src/apple_scraper_for_rudea.py": {
      "CONFIDENCE.HIGH": 0,
      "CONFIDENCE.LOW": 0,
      "CONFIDENCE.MEDIUM": 0,
      "CONFIDENCE.UNDEFINED": 0,
      "SEVERITY.HIGH": 0,
      "SEVERITY.LOW": 0,
      "SEVERITY.MEDIUM": 0,
      "SEVERITY.UNDEFINED": 0,
      "loc": 188,
      "nosec": 0,
      "skipped_tests": 0
    },
    "src/lambda_functions/get_prices_lambda/config/__init__.py": {
      "CONFIDENCE.HIGH": 0,
      "CONFIDENCE.LOW": 0,
      "CONFIDENCE.MEDIUM": 0,
      "CONFIDENCE.UNDEFINED": 0,
      "SEVERITY.HIGH": 0,
      "SEVERITY.LOW": 0,
      "SEVERITY.MEDIUM": 0,
      "SEVERITY.UNDEFINED": 0,
      "loc": 3,
      "nosec": 0,
      "skipped_tests": 0
    },
    "src/lambda_functions/get_prices_lambda/config/manager.py": {
      "CONFIDENCE.HIGH": 0,
      "CONFIDENCE.LOW": 0,
      "CONFIDENCE.MEDIUM": 0,
      "CONFIDENCE.UNDEFINED": 0,
      "SEVERITY.HIGH": 0,
      "SEVERITY.LOW": 0,
      "SEVERITY.MEDIUM": 0,
      "SEVERITY.UNDEFINED": 0,
      "loc": 54,
      "nosec": 0,
      "skipped_tests": 0
    },
    "src/lambda_functions/get_prices_lambda/scraper.py": {
      "CONFIDENCE.HIGH": 0,
      "CONFIDENCE.LOW": 0,
      "CONFIDENCE.MEDIUM": 0,
      "CONFIDENCE.UNDEFINED": 0,
      "SEVERITY.HIGH": 0,
      "SEVERITY.LOW": 0,
      "SEVERITY.MEDIUM": 0,
      "SEVERITY.UNDEFINED": 0,
      "loc": 772,
      "nosec": 0,
      "skipped_tests": 0
    }
  },
  "results": []
}
</file>

<file path="README.md">
# **`priceComparisonAppForIphone`リポジトリについて**

# Claude や ChatGPT にリポジトリを丸ごと読み込ませるコマンド

以下のコマンドを実行することでリポジトリ一式をテキストファイル（`repomix-output.txt`, 旧：`repopack-output.txt`）を出力することができます。

```
npx repomix
// 2024/12/20 `repopack`からupgrade
```

chat へ最初に取り込ませることでコード修正に役立ちます。

### 読み込ませるポイント

ファイルと合わせて以下のプロンプトで始めるとスムーズに改修を始めやすい

```
このファイルはリポジトリのファイルを1つにしたものです。コードのリファクタなどをしたいのでまず添付のコードを確認してください。
```

# About setting to "Renovate"

## 説明:

- extends: ["config:base"]: デフォルト設定に基づきます。
- labels: ["dependencies"]: すべての PR に "dependencies" ラベルが付与されます。
- packageRules:
  - minor と patch の自動マージ: 自動的に PR がマージされます（automergeType: "pr"）。
  - 大規模なマイナー変更（特定のパッケージ）やメジャーアップデートは自動マージされません\*\*。
- prConcurrentLimit: 一度に開かれる PR の上限(number)。

この設定で、メジャーアップデートと大規模なマイナー変更は手動でマージすることができ、それ以外の更新は自動的にマージされます。

# `AWS`の設定について

## credentials について

以下`~/.aws/credentials`のサンプルになります(2024/12/20 時点のもの。セキュリティ面から 2,3 週間ごとに変更予定のため流用はほぼ不可)

```
[default]
aws_access_key_id = ********************
aws_secret_access_key = ****************************************
# 格納方法は別途検討中
```

※ MFA を有効にする場合、`aws cli`は追加対応が必要になるため注意が必要（AI に聞くなり「aws-cli mfa」などで調べてください。大体は「一時的なアクセス情報を発行する」や`aws sts`コマンドに行き着くかと思います）

※ `aws configure` は `--profile`オプションを追加して名前つきのプロファイルを設定することができます（上記同様 AI に聞くなりして調べてください）

## config について

以下`~/.aws/config`のサンプルになります。こちらは管理者が日本以外に帰化しない限りは以下のままかと思います。

```
[default]
region = ap-northeast-1
output = json
# outputについて、`yaml`等が良ければ必要に応じて変更してください
```

## DynamoDB create command

上記`aws configure`の設定は前提

```
aws dynamodb create-table \
  --table-name official_prices \
  --attribute-definitions \
      AttributeName=series,AttributeType=S \
      AttributeName=capacity,AttributeType=S \
  --key-schema \
      AttributeName=series,KeyType=HASH \
      AttributeName=capacity,KeyType=RANGE \
  --billing-mode PAY_PER_REQUEST
```

実際に保存したい情報（`2024/12/20`時点のもの）は`data/official_prices.json`に残っていたりもする（以前は`json`ファイルから描写していた名残）

## ディレクトリ構成について（`2024/12/20`時点）

```
priceComparisonAppForIphone/
│
├── scripts/  # スクリプト関連
│   ├── migrate_to_dynamodb.py  # データ移行用
│
├── services/  # AWSサービスごとの処理
│   ├── dynamodb_service.py  # DynamoDB操作
│   ├── lambda_handler.py  # Lambda関数のエントリーポイント
│
├── templates/  # HTMLテンプレート
│   ├── index.html  # フロントエンド
│
├── app.py  # Flaskサーバー
├── requirements.txt
└── README.md
```

# ローカル環境での実行手順

1. まず、必要な環境変数を設定します。`.env.example`をコピーして`.env`ファイルを作成：

```bash
cp .env.example .env
```

2. 必要な Python パッケージをインストール：

```bash
pip install -r requirements.txt
```

3. Playwright のブラウザをインストール：

```bash
playwright install chromium
```

4. アプリケーションの実行：

開発モード（デバッグ有効）での実行：

```bash
python app.py
```

または、本番モードでの実行（Gunicorn を使用）：

```bash
gunicorn app:app --bind 0.0.0.0:5000 --workers=3 --timeout=60
```

Docker を使用する場合：

```bash
# イメージのビルド
docker build -t price-comparison-app:latest .

# コンテナの実行
docker run -p 5000:5000 price-comparison-app:latest
```

アプリケーションが起動したら、ブラウザで以下の URL にアクセスできます：

```
http://localhost:5000
```

注意点：

- AWS 関連の機能を使用する場合は、AWS 認証情報の設定が必要です
- DynamoDB を使用する場合は、`~/.aws/credentials`の設定が必要です
- 開発環境では`config/config.development.yaml`の設定が使用されます

エラーが発生した場合は、ログを確認することで詳細な情報を得ることができます。

# 仮想環境の作成

venv モジュールを使用して仮想環境を作成します。以下のコマンドを実行します。

```
python -m venv venv
```

これにより、venv という名前の仮想環境が作成されます。後半の'venv'の部分は任意の名前に変更できます。

# 仮想環境の有効化

仮想環境を作成したら、その環境を有効化します。OS によってコマンドが異なります。

### Windows の場合

```
venv\Scripts\activate
```

### macOS/Linux の場合

```
source venv/bin/activate
```

仮想環境が有効化されると、ターミナルのプロンプトが以下のように変わります。

```
(venv) $
```

# iPhone Price Comparison App

iPhone の価格比較を行うためのアプリケーションのバックエンドサービスです。

## 機能

- iPhone の公式価格情報の取得
- 買取価格の取得と履歴の保存
- RESTful API による価格情報の提供

## アーキテクチャ

### インフラストラクチャ

- AWS Lambda: 価格取得と保存の処理
- API Gateway: RESTful API の提供
- DynamoDB: 価格データの保存
- IAM: アクセス制御

### データ構造

価格データは以下の構造で保存されます：

```json
{
  "products": [
    {
      "model": "iPhone 16",
      "capacity": "128GB",
      "color": "black",
      "color_ja": "黒",
      "model_number": "MYDQ3J/A",
      "condition": "未開封",
      "carrier": "SIMフリー",
      "price": 124800
    }
  ]
}
```

## セットアップ

### 前提条件

- Python 3.9 以上
- Terraform 1.5.0 以上
- AWS CLI
- GitHub Actions の設定

### 環境変数

以下の環境変数を設定する必要があります：

```bash
AWS_REGION=ap-northeast-1
AWS_ACCESS_KEY_ID=your_access_key
AWS_SECRET_ACCESS_KEY=your_secret_key
AWS_ROLE_ARN=your_role_arn
```

### デプロイメント

1. リポジトリをクローン
2. 依存関係のインストール
   ```bash
   cd terraform
   pip install -r requirements.txt
   ```
3. Terraform の初期化
   ```bash
   terraform init
   ```
4. インフラストラクチャのデプロイ
   ```bash
   terraform apply
   ```

## API エンドポイント

### 価格情報の取得

```
GET /get_prices?series={series}
```

パラメータ:

- `series`: iPhone のシリーズ名（例: "iPhone 16"）

レスポンス:

```json
{
  "data": {
    "official": {
      "128GB": 124800,
      "256GB": 139800,
      "512GB": 169800
    },
    "kaitori": {
      "128GB": 110000,
      "256GB": 125000,
      "512GB": 155000
    }
  }
}
```

## セキュリティ

- IAM ロールは最小権限の原則に基づいて設定
- API Gateway は IAM 認証を必須
- アクセスログは CloudWatch Logs に保存（30 日間保持）

## メンテナンス

### 価格データの更新

1. `data/official_prices.json`を編集
2. 変更をコミットしてプッシュ
3. GitHub Actions が自動的にデプロイ

### モニタリング

- CloudWatch Logs で API アクセスを監視
- Lambda 関数の実行ログを確認

## ライセンス

MIT License
</file>

<file path="requirements-base.txt">
urllib3>=2.0.5,<3.0
requests>=2.32.3,<3.0
boto3>=1.34.0
python-dotenv==1.1.0
</file>

<file path="requirements-test.txt">
pytest==7.4.4
pytest-cov==6.1.1
pytest-mock==3.14.0
</file>

<file path="requirements-web.txt">
selenium>=4.16.0,<5.0
playwright==1.52.0
beautifulsoup4==4.13.4
flask==3.1.0
gunicorn==23.0.0
</file>

<file path="data/official_prices.json">
{
  "iPhone 16": {
    "128GB": {
      "colors": {
        "Black": 124800,
        "White": 124800,
        "Blue": 124800,
        "Green": 124800
      }
    },
    "256GB": {
      "colors": {
        "Black": 139800,
        "White": 139800,
        "Blue": 139800,
        "Green": 139800
      }
    },
    "512GB": {
      "colors": {
        "Black": 169800,
        "White": 169800,
        "Blue": 169800,
        "Green": 169800
      }
    }
  },
  "iPhone 16 Plus": {
    "128GB": {
      "colors": {
        "Black": 139800,
        "White": 139800,
        "Blue": 139800,
        "Green": 139800
      }
    },
    "256GB": {
      "colors": {
        "Black": 154800,
        "White": 154800,
        "Blue": 154800,
        "Green": 154800
      }
    },
    "512GB": {
      "colors": {
        "Black": 184800,
        "White": 184800,
        "Blue": 184800,
        "Green": 184800
      }
    }
  },
  "iPhone 16 Pro": {
    "128GB": {
      "colors": {
        "Natural Titanium": 159800,
        "Blue Titanium": 159800,
        "White Titanium": 159800,
        "Black Titanium": 159800
      }
    },
    "256GB": {
      "colors": {
        "Natural Titanium": 174800,
        "Blue Titanium": 174800,
        "White Titanium": 174800,
        "Black Titanium": 174800
      }
    },
    "512GB": {
      "colors": {
        "Natural Titanium": 204800,
        "Blue Titanium": 204800,
        "White Titanium": 204800,
        "Black Titanium": 204800
      }
    },
    "1TB": {
      "colors": {
        "Natural Titanium": 234800,
        "Blue Titanium": 234800,
        "White Titanium": 234800,
        "Black Titanium": 234800
      }
    }
  },
  "iPhone 16 Pro Max": {
    "256GB": {
      "colors": {
        "Natural Titanium": 189800,
        "Blue Titanium": 189800,
        "White Titanium": 189800,
        "Black Titanium": 189800
      }
    },
    "512GB": {
      "colors": {
        "Natural Titanium": 219800,
        "Blue Titanium": 219800,
        "White Titanium": 219800,
        "Black Titanium": 219800
      }
    },
    "1TB": {
      "colors": {
        "Natural Titanium": 249800,
        "Blue Titanium": 249800,
        "White Titanium": 249800,
        "Black Titanium": 249800
      }
    }
  },
  "iPhone 16 e": {
    "128GB": {
      "colors": {
        "Black": 99800,
        "White": 99800
      }
    },
    "256GB": {
      "colors": {
        "Black": 114800,
        "White": 114800
      }
    },
    "512GB": {
      "colors": {
        "Black": 144800,
        "White": 144800
      }
    }
  }
}
</file>

<file path="lambdas/get_price_history_lambda/get_price_history.py">
import json
from datetime import datetime, timedelta

import boto3
from boto3.dynamodb.conditions import Key

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('price_history')

def lambda_handler(event, context):
    try:
        # Get query parameters
        query_params = event.get('queryStringParameters', {})
        model = query_params.get('model')
        if not model:
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Credentials': True
                },
                'body': json.dumps('Missing required parameter: model')
            }
        
        # Calculate date range (2 weeks before and after)
        today = datetime.now()
        start_date = (today - timedelta(days=14)).strftime('%Y-%m-%d')
        end_date = (today + timedelta(days=14)).strftime('%Y-%m-%d')
        
        # Query DynamoDB using DateIndex
        response = table.query(
            IndexName='DateIndex',
            KeyConditionExpression=Key('date').between(start_date, end_date) & Key('model').eq(model)
        )
        
        # Format response data
        items = response.get('Items', [])
        formatted_data = []
        
        for item in items:
            formatted_data.append({
                'timestamp': item['timestamp'],
                'price': item['price']
            })
        
        # Sort by timestamp
        formatted_data.sort(key=lambda x: x['timestamp'])
        
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Credentials': True
            },
            'body': json.dumps(formatted_data)
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Credentials': True
            },
            'body': json.dumps(f'Error retrieving price history: {str(e)}')
        }
</file>

<file path="lambdas/get_prices_lambda/lambda_function.py">
import json
import logging
import os
from datetime import datetime, timezone

import boto3
from botocore.exceptions import ClientError

# ロガーの設定
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# DynamoDBクライアントの初期化
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])

def lambda_handler(event, context):
    """
    Lambda関数のメインハンドラー
    """
    try:
        logger.info("Starting price retrieval process")
        
        # クエリパラメータからシリーズを取得
        series = event.get('queryStringParameters', {}).get('series', 'iPhone 16')
        capacity = event.get('queryStringParameters', {}).get('capacity', '128GB')
        
        # 価格情報を取得
        prices = get_prices(series, capacity)
        
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                'Access-Control-Allow-Methods': 'GET,OPTIONS'
            },
            'body': json.dumps(prices)
        }
        
    except Exception as e:
        logger.error(f"Error in lambda_handler: {str(e)}")
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                'Access-Control-Allow-Methods': 'GET,OPTIONS'
            },
            'body': json.dumps({'error': str(e)})
        }

def get_prices(series, capacity):
    """
    指定されたシリーズと容量の価格情報を取得
    """
    try:
        response = table.scan(
            FilterExpression='#s = :series AND #c = :capacity',
            ExpressionAttributeNames={
                '#s': 'series',
                '#c': 'capacity'
            },
            ExpressionAttributeValues={
                ':series': series,
                ':capacity': capacity
            }
        )
        
        if not response['Items']:
            return {
                'series': series,
                'capacity': capacity,
                'prices': [],
                'message': 'No prices found for this series and capacity'
            }
        
        # レスポンスを整形
        items = []
        for item in response['Items']:
            formatted_item = {
                'series': item['series'],
                'capacity': item['capacity'],
                'price': item['price'],
                'store': item['store'],
                'updated_at': item.get('updated_at', '')
            }
            items.append(formatted_item)
        
        return {
            'series': series,
            'capacity': capacity,
            'prices': items,
            'message': 'Successfully retrieved prices'
        }
        
    except ClientError as e:
        logger.error(f"Error getting prices: {str(e)}")
        raise
</file>

<file path="lambdas/save_price_history_lambda/save_price_history.py">
import json
import time
from datetime import datetime, timedelta

import boto3

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('price_history')

def lambda_handler(event, context):
    try:
        # Log the incoming event
        print(f"Processing event: {json.dumps(event)}")
        
        # Get current timestamp
        current_timestamp = int(time.time())
        current_date = datetime.now().strftime('%Y-%m-%d')
        
        # Calculate expiration time (1 month from now)
        expiration_time = int((datetime.now() + timedelta(days=30)).timestamp())
        
        # Get price data from event
        price_data = event.get('price_data', {})
        
        # Validate price data
        if not price_data:
            print("Warning: No price data found in event")
            return {
                'statusCode': 400,
                'body': json.dumps('No price data provided')
            }
        
        # Save each model's price data
        items_processed = 0
        for model, capacities in price_data.items():
            for capacity, colors in capacities.items():
                for color, price in colors.items():
                    # Validate price
                    try:
                        price = int(price) if isinstance(price, str) else price
                    except ValueError:
                        print(f"Warning: Invalid price value for {model}-{capacity}-{color}: {price}")
                        continue
                        
                    item = {
                        'model': f"{model}-{capacity}-{color}",
                        'timestamp': current_timestamp,
                        'date': current_date,
                        'price': price,
                        'expiration_time': expiration_time
                    }
                    
                    table.put_item(Item=item)
                    items_processed += 1
        
        print(f"Successfully processed {items_processed} price items")
        
        return {
            'statusCode': 200,
            'body': json.dumps(f'Price history saved successfully: {items_processed} items processed')
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps(f'Error saving price history: {str(e)}')
        }
</file>

<file path="scripts/load_dynamodb_data.py">
#!/usr/bin/env python3

import json
import logging
import os
from datetime import datetime
from pathlib import Path

import boto3

# ロギングの設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_json_file(file_path):
    """JSONファイルを読み込む"""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading {file_path}: {str(e)}")
        raise

def write_to_official_prices(table, data):
    """公式価格データをDynamoDBに書き込む"""
    try:
        # 既存のデータを削除
        scan = table.scan()
        with table.batch_writer() as batch:
            for item in scan['Items']:
                batch.delete_item(
                    Key={
                        'series': item['series'],
                        'capacity': item['capacity']
                    }
                )
        
        # 新しいデータを書き込む
        for series, capacities in data.items():
            for capacity, details in capacities.items():
                item = {
                    'series': series,
                    'capacity': capacity,
                    'colors': details['colors'],
                    'timestamp': datetime.now().isoformat()
                }
                table.put_item(Item=item)
                logger.info(f"Added {series} {capacity} to official_prices")
    except Exception as e:
        logger.error(f"Error writing to official_prices: {str(e)}")
        raise

def write_to_price_history(table, data):
    """買取価格の履歴データをDynamoDBに書き込む"""
    try:
        for model, model_data in data.items():
            for price_data in model_data['prices']:
                # kaitoriの価格のみを保存
                if price_data['source'] == 'kaitori':
                    item = {
                        'model': model,
                        'timestamp': price_data['timestamp'],
                        'price': price_data['price'],
                        'source': price_data['source']
                    }
                    table.put_item(Item=item)
                    logger.info(f"Added kaitori price history for {model}")
    except Exception as e:
        logger.error(f"Error writing to price_history: {str(e)}")
        raise

def write_to_price_predictions(table, data):
    """価格予測データをDynamoDBに書き込む"""
    try:
        for series, series_data in data.items():
            for prediction in series_data['predictions']:
                item = {
                    'series': series,
                    'timestamp': prediction['timestamp'],
                    'predicted_price': prediction['predicted_price'],
                    'confidence': prediction['confidence'],
                    'factors': prediction['factors']
                }
                table.put_item(Item=item)
                logger.info(f"Added price prediction for {series}")
    except Exception as e:
        logger.error(f"Error writing to price_predictions: {str(e)}")
        raise

def main():
    try:
        # プロジェクトのルートディレクトリを取得
        project_root = Path(__file__).parent.parent
        data_dir = project_root / 'data'
        
        # データディレクトリの存在確認
        if not data_dir.exists():
            raise FileNotFoundError(f"Data directory not found: {data_dir}")
        
        # DynamoDBクライアントの初期化
        dynamodb = boto3.resource('dynamodb')
        
        # 各テーブルの取得
        official_prices_table = dynamodb.Table('official_prices')
        price_history_table = dynamodb.Table('price_history')
        price_predictions_table = dynamodb.Table('price_predictions')
        
        # データの読み込み
        logger.info("Loading data files...")
        official_prices = load_json_file(data_dir / 'official_prices.json')
        price_history = load_json_file(data_dir / 'price_history.json')
        price_predictions = load_json_file(data_dir / 'price_predictions.json')
        
        # データの書き込み
        logger.info("Writing data to DynamoDB...")
        write_to_official_prices(official_prices_table, official_prices)
        write_to_price_history(price_history_table, price_history)
        write_to_price_predictions(price_predictions_table, price_predictions)
        
        logger.info("Data loading completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main process: {str(e)}")
        raise

if __name__ == "__main__":
    main()
</file>

<file path="src/lambda_functions/get_prices_lambda/config/manager.py">
import os
from pathlib import Path
from typing import Any, Dict, Optional

import yaml


class ConfigManager:
    """Configuration manager for the application."""

    def __init__(self, config_path: Optional[str] = None):
        """Initialize the configuration manager.

        Args:
            config_path: Optional path to the configuration file.
                        If not provided, uses default path.
        """
        self.config = None
        self.config_path = config_path or os.path.join(
            os.path.dirname(os.path.dirname(__file__)),
            "config",
            "config.yaml"
        )

    def load_config(self) -> None:
        """Load the configuration from the YAML file."""
        if not os.path.exists(self.config_path):
            raise FileNotFoundError(f"Configuration file not found: {self.config_path}")

        with open(self.config_path, "r", encoding="utf-8") as f:
            self.config = yaml.safe_load(f)

    def get_scraper_config(self) -> Dict[str, Any]:
        """Get the scraper configuration.

        Returns:
            Dict containing scraper configuration.

        Raises:
            Exception: If configuration is not loaded.
        """
        if not self.config:
            raise Exception("Configuration not loaded")
        return self.config.get("scraper", {})

    def get_dynamodb_config(self) -> Dict[str, Any]:
        """Get the DynamoDB configuration.

        Returns:
            Dict containing DynamoDB configuration.

        Raises:
            Exception: If configuration is not loaded.
        """
        if not self.config:
            raise Exception("Configuration not loaded")
        return self.config.get("dynamodb", {})

    def get_urls_config(self) -> Dict[str, Any]:
        """Get the URLs configuration.

        Returns:
            Dict containing URLs configuration.

        Raises:
            Exception: If configuration is not loaded.
        """
        if not self.config:
            raise Exception("Configuration not loaded")
        return self.config.get("urls", {})
</file>

<file path="terraform/scripts/load_dynamodb_data.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、Terraformのデプロイメント時にDynamoDBテーブルに初期データを投入するために使用されます。
以下のコマンドで実行します：
    python3 load_dynamodb_data.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

投入されるデータ:
- official_prices.json: 公式価格データ
- price_history.json: 価格履歴データ
- price_predictions.json: 価格予測データ
- kaitori-rudea_sample-prices.json: 買取価格データ
"""

import json
import logging
import os
from datetime import datetime
from decimal import Decimal
from pathlib import Path

import boto3

# ロギングの設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_json_file(file_path):
    """JSONファイルを読み込む"""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading {file_path}: {str(e)}")
        raise

def write_to_official_prices(table, data):
    """公式価格データをDynamoDBに書き込む"""
    try:
        for series, capacities in data.items():
            for capacity, details in capacities.items():
                item = {
                    'series': series,
                    'capacity': capacity,
                    'colors': details['colors'],
                    'timestamp': datetime.now().isoformat()
                }
                table.put_item(Item=item)
                logger.info(f"Added {series} {capacity} to official_prices")
    except Exception as e:
        logger.error(f"Error writing to official_prices: {str(e)}")
        raise

def write_to_price_history(table, data):
    """価格履歴データをDynamoDBに書き込む"""
    try:
        for model, model_data in data.items():
            for price_data in model_data['prices']:
                item = {
                    'model': model,
                    'timestamp': int(price_data['timestamp']),
                    'price': price_data['price'],
                    'source': price_data['source']
                }
                table.put_item(Item=item)
                logger.info(f"Added price history for {model}")
    except Exception as e:
        logger.error(f"Error writing to price_history: {str(e)}")
        raise

def write_to_price_predictions(table, data):
    """価格予測データをDynamoDBに書き込む"""
    try:
        for series, series_data in data.items():
            for prediction in series_data['predictions']:
                item = {
                    'series': series,
                    'timestamp': str(prediction['timestamp']),
                    'predicted_price': int(prediction['predicted_price']),
                    'confidence': Decimal(str(prediction['confidence'])),
                    'factors': prediction['factors']
                }
                table.put_item(Item=item)
                logger.info(f"Added price prediction for {series}")
    except Exception as e:
        logger.error(f"Error writing to price_predictions: {str(e)}")
        raise

def write_to_kaitori_prices(table, data):
    """買取価格データをDynamoDBに書き込む"""
    try:
        for model, capacities in data.items():
            for capacity, details in capacities.items():
                for color, price in details['colors'].items():
                    item = {
                        'model': model,
                        'capacity': capacity,
                        'color': color,
                        'price': price,
                        'source': details['source'],
                        'timestamp': datetime.now().isoformat()
                    }
                    table.put_item(Item=item)
                    logger.info(f"Added kaitori price for {model} {capacity} {color}")
    except Exception as e:
        logger.error(f"Error writing to kaitori_prices: {str(e)}")
        raise

def main():
    try:
        # データディレクトリのパスを設定
        data_dir = Path(__file__).parent.parent.parent / 'data'
        
        # DynamoDBクライアントの初期化
        dynamodb = boto3.resource('dynamodb')
        
        # 各テーブルの取得
        official_prices_table = dynamodb.Table('official_prices')
        price_history_table = dynamodb.Table('price_history')
        price_predictions_table = dynamodb.Table('price_predictions')
        kaitori_prices_table = dynamodb.Table('kaitori_prices')
        
        # データの読み込み
        logger.info("Loading data files...")
        official_prices = load_json_file(data_dir / 'official_prices.json')
        price_history = load_json_file(data_dir / 'price_history.json')
        price_predictions = load_json_file(data_dir / 'price_predictions.json')
        kaitori_prices = load_json_file(data_dir / 'kaitori-rudea_sample-prices.json')
        
        # データの書き込み
        logger.info("Writing data to DynamoDB...")
        write_to_official_prices(official_prices_table, official_prices)
        write_to_price_history(price_history_table, price_history)
        write_to_price_predictions(price_predictions_table, price_predictions)
        write_to_kaitori_prices(kaitori_prices_table, kaitori_prices)
        
        logger.info("Data loading completed successfully!")
        
    except Exception as e:
        logger.error(f"Error in main process: {str(e)}")
        raise

if __name__ == "__main__":
    main()
</file>

<file path="terraform/scripts/package_lambda.py">
#!/usr/bin/env python3

"""
使用方法:
このスクリプトは、Lambda関数のパッケージングとデプロイに使用されます。
以下のコマンドで実行します：
    python3 package_lambda.py

必要な環境変数:
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- AWS_DEFAULT_REGION

パッケージングされるLambda関数:
- deployment-verification: デプロイメント検証用
- smoke-test: スモークテスト用

各Lambda関数は以下の手順でパッケージングされます：
1. 依存関係のインストール
2. ZIPファイルの作成
3. Lambda関数のデプロイ
"""

import logging
import os
import shutil
import subprocess
import sys
import zipfile

import boto3

# ロギングの設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def install_dependencies(requirements_file, target_dir):
    """依存関係をインストール"""
    try:
        logger.info(f"Installing dependencies from {requirements_file}...")
        subprocess.run([
            sys.executable, "-m", "pip", "install",
            "-r", requirements_file,
            "--target", target_dir
        ], check=True)
        logger.info("Dependencies installed successfully")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to install dependencies: {e}")
        raise
    except Exception as e:
        logger.error(f"Error installing dependencies: {e}")
        raise

def create_zip_file(source_dir, output_file):
    """ZIPファイルを作成"""
    try:
        logger.info(f"Creating ZIP file {output_file}...")
        with zipfile.ZipFile(output_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(source_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, source_dir)
                    zipf.write(file_path, arcname)
        logger.info(f"ZIP file created successfully: {output_file}")
        return output_file
    except Exception as e:
        logger.error(f"Error creating ZIP file: {e}")
        raise

def deploy_lambda_function(function_name, zip_file):
    """Lambda関数をデプロイ"""
    try:
        logger.info(f"Deploying Lambda function {function_name}...")
        lambda_client = boto3.client('lambda')
        
        with open(zip_file, 'rb') as f:
            zip_content = f.read()
        
        response = lambda_client.update_function_code(
            FunctionName=function_name,
            ZipFile=zip_content
        )
        
        logger.info(f"Successfully deployed Lambda function {function_name}")
        return response
    except Exception as e:
        logger.error(f"Error deploying Lambda function {function_name}: {e}")
        raise

def package_and_deploy_lambda(script_name, requirements_file):
    """Lambda関数をパッケージ化してデプロイ"""
    # スクリプトのディレクトリを取得
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 一時ディレクトリの作成
    temp_dir = os.path.join(script_dir, f"temp_{script_name}")
    os.makedirs(temp_dir, exist_ok=True)

    try:
        # スクリプトをコピー
        script_path = os.path.join(script_dir, f"{script_name}.py")
        if not os.path.exists(script_path):
            raise FileNotFoundError(f"Script file not found: {script_path}")
        
        shutil.copy2(script_path, os.path.join(temp_dir, f"{script_name}.py"))
        logger.info(f"Copied script file: {script_path}")

        # 依存関係をインストール
        install_dependencies(requirements_file, temp_dir)

        # ZIPファイルを作成
        output_file = os.path.join(script_dir, f"{script_name}.zip")
        zip_path = create_zip_file(temp_dir, output_file)

        if not os.path.exists(zip_path):
            raise FileNotFoundError(f"ZIP file not created: {zip_path}")

        # Lambda関数をデプロイ
        deploy_lambda_function(script_name, zip_path)

        logger.info(f"Successfully packaged and deployed {script_name}.py")
        return zip_path

    except Exception as e:
        logger.error(f"Error packaging and deploying Lambda function {script_name}: {e}")
        raise
    finally:
        # 一時ディレクトリを削除
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
            logger.info(f"Cleaned up temporary directory: {temp_dir}")

def main():
    """メイン関数"""
    try:
        # スクリプトのディレクトリを取得
        script_dir = os.path.dirname(os.path.abspath(__file__))
        
        # requirements.txtのパスを設定
        requirements_path = os.path.join(script_dir, "requirements.txt")
        if not os.path.exists(requirements_path):
            raise FileNotFoundError(f"Requirements file not found: {requirements_path}")
        
        # デプロイメント検証用のLambda関数をパッケージ化してデプロイ
        package_and_deploy_lambda("deployment-verification", requirements_path)
        
        # スモークテスト用のLambda関数をパッケージ化してデプロイ
        package_and_deploy_lambda("smoke-test", requirements_path)
        
        logger.info("All Lambda functions packaged and deployed successfully")

    except Exception as e:
        logger.error(f"Error in main function: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="terraform/backup.tf">
# DynamoDBのバックアップ設定
resource "aws_backup_plan" "dynamodb_backup" {
  name = "dynamodb-backup-plan"

  rule {
    rule_name         = "daily-backup"
    target_vault_name = aws_backup_vault.dynamodb_backup.name
    schedule          = "cron(0 3 ? * * *)" # 毎日午前3時

    lifecycle {
      delete_after = 30 # 30日間保持
    }
  }
}

# バックアップボールト
resource "aws_backup_vault" "dynamodb_backup" {
  name        = "dynamodb-backup-vault"
  kms_key_arn = aws_kms_key.backup.arn
}

# バックアップ用KMSキー
resource "aws_kms_key" "backup" {
  description             = "KMS key for DynamoDB backups"
  deletion_window_in_days = 7
  enable_key_rotation     = true
}

# バックアップポリシー
resource "aws_backup_selection" "dynamodb" {
  name         = "dynamodb-backup"
  plan_id      = aws_backup_plan.dynamodb_backup.id
  iam_role_arn = aws_iam_role.backup.arn

  resources = [
    aws_dynamodb_table.price_comparison_backup_v2.arn,
    aws_dynamodb_table.price_comparison.arn
  ]

  selection_tag {
    type  = "STRINGEQUALS"
    key   = "Environment"
    value = "production"
  }
}

# バックアップ用IAMロール
resource "aws_iam_role" "backup" {
  name = "backup-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "backup.amazonaws.com"
        }
      }
    ]
  })
}

# バックアップ用IAMポリシー
resource "aws_iam_role_policy" "backup" {
  name = "backup-policy"
  role = aws_iam_role.backup.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:DescribeTable",
          "dynamodb:ListBackups",
          "dynamodb:CreateBackup",
          "dynamodb:DeleteBackup",
          "dynamodb:RestoreTableFromBackup"
        ]
        Resource = [
          aws_dynamodb_table.iphone_prices.arn,
          aws_dynamodb_table.official_prices.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "tag:GetResources"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:GenerateDataKey"
        ]
        Resource = aws_kms_key.backup.arn
      }
    ]
  })
}
</file>

<file path="terraform/cost_monitoring.tf">
# コストアラートの設定
resource "aws_budgets_budget" "monthly" {
  name              = "price-comparison-monthly-budget"
  budget_type       = "COST"
  limit_amount      = "1000" # 月間予算1000ドル
  limit_unit        = "USD"
  time_unit         = "MONTHLY"
  time_period_start = "2024-01-01_00:00"

  notification {
    comparison_operator        = "GREATER_THAN"
    threshold                  = 80 # 予算の80%を超えたら通知
    threshold_type             = "PERCENTAGE"
    notification_type          = "ACTUAL"
    subscriber_email_addresses = [var.alert_email]
  }

  notification {
    comparison_operator        = "GREATER_THAN"
    threshold                  = 100 # 予算を超えたら通知
    threshold_type             = "PERCENTAGE"
    notification_type          = "FORECASTED"
    subscriber_email_addresses = [var.alert_email]
  }
}

# リソース使用量の監視
resource "aws_cloudwatch_metric_alarm" "lambda_cost" {
  alarm_name          = "lambda-cost-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "EstimatedCharges"
  namespace           = "AWS/Billing"
  period              = "21600" # 6時間
  statistic           = "Maximum"
  threshold           = "50" # 50ドル
  alarm_description   = "Lambda関数の推定コストが閾値を超えました"
  treat_missing_data  = "notBreaching"

  dimensions = {
    ServiceName = "AWSLambda"
    Currency    = "USD"
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

resource "aws_cloudwatch_metric_alarm" "dynamodb_cost" {
  alarm_name          = "dynamodb-cost-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "EstimatedCharges"
  namespace           = "AWS/Billing"
  period              = "21600" # 6時間
  statistic           = "Maximum"
  threshold           = "30" # 30ドル
  alarm_description   = "DynamoDBの推定コストが閾値を超えました"
  treat_missing_data  = "notBreaching"

  dimensions = {
    ServiceName = "AmazonDynamoDB"
    Currency    = "USD"
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# コスト最適化のためのメトリクス
resource "aws_cloudwatch_metric_alarm" "lambda_invocations" {
  alarm_name          = "lambda-invocations-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "Invocations"
  namespace           = "AWS/Lambda"
  period              = "3600" # 1時間
  statistic           = "Sum"
  threshold           = "1000" # 1時間あたり1000回
  alarm_description   = "Lambda関数の呼び出し回数が多すぎます"
  treat_missing_data  = "notBreaching"

  dimensions = {
    FunctionName = aws_lambda_function.get_prices.function_name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

resource "aws_cloudwatch_metric_alarm" "dynamodb_capacity_units" {
  alarm_name          = "dynamodb-capacity-units-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "ConsumedReadCapacityUnits"
  namespace           = "AWS/DynamoDB"
  period              = "3600" # 1時間
  statistic           = "Sum"
  threshold           = "10000" # 1時間あたり10000ユニット
  alarm_description   = "DynamoDBの読み取り容量ユニットが多すぎます"
  treat_missing_data  = "notBreaching"

  dimensions = {
    TableName = aws_dynamodb_table.price_comparison.name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# リソースタグの設定
resource "aws_resourcegroups_group" "cost_optimization" {
  name        = "cost-optimization-group"
  description = "Resources for cost optimization"

  resource_query {
    query = jsonencode({
      ResourceTypeFilters = ["AWS::AllSupported"]
      TagFilters = [
        {
          Key    = "Environment"
          Values = [var.environment]
        },
        {
          Key    = "CostCenter"
          Values = ["PriceComparison"]
        }
      ]
    })
  }
}

# コスト最適化のためのCloudWatchアラーム
resource "aws_cloudwatch_metric_alarm" "cost_anomaly" {
  alarm_name          = "cost-anomaly-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "AnomalyScore"
  namespace           = "AWS/CostExplorer"
  period              = "86400"
  statistic           = "Maximum"
  threshold           = "80"
  alarm_description   = "コストの異常を検知しました"
  treat_missing_data  = "notBreaching"

  alarm_actions = [aws_sns_topic.alerts.arn]
}
</file>

<file path="terraform/maintenance.tf">
# メンテナンスウィンドウの設定
resource "aws_ssm_maintenance_window" "price_comparison" {
  name              = "price-comparison-maintenance"
  description       = "Maintenance window for price comparison system"
  schedule          = "cron(0 2 ? * SUN *)" # 毎週日曜日の午前2時
  duration          = 2                     # 2時間
  cutoff            = 1                     # 1時間前までにタスクを開始
  schedule_timezone = "Asia/Tokyo"          # 日本時間
}

# メンテナンスウィンドウのターゲット
resource "aws_ssm_maintenance_window_target" "lambda" {
  window_id     = aws_ssm_maintenance_window.price_comparison.id
  name          = "lambda-maintenance-target"
  description   = "Target for Lambda function maintenance"
  resource_type = "INSTANCE"

  targets {
    key    = "tag:Environment"
    values = [var.environment]
  }
}

# メンテナンスタスク
resource "aws_ssm_maintenance_window_task" "lambda_cleanup" {
  window_id        = aws_ssm_maintenance_window.price_comparison.id
  task_type        = "RUN_COMMAND"
  task_arn         = "AWS-RunShellScript"
  priority         = 1
  service_role_arn = aws_iam_role.maintenance_window.arn
  max_concurrency  = "1"
  max_errors       = "1"

  targets {
    key    = "WindowTargetIds"
    values = [aws_ssm_maintenance_window_target.lambda.id]
  }

  task_invocation_parameters {
    run_command_parameters {
      timeout_seconds = 600

      parameter {
        name = "commands"
        values = [
          "aws lambda update-function-configuration --function-name ${aws_lambda_function.get_prices.function_name} --environment '{\"Variables\":{\"MAINTENANCE_MODE\":\"true\"}}'",
          "sleep 300",
          "aws lambda update-function-configuration --function-name ${aws_lambda_function.get_prices.function_name} --environment '{\"Variables\":{\"MAINTENANCE_MODE\":\"false\"}}'"
        ]
      }
    }
  }
}

# メンテナンスウィンドウ用のIAMロール
resource "aws_iam_role" "maintenance_window" {
  name = "maintenance-window-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ssm.amazonaws.com"
        }
      }
    ]
  })
}

# メンテナンスウィンドウ用のIAMポリシー
resource "aws_iam_role_policy" "maintenance_window" {
  name = "maintenance-window-policy"
  role = aws_iam_role.maintenance_window.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "lambda:UpdateFunctionConfiguration",
          "lambda:GetFunctionConfiguration"
        ]
        Resource = aws_lambda_function.get_prices.arn
      }
    ]
  })
}
</file>

<file path="terraform/terraform.tfvars">
environment               = "production"
project                   = "iphone_price_tracker"
alert_email               = "konishi.b0engineer@gmail.com"
budget_notification_email = "konishi.b0engineer@gmail.com"
aws_account_id            = "273354647319"
vpc_id                    = "vpc-059f369ee085199f7"
line_channel_access_token = "mi4hNJnN61OAfMHeqNoPgS7yl979kQWtuKTqKlqg4tuoi5C/hb1uzVCCiT7LQ5iTYN9Grx4tgAlItJ15wFUK8Z3nRi5zebSl9XTmoCC1VtZhAT/vpy09Dl+Y815eNcwIoZHsNSbcf57mZ5Rj6+emagdB04t89/1O/w1cDnyilFU="
line_notify_token         = "0Gtx0g/muPh9vdELL0wgYqOCXNxh2q+b0UHX12NKuhQwadStPGhvLpKcOwldwf49YN9Grx4tgAlItJ15wFUK8Z3nRi5zebSl9XTmoCC1Vtbj/xTFBqNlSzIwTM9f5UeWTqacxhemtAsJQuUDqdLuuQdB04t89/1O/w1cDnyilFU="
</file>

<file path="tests/pytest.ini">
[pytest]
pythonpath = .
testpaths = tests/unit
python_files = test_*.py
addopts = -v -s --cov=src --cov-report=term-missing --cov-report=xml --tb=short
markers =
    unit: Unit tests
    integration: Integration tests
filterwarnings =
    ignore::DeprecationWarning
    ignore::UserWarning
log_cli = true
log_cli_level = INFO
</file>

<file path=".github/workflows/scrape_prices.yml">
name: Scrape iPhone Prices

on:
  schedule:
    - cron: '0 */6 * * *'  # 6時間ごとに実行
  workflow_dispatch:  # 手動実行も可能

env:
  AWS_REGION: ap-northeast-1
  PYTHONPATH: ${{ github.workspace }}

jobs:
  scrape:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install base dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-base.txt

      - name: Install web dependencies
        run: |
          pip install -r requirements-web.txt
          playwright install chromium --with-deps

      - name: Install test dependencies
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          pip install -r requirements-test.txt

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActionsSession

      - name: Run price scraping
        run: |
          python src/lambda_functions/get_prices_lambda/lambda_function.py

      - name: Run tests
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          pytest tests/ --cov=src --cov-report=xml

      - name: Upload coverage report
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          fail_ci_if_error: true
</file>

<file path="terraform/scripts/requirements.txt">
boto3>=1.26.0
requests>=2.31.0
beautifulsoup4==4.12.0
PyYAML==6.0.1
python-dateutil==2.9.0.post0
pytz==2024.2
</file>

<file path="terraform/disaster_recovery.tf">
# プライマリテーブルを先に作成
# resource "aws_dynamodb_table" "price_comparison_primary" {
#   name           = "price-comparison"
#   billing_mode   = "PAY_PER_REQUEST"
#   hash_key       = "id"
#   range_key      = "timestamp"
# 
#   attribute {
#     name = "id"
#     type = "S"
#   }
# 
#   attribute {
#     name = "timestamp"
#     type = "S"
#   }
# 
#   tags = {
#     Name        = "price-comparison"
#     Environment = "production"
#   }
# }
# 
# # グローバルテーブルの設定
# resource "aws_dynamodb_table" "price_comparison" {
#   name           = "price-comparison"
#   billing_mode   = "PAY_PER_REQUEST"
#   hash_key       = "id"
#   stream_enabled = true
#   stream_view_type = "NEW_AND_OLD_IMAGES"
# 
#   attribute {
#     name = "id"
#     type = "S"
#   }
# 
#   server_side_encryption {
#     enabled = true
#     kms_key_arn = aws_kms_key.data_encryption.arn
#   }
# 
#   replica {
#     region_name = "ap-southeast-1"
#   }
# 
#   tags = {
#     Name        = "price-comparison"
#     Environment = "production"
#     Project     = "iphone_price_tracker"
#   }
# }

# DynamoDBのバックアップ設定
resource "aws_dynamodb_table" "price_comparison_backup" {
  name           = "price-comparison-backup"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "model"
  stream_enabled = true
  stream_view_type = "NEW_AND_OLD_IMAGES"

  attribute {
    name = "model"
    type = "S"
  }

  server_side_encryption {
    enabled = true
    kms_key_arn = aws_kms_key.data_encryption.arn
  }

  tags = {
    Name        = "price-comparison-backup"
    Purpose     = "backup"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 新しいバックアップテーブルの設定
resource "aws_dynamodb_table" "price_comparison_backup_v2" {
  name           = "price-comparison-backup-v2"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "model"
  stream_enabled = true
  stream_view_type = "NEW_AND_OLD_IMAGES"

  attribute {
    name = "model"
    type = "S"
  }

  server_side_encryption {
    enabled = true
    kms_key_arn = aws_kms_key.data_encryption.arn
  }

  tags = {
    Name        = "price-comparison-backup-v2"
    Purpose     = "backup"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# Lambda関数のバックアップ設定
resource "aws_lambda_function" "get_prices_backup" {
  filename      = "lambda_function.zip"
  function_name = "${aws_lambda_function.get_prices.function_name}-backup"
  role          = aws_iam_role.lambda_execution_role.arn
  handler       = "get_prices_lambda.lambda_handler"
  runtime       = "python3.9"
  memory_size   = 1024
  timeout       = 15
  publish       = true

  environment {
    variables = {
      DYNAMODB_TABLE = aws_dynamodb_table.price_comparison_backup.name
    }
  }

  tags = {
    Name        = "${aws_lambda_function.get_prices.function_name}-backup"
    Environment = var.environment
    Purpose     = "backup"
  }
}

# API Gatewayのバックアップ設定
resource "aws_api_gateway_rest_api" "price_comparison_backup" {
  name        = "${aws_api_gateway_rest_api.price_comparison.name}-backup"
  description = "Backup API for iPhone price comparison"
}

resource "aws_api_gateway_resource" "prices_backup" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison_backup.id
  parent_id   = aws_api_gateway_rest_api.price_comparison_backup.root_resource_id
  path_part   = "get_prices"
}

resource "aws_api_gateway_method" "get_prices_backup" {
  rest_api_id   = aws_api_gateway_rest_api.price_comparison_backup.id
  resource_id   = aws_api_gateway_resource.prices_backup.id
  http_method   = "GET"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "lambda_backup" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison_backup.id
  resource_id = aws_api_gateway_resource.prices_backup.id
  http_method = aws_api_gateway_method.get_prices_backup.http_method

  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.get_prices_backup.invoke_arn
}

resource "aws_api_gateway_deployment" "api_backup" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison_backup.id

  depends_on = [
    aws_api_gateway_integration.lambda_backup
  ]

  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_api_gateway_stage" "production_backup" {
  stage_name    = "production"
  rest_api_id   = aws_api_gateway_rest_api.price_comparison_backup.id
  deployment_id = aws_api_gateway_deployment.api_backup.id

  cache_cluster_enabled = true
  cache_cluster_size    = "0.5"

  variables = {
    deployed_at = timestamp()
  }
}

# バックアップの自動化
resource "aws_cloudwatch_event_rule" "backup_schedule" {
  name                = "backup-schedule"
  description         = "定期バックアップのスケジュール"
  schedule_expression = "cron(0 0 * * ? *)" # 毎日午前0時に実行
}

resource "aws_cloudwatch_event_target" "backup_lambda" {
  rule      = aws_cloudwatch_event_rule.backup_schedule.name
  target_id = "BackupLambda"
  arn       = aws_lambda_function.get_prices_backup.arn
}

# バックアップの検証
resource "aws_cloudwatch_metric_alarm" "backup_verification" {
  alarm_name          = "backup-verification"
  comparison_operator = "LessThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "Invocations"
  namespace           = "AWS/Lambda"
  period              = "86400" # 24時間
  statistic           = "Sum"
  threshold           = "1" # 1回以上の実行
  alarm_description   = "バックアップが24時間以内に実行されていません"
  treat_missing_data  = "breaching"

  dimensions = {
    FunctionName = aws_lambda_function.get_prices_backup.function_name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}
</file>

<file path="terraform/dr_plan.tf">
# ディザスタリカバリ用のIAMロール
resource "aws_iam_role" "dr_role" {
  name = "price-comparison-dr-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "dr_policy" {
  name = "price-comparison-dr-policy"
  role = aws_iam_role.dr_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:DescribeTable",
          "dynamodb:Scan",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:GetItem",
          "dynamodb:Query",
          "dynamodb:BatchWriteItem",
          "dynamodb:BatchGetItem",
          "dynamodb:DescribeTable"
        ]
        Resource = [
          aws_dynamodb_table.price_comparison.arn,
          aws_dynamodb_table.price_comparison_backup.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      }
    ]
  })
}

# ディザスタリカバリ用のLambda関数
resource "aws_lambda_function" "dr_handler" {
  filename      = "lambda_function.zip"
  function_name = "price-comparison-dr-handler"
  role          = aws_iam_role.dr_role.arn
  handler       = "dr_handler.lambda_handler"
  runtime       = "python3.9"
  memory_size   = 1024
  timeout       = 300 # 5分

  environment {
    variables = {
      PRIMARY_TABLE = aws_dynamodb_table.price_comparison.name
      BACKUP_TABLE  = aws_dynamodb_table.price_comparison_backup.name
      PRIMARY_API   = aws_api_gateway_rest_api.price_comparison.id
      BACKUP_API    = aws_api_gateway_rest_api.price_comparison_backup.id
    }
  }

  tags = {
    Name        = "price-comparison-dr-handler"
    Environment = var.environment
    Purpose     = "disaster-recovery"
  }
}

# ディザスタリカバリの自動化
resource "aws_cloudwatch_event_rule" "dr_test" {
  name                = "dr-test-schedule"
  description         = "ディザスタリカバリテストのスケジュール"
  schedule_expression = "cron(0 0 1 * ? *)" # 毎月1日午前0時に実行
}

resource "aws_cloudwatch_event_target" "dr_test" {
  rule      = aws_cloudwatch_event_rule.dr_test.name
  target_id = "DRTest"
  arn       = aws_lambda_function.dr_handler.arn
}

# ディザスタリカバリの検証
resource "aws_cloudwatch_metric_alarm" "dr_verification" {
  alarm_name          = "dr-verification"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  metric_name         = "Errors"
  namespace           = "AWS/Lambda"
  period             = 300  # 5分に変更
  statistic          = "Sum"
  threshold          = 0
  alarm_description  = "DR verification Lambda function errors"
  alarm_actions      = [aws_sns_topic.alerts.arn]

  dimensions = {
    FunctionName = aws_lambda_function.dr_handler.function_name
  }

  tags = {
    Name        = "dr-verification"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# ディザスタリカバリのドキュメント
resource "aws_ssm_document" "dr_plan" {
  name            = "dr-plan"
  document_type   = "Command"
  document_format = "YAML"

  content = <<DOC
schemaVersion: '2.2'
description: Disaster Recovery Plan
mainSteps:
  - action: aws:runPowerShellScript
    name: invokeDRHandler
    inputs:
      runCommand:
        - aws lambda invoke --function-name price-comparison-dr-handler response.json
DOC
}
</file>

<file path="terraform/monitoring.tf">
# CloudWatchのモニタリング設定

# Lambda関数のエラーアラーム
resource "aws_cloudwatch_metric_alarm" "lambda_errors" {
  alarm_name          = "get_prices_lambda_errors"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "Errors"
  namespace           = "AWS/Lambda"
  period              = "300" # 5分
  statistic           = "Sum"
  threshold           = "0"
  alarm_description   = "Lambda関数のエラー発生を検知"
  treat_missing_data  = "notBreaching"

  dimensions = {
    FunctionName = aws_lambda_function.get_prices.function_name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# Lambda関数の実行時間アラーム
resource "aws_cloudwatch_metric_alarm" "lambda_duration" {
  alarm_name          = "lambda-duration-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "3"
  metric_name         = "Duration"
  namespace           = "AWS/Lambda"
  period              = "300"
  statistic           = "Average"
  threshold           = "1000" # 1秒
  alarm_description   = "Lambda関数の実行時間が長すぎます"
  treat_missing_data  = "notBreaching"

  dimensions = {
    FunctionName = aws_lambda_function.get_prices.function_name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# API Gatewayのエラーアラーム
resource "aws_cloudwatch_metric_alarm" "api_gateway_errors" {
  alarm_name          = "price_comparison_api_errors"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "5XXError"
  namespace           = "AWS/ApiGateway"
  period              = "300" # 5分
  statistic           = "Sum"
  threshold           = "0"
  alarm_description   = "API Gatewayの5XXエラー発生を検知"
  treat_missing_data  = "notBreaching"

  dimensions = {
    ApiName = aws_api_gateway_rest_api.price_comparison.name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# DynamoDBの容量アラーム
resource "aws_cloudwatch_metric_alarm" "dynamodb_capacity" {
  alarm_name          = "price_comparison_dynamodb_capacity"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "ConsumedReadCapacityUnits"
  namespace           = "AWS/DynamoDB"
  period              = "300" # 5分
  statistic           = "Sum"
  threshold           = "1000" # 1,000ユニット
  alarm_description   = "DynamoDBの読み取り容量が高い"
  treat_missing_data  = "notBreaching"

  dimensions = {
    TableName = aws_dynamodb_table.price_comparison.name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# SNSトピックの作成
resource "aws_sns_topic" "alerts" {
  name = "price_comparison_alerts"
}

# SNSトピックのポリシー
resource "aws_sns_topic_policy" "alerts" {
  arn    = aws_sns_topic.alerts.arn
  policy = data.aws_iam_policy_document.sns_topic_policy.json
}

# SNSトピックのポリシードキュメント
data "aws_iam_policy_document" "sns_topic_policy" {
  statement {
    effect    = "Allow"
    actions   = ["SNS:Publish"]
    resources = [aws_sns_topic.alerts.arn]

    principals {
      type        = "Service"
      identifiers = ["cloudwatch.amazonaws.com"]
    }
  }
}

# CloudWatchダッシュボード
resource "aws_cloudwatch_dashboard" "main" {
  dashboard_name = "price-comparison-dashboard"

  dashboard_body = jsonencode({
    widgets = [
      {
        type   = "metric"
        x      = 0
        y      = 0
        width  = 12
        height = 6

        properties = {
          metrics = [
            ["AWS/Lambda", "Errors", "FunctionName", aws_lambda_function.get_prices.function_name],
            ["AWS/Lambda", "Duration", "FunctionName", aws_lambda_function.get_prices.function_name]
          ]
          period = 300
          stat   = "Sum"
          region = var.aws_region
          title  = "Lambda Function Metrics"
        }
      },
      {
        type   = "metric"
        x      = 12
        y      = 0
        width  = 12
        height = 6

        properties = {
          metrics = [
            ["AWS/ApiGateway", "5XXError", "ApiName", aws_api_gateway_rest_api.price_comparison.name],
            ["AWS/ApiGateway", "4XXError", "ApiName", aws_api_gateway_rest_api.price_comparison.name]
          ]
          period = 300
          stat   = "Sum"
          region = var.aws_region
          title  = "API Gateway Errors"
        }
      },
      {
        type   = "metric"
        x      = 0
        y      = 6
        width  = 12
        height = 6

        properties = {
          metrics = [
            ["AWS/DynamoDB", "ConsumedReadCapacityUnits", "TableName", aws_dynamodb_table.price_comparison.name],
            ["AWS/DynamoDB", "ConsumedWriteCapacityUnits", "TableName", aws_dynamodb_table.price_comparison.name]
          ]
          period = 300
          stat   = "Sum"
          region = var.aws_region
          title  = "DynamoDB Capacity"
        }
      },
      {
        type   = "log"
        x      = 0
        y      = 12
        width  = 12
        height = 6

        properties = {
          query  = "SOURCE '/aws/lambda/${aws_lambda_function.get_prices.function_name}' | fields @timestamp, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 20"
          region = var.aws_region
          title  = "Lambda Error Logs"
          view   = "table"
        }
      },
      {
        type   = "log"
        x      = 12
        y      = 12
        width  = 12
        height = 6

        properties = {
          query  = "SOURCE '/aws/apigateway/${aws_api_gateway_rest_api.price_comparison.name}' | fields @timestamp, @message | filter @message like /error/ | sort @timestamp desc | limit 20"
          region = var.aws_region
          title  = "API Gateway Error Logs"
          view   = "table"
        }
      }
    ]
  })
}

# CloudWatch Logs Insightsのクエリ定義
resource "aws_cloudwatch_query_definition" "lambda_errors" {
  name = "lambda-errors"
  log_group_names = [
    "/aws/lambda/${aws_lambda_function.get_prices.function_name}"
  ]
  query_string = <<EOF
fields @timestamp, @message
| filter @message like /ERROR/
| sort @timestamp desc
| limit 20
EOF
}

resource "aws_cloudwatch_query_definition" "api_errors" {
  name = "api-errors"
  log_group_names = [
    "/aws/apigateway/${aws_api_gateway_rest_api.price_comparison.name}"
  ]
  query_string = <<EOF
fields @timestamp, @message
| filter @message like /error/
| sort @timestamp desc
| limit 20
EOF
}

# ロググループの保持期間設定
resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/${aws_lambda_function.get_prices.function_name}"
  retention_in_days = 30
}

resource "aws_cloudwatch_log_group" "api_gateway_logs" {
  name              = "/aws/apigateway/price-comparison-api"
  retention_in_days = 30

  lifecycle {
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "api-gateway-logs"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# カスタムメトリクスの定義
resource "aws_cloudwatch_metric_alarm" "custom_error_rate" {
  alarm_name          = "price_comparison_error_rate"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "ErrorRate"
  namespace           = "Custom/PriceComparison"
  period              = "300"
  statistic           = "Average"
  threshold           = "0.1" # 10%のエラーレート
  alarm_description   = "カスタムエラーレートが閾値を超えました"
  treat_missing_data  = "notBreaching"

  dimensions = {
    Service = "PriceComparison"
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# パフォーマンスモニタリングのためのCloudWatchダッシュボード
resource "aws_cloudwatch_dashboard" "performance" {
  dashboard_name = "performance-dashboard"
  dashboard_body = jsonencode({
    widgets = [
      {
        type   = "metric"
        x      = 0
        y      = 0
        width  = 12
        height = 6
        properties = {
          metrics = [
            ["AWS/Lambda", "Duration", "FunctionName", aws_lambda_function.get_prices.function_name],
            ["AWS/Lambda", "ConcurrentExecutions", "FunctionName", aws_lambda_function.get_prices.function_name]
          ]
          period = 300
          stat   = "Average"
          region = var.aws_region
          title  = "Lambda Performance"
        }
      },
      {
        type   = "metric"
        x      = 12
        y      = 0
        width  = 12
        height = 6
        properties = {
          metrics = [
            ["AWS/DynamoDB", "ConsumedReadCapacityUnits", "TableName", aws_dynamodb_table.iphone_prices.name],
            ["AWS/DynamoDB", "ConsumedWriteCapacityUnits", "TableName", aws_dynamodb_table.iphone_prices.name]
          ]
          period = 300
          stat   = "Sum"
          region = var.aws_region
          title  = "DynamoDB Throughput"
        }
      },
      {
        type   = "metric"
        x      = 0
        y      = 6
        width  = 12
        height = 6
        properties = {
          metrics = [
            ["AWS/ApiGateway", "Latency", "ApiName", aws_api_gateway_rest_api.price_comparison.name],
            ["AWS/ApiGateway", "IntegrationLatency", "ApiName", aws_api_gateway_rest_api.price_comparison.name]
          ]
          period = 300
          stat   = "Average"
          region = var.aws_region
          title  = "API Gateway Latency"
        }
      }
    ]
  })
}

# パフォーマンスアラームの設定
resource "aws_cloudwatch_metric_alarm" "api_latency" {
  alarm_name          = "api-latency-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "3"
  metric_name         = "Latency"
  namespace           = "AWS/ApiGateway"
  period              = "300"
  statistic           = "Average"
  threshold           = "500" # 500ミリ秒
  alarm_description   = "API Gatewayのレイテンシーが高すぎます"
  treat_missing_data  = "notBreaching"

  dimensions = {
    ApiName = aws_api_gateway_rest_api.price_comparison.name
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# パフォーマンスログの設定
resource "aws_cloudwatch_log_group" "performance" {
  name              = "/aws/lambda/performance-logs"
  retention_in_days = 30

  tags = {
    Environment = var.environment
    Purpose     = "PerformanceMonitoring"
  }
}

# パフォーマンスメトリクスのフィルター
resource "aws_cloudwatch_log_metric_filter" "slow_requests" {
  name           = "slow-requests-filter"
  pattern        = "{ $.duration > 1000 }"
  log_group_name = aws_cloudwatch_log_group.performance.name

  metric_transformation {
    name      = "SlowRequests"
    value     = "1"
    namespace = "Custom/Performance"
  }
}
</file>

<file path="terraform/security.tf">
# AWS Security Hubの設定
resource "aws_securityhub_account" "main" {
}

# Security Hubの標準を有効化
resource "aws_securityhub_standards_subscription" "cis" {
  standards_arn = "arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0"
  depends_on    = [aws_securityhub_account.main]
}

resource "aws_securityhub_standards_subscription" "pci" {
  standards_arn = "arn:aws:securityhub:ap-northeast-1::standards/pci-dss/v/3.2.1"
  depends_on    = [aws_securityhub_account.main]
}

# セキュリティイベントの監視
resource "aws_cloudwatch_event_rule" "security_events" {
  name        = "security-events"
  description = "セキュリティ関連のイベントを監視"

  event_pattern = jsonencode({
    source      = ["aws.securityhub"]
    detail-type = ["Security Hub Findings - Imported"]
  })
}

resource "aws_cloudwatch_event_target" "security_events" {
  rule      = aws_cloudwatch_event_rule.security_events.name
  target_id = "SecurityEvents"
  arn       = aws_sns_topic.alerts.arn
}

# セキュリティアラートの設定
resource "aws_cloudwatch_metric_alarm" "security_findings" {
  alarm_name          = "security-findings"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "SecurityFindings"
  namespace           = "AWS/SecurityHub"
  period              = "300"
  statistic           = "Sum"
  threshold           = "0"
  alarm_description   = "新しいセキュリティの検出結果があります"
  treat_missing_data  = "notBreaching"

  dimensions = {
    ProductName = "Security Hub"
  }

  alarm_actions = [aws_sns_topic.alerts.arn]
}

# コンプライアンスチェックの設定
resource "aws_config_configuration_recorder" "main" {
  name     = "price-comparison-recorder"
  role_arn = aws_iam_role.config_role.arn

  recording_group {
    all_supported = true
  }
}

resource "aws_config_delivery_channel" "main" {
  name           = "price-comparison-delivery"
  s3_bucket_name = aws_s3_bucket.config_bucket.id
  s3_key_prefix  = "config"

  snapshot_delivery_properties {
    delivery_frequency = "Six_Hours"
  }

  depends_on = [aws_config_configuration_recorder.main]
}

# 設定ファイル用のS3バケット
resource "aws_s3_bucket" "config_bucket" {
  bucket        = "price-comparison-config-production"
  force_destroy = true  # 一時的に有効化

  tags = {
    Name        = "price-comparison-config"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_s3_bucket_versioning" "config_bucket" {
  bucket = aws_s3_bucket.config_bucket.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "config_bucket" {
  bucket = aws_s3_bucket.config_bucket.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# ConfigのIAMロール
resource "aws_iam_role" "config_role" {
  name = "price-comparison-config-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "config.amazonaws.com"
        }
      }
    ]
  })

  tags = {
    Name        = "price-comparison-config-role"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_iam_role_policy" "config_policy" {
  name = "config-policy"
  role = aws_iam_role.config_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:PutObject",
          "s3:GetBucketAcl"
        ]
        Resource = [
          aws_s3_bucket.config_bucket.arn,
          "${aws_s3_bucket.config_bucket.arn}/*"
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "config:Put*",
          "config:Get*",
          "config:List*",
          "config:Describe*"
        ]
        Resource = "*"
      }
    ]
  })
}

# WAF Web ACLの設定
resource "aws_wafv2_web_acl" "api_gateway" {
  name        = "api-gateway-waf"
  description = "WAF for API Gateway"
  scope       = "REGIONAL"

  default_action {
    allow {}
  }

  rule {
    name     = "RateLimit"
    priority = 1

    action {
      block {}
    }

    statement {
      rate_based_statement {
        limit              = 1000
        aggregate_key_type = "IP"
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "RateLimit"
      sampled_requests_enabled   = true
    }
  }

  rule {
    name     = "SQLInjection"
    priority = 2

    action {
      block {}
    }

    statement {
      sqli_match_statement {
        field_to_match {
          query_string {}
        }
        text_transformation {
          priority = 1
          type     = "URL_DECODE"
        }
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "SQLInjection"
      sampled_requests_enabled   = true
    }
  }

  rule {
    name     = "XSSProtection"
    priority = 3

    action {
      block {}
    }

    statement {
      xss_match_statement {
        field_to_match {
          query_string {}
        }
        text_transformation {
          priority = 1
          type     = "URL_DECODE"
        }
        text_transformation {
          priority = 2
          type     = "HTML_ENTITY_DECODE"
        }
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "XSSProtection"
      sampled_requests_enabled   = true
    }
  }

  rule {
    name     = "SizeRestrictions"
    priority = 4

    action {
      block {}
    }

    statement {
      size_constraint_statement {
        field_to_match {
          query_string {}
        }
        comparison_operator = "GT"
        size                = 8192
        text_transformation {
          priority = 1
          type     = "URL_DECODE"
        }
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "SizeRestrictions"
      sampled_requests_enabled   = true
    }
  }

  rule {
    name     = "CommonVulnerabilities"
    priority = 5

    action {
      block {}
    }

    statement {
      or_statement {
        statement {
          sqli_match_statement {
            field_to_match {
              body {}
            }
            text_transformation {
              priority = 1
              type     = "URL_DECODE"
            }
          }
        }
        statement {
          sqli_match_statement {
            field_to_match {
              uri_path {}
            }
            text_transformation {
              priority = 1
              type     = "URL_DECODE"
            }
          }
        }
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "CommonVulnerabilities"
      sampled_requests_enabled   = true
    }
  }

  visibility_config {
    cloudwatch_metrics_enabled = true
    metric_name                = "WAF"
    sampled_requests_enabled   = true
  }

  tags = {
    Name        = "api-gateway-waf"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_wafv2_web_acl_association" "api_gateway" {
  resource_arn = aws_api_gateway_stage.production.arn
  web_acl_arn  = aws_wafv2_web_acl.api_gateway.arn

  depends_on = [
    aws_api_gateway_stage.production,
    aws_wafv2_web_acl.api_gateway
  ]
}

# セキュリティグループの設定
resource "aws_security_group" "lambda" {
  name        = "lambda-security-group"
  description = "Security group for Lambda functions"
  vpc_id      = var.vpc_id

  ingress {
    description     = "Allow HTTPS traffic from API Gateway"
    from_port       = 443
    to_port         = 443
    protocol        = "tcp"
    security_groups = [aws_security_group.api_gateway.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "lambda-security-group"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_security_group" "api_gateway" {
  name        = "api-gateway-security-group"
  description = "Security group for API Gateway"
  vpc_id      = var.vpc_id

  ingress {
    description = "Allow HTTPS traffic from internet"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "api-gateway-security-group"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# KMSキー
resource "aws_kms_key" "data_encryption" {
  description             = "KMS key for data encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable IAM User Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = "*"
      },
      {
        Sid    = "Allow CloudTrail to encrypt logs"
        Effect = "Allow"
        Principal = {
          Service = "cloudtrail.amazonaws.com"
        }
        Action = [
          "kms:GenerateDataKey*",
          "kms:Decrypt"
        ]
        Resource = "*"
        Condition = {
          StringLike = {
            "kms:EncryptionContext:aws:cloudtrail:arn" = "arn:aws:cloudtrail:*:${data.aws_caller_identity.current.account_id}:trail/*"
          }
        }
      }
    ]
  })

  tags = {
    Name        = "data-encryption-key"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# KMSキーのエイリアス
resource "aws_kms_alias" "data_encryption" {
  name          = "alias/data-encryption-key"
  target_key_id = aws_kms_key.data_encryption.key_id
}

# CloudTrailの設定
resource "aws_cloudtrail" "security_audit" {
  name                          = "security-audit-trail"
  s3_bucket_name               = aws_s3_bucket.cloudtrail.id
  include_global_service_events = true
  is_multi_region_trail        = true
  enable_logging               = true
  kms_key_id                   = aws_kms_key.data_encryption.arn

  tags = {
    Name        = "security-audit-trail"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# CloudTrail用のS3バケット
resource "aws_s3_bucket" "cloudtrail" {
  bucket        = "security-audit-trail-${data.aws_caller_identity.current.account_id}"
  force_destroy = true

  tags = {
    Name        = "security-audit-trail"
    Environment = "production"
    Project     = "iphone_price_tracker"
    Purpose     = "SecurityAudit"
  }
}

resource "aws_s3_bucket_versioning" "cloudtrail" {
  bucket = aws_s3_bucket.cloudtrail.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "cloudtrail" {
  bucket = aws_s3_bucket.cloudtrail.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_policy" "cloudtrail" {
  bucket = aws_s3_bucket.cloudtrail.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AWSCloudTrailAclCheck"
        Effect = "Allow"
        Principal = {
          Service = "cloudtrail.amazonaws.com"
        }
        Action   = "s3:GetBucketAcl"
        Resource = aws_s3_bucket.cloudtrail.arn
      },
      {
        Sid    = "AWSCloudTrailWrite"
        Effect = "Allow"
        Principal = {
          Service = "cloudtrail.amazonaws.com"
        }
        Action   = "s3:PutObject"
        Resource = "${aws_s3_bucket.cloudtrail.arn}/*"
        Condition = {
          StringEquals = {
            "s3:x-amz-acl" = "bucket-owner-full-control"
          }
        }
      }
    ]
  })
}

provider "aws" {
  alias  = "ap-southeast-1"
  region = "ap-southeast-1"
}

resource "aws_kms_key" "data_encryption_replica" {
  provider = aws.ap-southeast-1
  description = "KMS key for encrypting DynamoDB data in ap-southeast-1"
  enable_key_rotation = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid = "Enable IAM User Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::273354647319:root"
        }
        Action = "kms:*"
        Resource = "*"
      }
    ]
  })

  tags = {
    Name        = "data-encryption-key-replica"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_kms_alias" "data_encryption_replica" {
  provider = aws.ap-southeast-1
  name          = "alias/data-encryption-key-replica"
  target_key_id = aws_kms_key.data_encryption_replica.key_id
}
</file>

<file path="terraform/variables.tf">
variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "project" {
  description = "Project name"
  type        = string
  default     = "iphone_price_tracker"
}

variable "alert_email" {
  description = "アラート通知を受け取るメールアドレス"
  type        = string
}

variable "vpc_id" {
  description = "The ID of the VPC where resources will be deployed"
  type        = string
}

variable "aws_account_id" {
  description = "The AWS account ID"
  type        = string
}

variable "budget_notification_email" {
  description = "Email address for budget notifications"
  type        = string
}

variable "github_org" {
  description = "GitHub organization name"
  type        = string
  default     = "PheasantDevil"
}

variable "github_repo" {
  description = "GitHub repository name"
  type        = string
  default     = "priceComparisonAppForIphone"
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "ap-northeast-1"
}

variable "line_channel_access_token" {
  description = "LINE Messaging API channel access token"
  type        = string
  sensitive   = true
}

variable "line_notify_token" {
  description = "LINE Notifyのアクセストークン"
  type        = string
  sensitive   = true
}

variable "create_sample_data" {
  description = "サンプルデータを作成するかどうか"
  type        = bool
  default     = false
}
</file>

<file path="app.py">
import json
import logging
import os
import re
from datetime import datetime

import boto3
from flask import Flask, jsonify, render_template, request, send_from_directory
from playwright.sync_api import sync_playwright

from config import config
from services.dynamodb_service import get_prices_by_series


def create_app():
    app = Flask(__name__)

    # アプリケーション設定の適用
    app.config['DEBUG'] = config.app.DEBUG
    app.config['SECRET_KEY'] = config.app.SECRET_KEY

    # Playwrightのタイムアウト設定
    app.config['PLAYWRIGHT_TIMEOUT'] = config.scraper.REQUEST_TIMEOUT * 1000  # ミリ秒単位に変換

    # ログ設定
    logging.basicConfig(
        level=getattr(logging, config.app.LOG_LEVEL),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # DynamoDBの設定
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table('price_history')

    # Lambdaクライアントの設定
    lambda_client = boto3.client('lambda')

    @app.route("/favicon.ico")
    def favicon():
        try:
            return send_from_directory(
                os.path.join(app.root_path, "static"),
                "favicon.ico",
                mimetype="image/vnd.microsoft.icon"
            )
        except Exception as e:
            app.logger.error(f"Favicon error: {str(e)}")
            return "", 204  # No Content

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/set-alert', methods=['POST'])
    def set_alert():
        try:
            data = request.get_json()
            threshold = data.get('threshold')
            
            if not threshold:
                return jsonify({'error': '閾値が指定されていません'}), 400
            
            # 閾値をDynamoDBに保存
            table.put_item(
                Item={
                    'id': 'alert_threshold',
                    'threshold': int(threshold),
                    'timestamp': str(datetime.now())
                }
            )
            
            return jsonify({'message': 'アラートを設定しました'}), 200
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/check-prices', methods=['GET'])
    def check_prices():
        try:
            # 価格データを取得
            response = table.scan()
            items = response.get('Items', [])
            
            # アラート閾値を取得
            alert_response = table.get_item(Key={'id': 'alert_threshold'})
            threshold = alert_response.get('Item', {}).get('threshold')
            
            if not threshold:
                return jsonify({'message': 'アラート閾値が設定されていません'}), 200
            
            # 価格が閾値を下回っているかチェック
            for item in items:
                if item.get('price', float('inf')) < threshold:
                    # LINE通知を送信
                    lambda_client.invoke(
                        FunctionName='line_notification_lambda',
                        InvocationType='Event',
                        Payload=json.dumps({
                            'message': f'価格アラート: {item.get("model")}の価格が{threshold}円を下回りました。現在の価格: {item.get("price")}円'
                        })
                    )
            
            return jsonify({'message': '価格チェックを完了しました'}), 200
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    return app

# アプリケーションインスタンスの作成
app = create_app()

def price_text_to_int(price_text):
    """価格テキストを整数に変換する"""
    try:
        # "123,456円" → 123456
        return int(price_text.replace("円", "").replace(",", ""))
    except (ValueError, AttributeError):
        return 0

def get_kaitori_prices():
    """買取価格データをスクレイピングで取得"""
    all_product_details = {
        "iPhone 16": {},
        "iPhone 16 Pro": {},
        "iPhone 16 Pro Max": {},
        "iPhone 16e": {},
    }

    with sync_playwright() as p:
        browser = p.chromium.launch(chromium_sandbox=False)
        page = browser.new_page()

        for url in config.scraper.KAITORI_RUDEA_URLS:
            page.goto(url)
            page.wait_for_load_state("networkidle")

            items = page.query_selector_all(".tr")

            for item in items:
                try:
                    model_element = item.query_selector(".ttl h2")
                    model_name = model_element.inner_text().strip() if model_element else ""

                    # モデル名からシリーズを判定
                    if "Pro Max" in model_name:
                        series = "iPhone 16 Pro Max"
                    elif "Pro" in model_name:
                        series = "iPhone 16 Pro"
                    elif "16" in model_name:
                        series = "iPhone 16"
                    elif "16" in model_name:
                        series = "iPhone 16 e"
                    else:
                        continue

                    # 容量を抽出（例: "128GB" または "1TB"）
                    capacity_match = re.search(r"(\d+)(GB|TB)", model_name)
                    if not capacity_match:
                        continue
                    capacity = capacity_match.group(0)  # "128GB" or "1TB"

                    price_element = item.query_selector(".td.td2 .td2wrap")
                    price_text = price_element.inner_text().strip() if price_element else ""

                    if model_name and price_text and "円" in price_text:
                        # カラーを抽出
                        color_match = re.search(r"(黒|白|桃|緑|青|金|灰)", model_name)
                        color = color_match.group(1) if color_match else "不明"

                        # 容量ごとのデータを初期化・更新
                        if capacity not in all_product_details[series]:
                            all_product_details[series][capacity] = {
                                "colors": {},
                                "kaitori_price_min": None,
                                "kaitori_price_max": None,
                            }

                        # 色ごとの価格を保存
                        price_value = price_text_to_int(price_text)
                        all_product_details[series][capacity]["colors"][color] = {
                            "price_text": price_text,
                            "price_value": price_value,
                        }

                        # 最小・最大価格を更新
                        current_min = all_product_details[series][capacity]["kaitori_price_min"]
                        current_max = all_product_details[series][capacity]["kaitori_price_max"]

                        if current_min is None or price_value < current_min:
                            all_product_details[series][capacity]["kaitori_price_min"] = price_value
                        if current_max is None or price_value > current_max:
                            all_product_details[series][capacity]["kaitori_price_max"] = price_value

                except Exception as e:
                    app.logger.error(f"データ取得エラー: {str(e)}")
                    continue

        browser.close()

    return all_product_details

@app.route("/get_prices")
def get_prices():
    """DynamoDBから最新の価格情報を取得"""
    try:
        # DynamoDBから価格データを取得
        dynamodb = boto3.resource('dynamodb')
        kaitori_table = dynamodb.Table('kaitori_prices')
        official_table = dynamodb.Table('official_prices')
        
        app.logger.info("Fetching data from kaitori_prices table...")
        # 買取価格データを取得
        kaitori_response = kaitori_table.scan()
        kaitori_items = kaitori_response.get('Items', [])
        app.logger.info(f"Found {len(kaitori_items)} items in kaitori_prices table")
        
        app.logger.info("Fetching data from official_prices table...")
        # 公式価格データを取得
        official_response = official_table.scan()
        official_items = official_response.get('Items', [])
        app.logger.info(f"Found {len(official_items)} items in official_prices table")
        app.logger.debug(f"Official prices data: {json.dumps(official_items, indent=2)}")
        
        # 公式価格をマッピング
        official_prices = {}
        for item in official_items:
            series = item.get('series')
            capacity = item.get('capacity')
            colors = item.get('colors', {})
            
            if series and capacity:
                if series not in official_prices:
                    official_prices[series] = {}
                official_prices[series][capacity] = colors
        
        app.logger.debug(f"Mapped official prices: {json.dumps(official_prices, indent=2)}")
        
        # データを整形
        price_data = {}
        for item in kaitori_items:
            model = item.get('model')
            capacity = item.get('capacity')
            price = item.get('price')
            
            app.logger.debug(f"Processing kaitori item: {json.dumps(item, indent=2)}")
            
            # モデル名からシリーズを判定
            if "Pro Max" in model:
                series = "iPhone 16 Pro Max"
            elif "Pro" in model:
                series = "iPhone 16 Pro"
            elif "16" in model:
                series = "iPhone 16"
            else:
                app.logger.warning(f"Skipping unknown model: {model}")
                continue
            
            if series not in price_data:
                price_data[series] = {}
            
            if capacity not in price_data[series]:
                # 公式価格を取得
                official_colors = official_prices.get(series, {}).get(capacity, {})
                app.logger.debug(f"Found official colors for {series} {capacity}: {official_colors}")
                
                price_data[series][capacity] = {
                    'colors': {'不明': {'price_text': f"{price:,}円", 'price_value': price}},
                    'kaitori_price_min': price,
                    'kaitori_price_max': price,
                    'official_prices': official_colors
                }
            else:
                # 最小・最大価格を更新
                current_min = price_data[series][capacity]['kaitori_price_min']
                current_max = price_data[series][capacity]['kaitori_price_max']
                
                if price < current_min:
                    price_data[series][capacity]['kaitori_price_min'] = price
                if price > current_max:
                    price_data[series][capacity]['kaitori_price_max'] = price

        app.logger.debug(f"Final price data: {json.dumps(price_data, indent=2)}")
        return jsonify(price_data), 200

    except Exception as e:
        app.logger.error(f"エラー: {str(e)}")
        app.logger.exception("Detailed error information:")
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 5000)))
</file>

<file path="Dockerfile">
# Dockerのイメージ名: price-comparison-app:latest

# ベースイメージを安定版のPythonに変更
FROM python:3.11-slim

# 必要なシステムパッケージとPlaywrightの依存ライブラリをインストール
RUN apt-get update && apt-get install -y --no-install-recommends \
    libnss3 \
    libnspr4 \
    libatk1.0-0 \
    libatk-bridge2.0-0 \
    libatspi2.0-0 \
    libxcomposite1 \
    libxdamage1 \
    libxrandr2 \
    libxkbcommon0 \
    libgdk-pixbuf2.0-0 \
    libgtk-3-0 \
    libpango-1.0-0 \
    libxshmfence1 \
    libgbm1 \
    libasound2 \
    libcurl4 \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 作業ディレクトリを設定
WORKDIR /app

# 依存関係ファイルを先にコピーしてキャッシュを活用
COPY requirements.txt .

# Pythonパッケージのインストール
RUN pip install --no-cache-dir -r requirements.txt

# Playwrightの環境変数を設定
ENV PLAYWRIGHT_BROWSERS_PATH=/opt/render/.cache/ms-playwright

# Playwrightブラウザのインストール
RUN playwright install chromium

# プロジェクトのファイルをコピー
COPY . .

# アプリケーションを起動
CMD ["gunicorn", "app:app", "--bind", "0.0.0.0:5000", "--workers=3", "--timeout=60"]
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPhone 16シリーズ 買取価格比較</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      /* ローディングスピナーのスタイル */
      .loader {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #priceTable {
        display: none;
      }

      .tables-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin: 20px auto;
        max-width: 1400px;
        padding: 0 20px;
      }

      .price-table {
        min-width: 300px;
        width: 100%;
        border-collapse: collapse;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .price-table caption {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .price-table th,
      .price-table td {
        padding: 8px 15px;
        border: 1px solid #ddd;
        text-align: left;
        white-space: nowrap;
      }

      .price-table th {
        background-color: #f2f2f2;
      }

      .price-table td:last-child {
        text-align: right;
      }

      .price-table td[style*='color: green'] {
        font-weight: bold;
      }

      .price-table td[style*='color: red'] {
        font-weight: bold;
      }

      .series-section {
        flex: 1 1 100%;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .series-section h2 {
        text-align: center;
        color: #333;
        margin-bottom: 15px;
      }

      /* 収支の色分け */
      .price-diff-negative {
        color: red;
        font-weight: bold;
      }

      .price-diff-positive {
        color: green;
        font-weight: bold;
      }

      /* ブレークポイントの調整 */
      @media (min-width: 576px) {
        .series-section {
          padding: 0 10px;
        }
      }

      @media (min-width: 768px) {
        .series-section {
          flex: 0 1 calc(50% - 20px);
        }
      }

      @media (min-width: 992px) {
        .series-section {
          flex: 0 1 calc(33.333% - 20px);
        }
      }

      @media (max-width: 576px) {
        .price-table {
          font-size: 0.85em;
        }
        .price-table th,
        .price-table td {
          padding: 6px 10px;
        }
      }

      /* テーブルラッパーを追加 */
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
        margin-bottom: 15px;
      }

      /* スマートフォン向けの調整 */
      @media (max-width: 414px) {
        .series-section {
          flex: 1 1 100%;
          max-width: 100%;
          padding: 0 10px;
        }

        .tables-container {
          gap: 20px;
          padding: 0 5px;
        }

        .table-wrapper {
          max-width: calc(100vw - 20px); /* 画面幅からパディングを引いた幅 */
        }

        .price-table {
          min-width: 300px; /* テーブルの最小幅を設定 */
          font-size: 0.85em; /* フォントサイズを縮小 */
        }

        .price-table th,
        .price-table td {
          padding: 6px 10px; /* セルのパディングを縮小 */
          white-space: nowrap; /* テキストの折り返しを防止 */
        }

        /* テーブルのキャプションスタイルを調整 */
        .series-section h2 {
          font-size: 1.1em;
          margin-bottom: 10px;
        }
      }

      /* さらに小さい画面向けの微調整 */
      @media (max-width: 374px) {
        .price-table {
          font-size: 0.8em;
        }

        .price-table th,
        .price-table td {
          padding: 5px 8px;
        }
      }

      /* グラフコンテナのスタイル */
      .graph-container {
        width: 100%;
        height: 200px;
        margin-top: 20px;
        margin-bottom: 30px;
      }

      /* 統計情報のスタイル */
      .stats-container {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .stat-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .stat-title {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
      }

      .stat-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .stat-change {
        font-size: 0.8em;
        margin-top: 5px;
      }

      .stat-change.positive {
        color: #2ecc71;
      }

      .stat-change.negative {
        color: #e74c3c;
      }

      .trend-indicator {
        display: inline-block;
        margin-left: 5px;
        font-size: 0.8em;
      }

      .trend-up {
        color: #2ecc71;
      }

      .trend-down {
        color: #e74c3c;
      }

      .graph-toggle {
        background-color: #f2f2f2;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
        font-size: 0.9em;
        transition: background-color 0.3s ease;
      }

      .graph-toggle:hover {
        background-color: #e0e0e0;
      }

      .graph-wrapper {
        display: none;
        width: 100%;
        overflow-x: auto;
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .graph-wrapper.active {
        display: block;
      }

      .graph-wrapper canvas {
        width: 100% !important;
        height: 200px !important;
      }

      /* 期間選択のスタイル */
      .period-selector {
        margin: 10px 0;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: #fff;
        font-size: 0.9em;
      }

      .period-selector:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
      }

      /* 予測グラフのスタイル */
      .prediction-graph {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .prediction-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .prediction-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
      }

      .prediction-controls {
        display: flex;
        gap: 10px;
      }

      .prediction-period {
        padding: 5px 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: white;
      }

      .prediction-info {
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .prediction-trend {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.9em;
      }

      .prediction-trend.up {
        color: #2ecc71;
      }

      .prediction-trend.down {
        color: #e74c3c;
      }

      .confidence-interval {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
      }

      /* モデル比較のスタイル */
      .model-comparison {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .comparison-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .comparison-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .comparison-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .model-selector {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 200px;
      }

      .comparison-period {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .comparison-graph {
        margin-top: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .comparison-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .model-stat-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .model-name {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .price-change {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
      }

      .price-change.positive {
        color: #2ecc71;
      }

      .price-change.negative {
        color: #e74c3c;
      }

      /* フィルターのスタイル */
      .filter-container {
        margin: 20px 0;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .filter-label {
        font-size: 0.9em;
        color: #666;
      }

      .filter-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 150px;
      }

      .filter-button {
        padding: 8px 16px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .filter-button:hover {
        background-color: #2980b9;
      }

      .filter-button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      /* 価格差のスタイル */
      .price-difference {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .price-difference-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .price-difference-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
      }

      .price-difference-content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .price-difference-card {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .price-difference-label {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
      }

      .price-difference-value {
        font-size: 1.2em;
        font-weight: bold;
      }

      .price-difference-value.positive {
        color: #2ecc71;
      }

      .price-difference-value.negative {
        color: #e74c3c;
      }

      /* レコメンデーションのスタイル */
      .recommendation-section {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .recommendation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .recommendation-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .recommendation-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .preference-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 150px;
      }

      .recommendation-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .recommendation-card {
        background-color: white;
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease;
      }

      .recommendation-card:hover {
        transform: translateY(-5px);
      }

      .recommendation-card.best {
        border: 2px solid #2ecc71;
      }

      .recommendation-card.good {
        border: 2px solid #3498db;
      }

      .recommendation-card.fair {
        border: 2px solid #f1c40f;
      }

      .recommendation-model {
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .recommendation-details {
        margin-top: 10px;
      }

      .recommendation-detail {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.9em;
      }

      .recommendation-label {
        color: #666;
      }

      .recommendation-value {
        font-weight: bold;
      }

      .recommendation-value.positive {
        color: #2ecc71;
      }

      .recommendation-value.negative {
        color: #e74c3c;
      }

      .recommendation-score {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
        text-align: right;
        font-size: 0.9em;
        color: #666;
      }

      /* 予測期間選択のスタイル */
      .prediction-period-select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: white;
        font-size: 0.9em;
        margin-left: 10px;
      }

      /* 購入タイミング提案のスタイル */
      .purchase-timing {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 4px;
      }

      .purchase-timing-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .purchase-timing-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .purchase-timing-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .purchase-timing-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .purchase-timing-card {
        background-color: white;
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .purchase-timing-card.best {
        border: 2px solid #2ecc71;
      }

      .purchase-timing-card.good {
        border: 2px solid #3498db;
      }

      .purchase-timing-card.fair {
        border: 2px solid #f1c40f;
      }

      .purchase-timing-model {
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .purchase-timing-details {
        margin-top: 10px;
      }

      .purchase-timing-detail {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.9em;
      }

      .purchase-timing-label {
        color: #666;
      }

      .purchase-timing-value {
        font-weight: bold;
      }

      .purchase-timing-value.positive {
        color: #2ecc71;
      }

      .purchase-timing-value.negative {
        color: #e74c3c;
      }

      .purchase-timing-recommendation {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #666;
      }

      .purchase-timing-score {
        text-align: right;
        font-size: 0.8em;
        color: #999;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container mt-4">
      <h1 class="mb-4">iPhone価格比較</h1>

      <!-- 価格アラート設定セクション -->
      <div class="card mb-4">
        <div class="card-header">
          <h5 class="mb-0">価格アラート設定</h5>
        </div>
        <div class="card-body">
          <form id="alertForm">
            <div class="form-group">
              <label for="alertThreshold">アラート閾値（円）</label>
              <input
                type="number"
                class="form-control"
                id="alertThreshold"
                required
              />
            </div>
            <button type="submit" class="btn btn-primary mt-3">
              アラートを設定
            </button>
          </form>
        </div>
      </div>

      <!-- 価格比較セクション -->
      <div id="content">
        <div id="priceTablesContainer" class="tables-container">
          <!-- iPhone 16 -->
          <div class="series-section">
            <h2>iPhone 16</h2>
            <div class="table-wrapper">
              <table id="iPhone16-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16 Pro -->
          <div class="series-section">
            <h2>iPhone 16 Pro</h2>
            <div class="table-wrapper">
              <table id="iPhone16Pro-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16 Pro Max -->
          <div class="series-section">
            <h2>iPhone 16 Pro Max</h2>
            <div class="table-wrapper">
              <table id="iPhone16ProMax-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- iPhone 16e -->
          <div class="series-section">
            <h2>iPhone 16e</h2>
            <div class="table-wrapper">
              <table id="iPhone16e-prices" class="price-table">
                <thead>
                  <tr>
                    <th>容量</th>
                    <th>公式価格</th>
                    <th>買取価格</th>
                    <th>収支</th>
                    <th>楽天錬金時収支</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const API_ENDPOINT =
          'https://l8l7v5xw9d.execute-api.ap-northeast-1.amazonaws.com/prod/get_prices';
        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16 e',
        ];

        // ローディング状態を管理する要素
        const loadingElement = document.getElementById('loading');
        const contentElement = document.getElementById('content');
        const priceTablesContainer = document.getElementById(
          'priceTablesContainer'
        );

        // データ取得と表示の処理
        async function fetchPrices() {
          try {
            // ローディング表示
            if (loadingElement) loadingElement.style.display = 'block';
            if (contentElement) contentElement.style.display = 'none';

            const results = await Promise.all(
              series.map(series =>
                fetch(
                  `${API_ENDPOINT}?series=${encodeURIComponent(series)}`
                ).then(response => {
                  if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                  }
                  return response.json();
                })
              )
            );

            console.log('Raw response data from Lambda:', results);

            results.forEach((data, index) => {
              if (data && data.data) {
                const seriesName = Object.keys(data.data)[0];
                const priceData = data.data[seriesName];

                const tableId = seriesName.replace(/\s+/g, '') + '-prices';
                const tableBody = document.querySelector(`#${tableId} tbody`);

                if (tableBody && priceData) {
                  // DocumentFragment を使用
                  const fragment = document.createDocumentFragment();

                  // 容量配列の作成（既存のソートロジックを維持）
                  const capacities = Array.from(
                    new Set([
                      ...Object.keys(priceData.official || {}),
                      ...Object.keys(priceData.kaitori || {}),
                    ])
                  ).sort((a, b) => {
                    const [aNum, aUnit] = a.match(/(\d+)(GB|TB)/).slice(1);
                    const [bNum, bUnit] = b.match(/(\d+)(GB|TB)/).slice(1);
                    const aValue =
                      aUnit === 'TB' ? parseInt(aNum) * 1024 : parseInt(aNum);
                    const bValue =
                      bUnit === 'TB' ? parseInt(bNum) * 1024 : parseInt(bNum);
                    return aValue - bValue;
                  });

                  // 一度のループで全ての行を生成
                  capacities.forEach(capacity => {
                    const row = document.createElement('tr');
                    const officialPrice = parseInt(
                      priceData.official?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const kaitoriPrice = parseInt(
                      priceData.kaitori?.[capacity]?.replace(/,/g, '') || '0'
                    );
                    const priceDiff = kaitoriPrice - officialPrice;
                    const rakutenPriceDiff = kaitoriPrice - officialPrice * 0.9;

                    row.innerHTML = `
                      <td>${capacity}</td>
                      <td>¥${officialPrice.toLocaleString()}</td>
                      <td>¥${kaitoriPrice.toLocaleString()}</td>
                      <td class="${
                        priceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${priceDiff.toLocaleString()}
                      </td>
                      <td class="${
                        rakutenPriceDiff > 0
                          ? 'price-diff-positive'
                          : 'price-diff-negative'
                      }">
                        ¥${Math.round(rakutenPriceDiff).toLocaleString()}
                      </td>
                    `;
                    fragment.appendChild(row);
                  });

                  // まとめてDOM更新
                  tableBody.innerHTML = '';
                  tableBody.appendChild(fragment);
                }
              }
            });

            // データ表示後にテーブルを表示
            if (priceTablesContainer)
              priceTablesContainer.style.display = 'flex';
          } catch (error) {
            console.error('Fetch Error:', error);
            // エラーメッセージを表示
            const errorElement = document.getElementById('error-message');
            if (errorElement) {
              errorElement.textContent = `データの取得に失敗しました: ${error.message}`;
              errorElement.style.display = 'block';
            }
          } finally {
            // ローディング非表示
            if (loadingElement) loadingElement.style.display = 'none';
            if (contentElement) contentElement.style.display = 'block';
          }
        }

        // 初期データ取得
        fetchPrices();
      });

      // 価格履歴グラフの実装
      const priceHistoryCharts = {};

      function formatDate(timestamp) {
        const date = new Date(timestamp * 1000);
        return `${date.getMonth() + 1}/${date.getDate()}`;
      }

      function createPriceHistoryGraph(series, capacity, color) {
        const modelId = `${series}-${capacity}-${color}`;
        const graphContainer = document.createElement('div');
        graphContainer.className = 'graph-wrapper';
        graphContainer.id = `graph-${modelId}`;

        // 期間選択ドロップダウンを追加
        const periodSelector = document.createElement('select');
        periodSelector.className = 'period-selector';
        periodSelector.innerHTML = `
          <option value="7">過去1週間</option>
          <option value="14" selected>過去2週間</option>
          <option value="30">過去1ヶ月</option>
          <option value="90">過去3ヶ月</option>
        `;
        periodSelector.onchange = () => {
          fetchPriceHistory(
            series,
            capacity,
            color,
            parseInt(periodSelector.value)
          );
        };

        graphContainer.appendChild(periodSelector);

        const canvas = document.createElement('canvas');
        graphContainer.appendChild(canvas);

        // 統計情報コンテナを追加
        const statsContainer = document.createElement('div');
        statsContainer.className = 'stats-container';
        statsContainer.id = `stats-${modelId}`;
        graphContainer.appendChild(statsContainer);

        // 予測グラフコンテナを追加
        const predictionContainer = document.createElement('div');
        predictionContainer.className = 'prediction-graph';
        predictionContainer.id = `prediction-${modelId}`;

        const predictionHeader = document.createElement('div');
        predictionHeader.className = 'prediction-header';

        const predictionTitle = document.createElement('div');
        predictionTitle.className = 'prediction-title';
        predictionTitle.textContent = '価格予測';

        const predictionControls = document.createElement('div');
        predictionControls.className = 'prediction-controls';

        const predictionPeriod = document.createElement('select');
        predictionPeriod.className = 'prediction-period';
        predictionPeriod.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriod.onchange = () => {
          fetchPricePrediction(modelId, parseInt(predictionPeriod.value));
        };

        predictionControls.appendChild(predictionPeriod);
        predictionHeader.appendChild(predictionTitle);
        predictionHeader.appendChild(predictionControls);
        predictionContainer.appendChild(predictionHeader);

        const predictionCanvas = document.createElement('canvas');
        predictionContainer.appendChild(predictionCanvas);

        const predictionInfo = document.createElement('div');
        predictionInfo.className = 'prediction-info';
        predictionInfo.id = `prediction-info-${modelId}`;
        predictionContainer.appendChild(predictionInfo);

        graphContainer.appendChild(predictionContainer);

        const table = document.getElementById(`${series}-prices`);
        const row = table.querySelector(
          `tr[data-capacity="${capacity}"][data-color="${color}"]`
        );
        if (row) {
          row.parentNode.insertBefore(graphContainer, row.nextSibling);
        }

        const ctx = canvas.getContext('2d');
        priceHistoryCharts[modelId] = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: '買取価格',
                data: [],
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                borderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6,
                pointBackgroundColor: 'rgb(75, 192, 192)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgb(75, 192, 192)',
                tension: 0.3,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 1000,
              easing: 'easeInOutQuart',
              onComplete: function () {
                const chart = this;
                const ctx = chart.ctx;
                ctx.save();
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                chart.data.datasets.forEach((dataset, i) => {
                  const meta = chart.getDatasetMeta(i);
                  meta.data.forEach((point, index) => {
                    const data = dataset.data[index];
                    ctx.fillText(
                      '¥' + data.toLocaleString(),
                      point.x,
                      point.y - 5
                    );
                  });
                });
                ctx.restore();
              },
            },
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleFont: {
                  size: 14,
                  weight: 'bold',
                },
                bodyFont: {
                  size: 12,
                },
                padding: 12,
                callbacks: {
                  title: function (context) {
                    const date = new Date(context[0].label);
                    return date.toLocaleDateString('ja-JP', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      weekday: 'long',
                    });
                  },
                  label: function (context) {
                    const value = context.parsed.y;
                    const index = context.dataIndex;
                    const dataset = context.dataset.data;
                    const previousValue = index > 0 ? dataset[index - 1] : null;

                    let label = `買取価格: ¥${value.toLocaleString()}`;

                    if (previousValue) {
                      const diff = value - previousValue;
                      const percentage = ((diff / previousValue) * 100).toFixed(
                        1
                      );
                      const diffText =
                        diff > 0
                          ? `+¥${diff.toLocaleString()}`
                          : `-¥${Math.abs(diff).toLocaleString()}`;
                      const percentageText =
                        diff > 0 ? `+${percentage}%` : `${percentage}%`;

                      label += `\n前回比: ${diffText} (${percentageText})`;
                    }

                    return label;
                  },
                  footer: function (context) {
                    const index = context[0].dataIndex;
                    const dataset = context[0].dataset.data;
                    const value = context[0].parsed.y;

                    if (index > 0) {
                      const previousValue = dataset[index - 1];
                      const diff = value - previousValue;
                      const percentage = ((diff / previousValue) * 100).toFixed(
                        1
                      );

                      if (diff > 0) {
                        return '価格が上昇しています';
                      } else if (diff < 0) {
                        return '価格が下落しています';
                      } else {
                        return '価格に変化はありません';
                      }
                    }
                    return '';
                  },
                },
              },
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)',
                },
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
              x: {
                grid: {
                  display: false,
                },
              },
            },
            interaction: {
              mode: 'nearest',
              axis: 'x',
              intersect: false,
            },
          },
        });

        // 予測グラフの初期化
        const predictionCtx = predictionCanvas.getContext('2d');
        pricePredictionCharts[modelId] = new Chart(predictionCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: '予測価格',
                data: [],
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                borderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6,
                tension: 0.3,
                fill: true,
              },
              {
                label: '信頼区間（上限）',
                data: [],
                borderColor: 'rgba(255, 99, 132, 0.3)',
                borderWidth: 1,
                pointRadius: 0,
                borderDash: [5, 5],
                fill: false,
              },
              {
                label: '信頼区間（下限）',
                data: [],
                borderColor: 'rgba(255, 99, 132, 0.3)',
                borderWidth: 1,
                pointRadius: 0,
                borderDash: [5, 5],
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    const value = context.parsed.y;
                    return `${
                      context.dataset.label
                    }: ¥${value.toLocaleString()}`;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
            },
          },
        });

        return graphContainer;
      }

      function updateStats(modelId, data) {
        const statsContainer = document.getElementById(`stats-${modelId}`);
        if (!statsContainer || !data || data.length === 0) return;

        const prices = data.map(item => item.price);
        const timestamps = data.map(item => item.timestamp);

        // 基本統計量の計算
        const maxPrice = Math.max(...prices);
        const minPrice = Math.min(...prices);
        const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;

        // 標準偏差の計算
        const variance =
          prices.reduce(
            (acc, price) => acc + Math.pow(price - avgPrice, 2),
            0
          ) / prices.length;
        const stdDev = Math.sqrt(variance);

        // トレンドの計算（単純な線形回帰）
        const n = prices.length;
        const sumX = timestamps.reduce((a, b) => a + b, 0);
        const sumY = prices.reduce((a, b) => a + b, 0);
        const sumXY = timestamps.reduce((acc, x, i) => acc + x * prices[i], 0);
        const sumX2 = timestamps.reduce((acc, x) => acc + x * x, 0);

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const trend = slope > 0 ? '上昇' : '下落';
        const trendClass = slope > 0 ? 'trend-up' : 'trend-down';

        // 統計情報の表示
        statsContainer.innerHTML = `
          <div class="stat-card">
            <div class="stat-title">最高価格</div>
            <div class="stat-value">¥${maxPrice.toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">最低価格</div>
            <div class="stat-value">¥${minPrice.toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">平均価格</div>
            <div class="stat-value">¥${Math.round(
              avgPrice
            ).toLocaleString()}</div>
            <div class="stat-change">標準偏差: ¥${Math.round(
              stdDev
            ).toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">価格トレンド</div>
            <div class="stat-value">
              ${trend}
              <span class="trend-indicator ${trendClass}">
                ${slope > 0 ? '↑' : '↓'}
              </span>
            </div>
            <div class="stat-change">
              1日あたりの変化: ¥${Math.abs(
                Math.round(slope * 86400)
              ).toLocaleString()}
            </div>
          </div>
        `;
      }

      async function fetchPriceHistory(series, capacity, color, days = 14) {
        const modelId = `${series}-${capacity}-${color}`;
        try {
          const response = await fetch(
            `/price-history?model=${modelId}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          const chart = priceHistoryCharts[modelId];
          if (chart) {
            chart.data.labels = data.map(item => formatDate(item.timestamp));
            chart.data.datasets[0].data = data.map(item => item.price);
            chart.update();

            // 統計情報を更新
            updateStats(modelId, data);
          }
        } catch (error) {
          console.error('Error fetching price history:', error);
          const errorMessage = document.createElement('div');
          errorMessage.className = 'error-message';
          errorMessage.textContent = '価格履歴の取得に失敗しました';
          const graphWrapper = document.getElementById(`graph-${modelId}`);
          if (graphWrapper) {
            graphWrapper.appendChild(errorMessage);
          }
        }
      }

      function addGraphToggle(series, capacity, color) {
        const modelId = `${series}-${capacity}-${color}`;
        const table = document.getElementById(`${series}-prices`);
        const row = table.querySelector(
          `tr[data-capacity="${capacity}"][data-color="${color}"]`
        );

        if (row) {
          const toggleButton = document.createElement('button');
          toggleButton.className = 'graph-toggle';
          toggleButton.textContent = '価格推移を表示';
          toggleButton.onclick = () => {
            const graphWrapper = document.getElementById(`graph-${modelId}`);
            if (!graphWrapper) {
              createPriceHistoryGraph(series, capacity, color);
              fetchPriceHistory(series, capacity, color);
            }
            graphWrapper.classList.toggle('active');
            toggleButton.textContent = graphWrapper.classList.contains('active')
              ? '価格推移を隠す'
              : '価格推移を表示';
          };

          // 新しいセルを作成してボタンを追加
          const newCell = document.createElement('td');
          newCell.appendChild(toggleButton);
          row.appendChild(newCell);
        }
      }

      // 既存のテーブル作成処理を修正
      function createTable(series, data) {
        // ... existing table creation code ...

        // 各行にグラフトグルを追加
        Object.entries(data).forEach(([capacity, colors]) => {
          Object.entries(colors).forEach(([color, price]) => {
            addGraphToggle(series, capacity, color);
          });
        });
      }

      async function fetchPricePrediction(modelId, days = 7) {
        try {
          const response = await fetch(
            `/predict-prices?model=${modelId}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          if (data.error) {
            throw new Error(data.error);
          }

          const chart = pricePredictionCharts[modelId];
          if (chart) {
            // 予測データの更新
            chart.data.labels = data.predictions.map(p => p.date);
            chart.data.datasets[0].data = data.predictions.map(
              p => p.predicted_price
            );
            chart.data.datasets[1].data = data.predictions.map(
              p => p.predicted_price + p.confidence_interval
            );
            chart.data.datasets[2].data = data.predictions.map(
              p => p.predicted_price - p.confidence_interval
            );
            chart.update();

            // 予測情報の更新
            const predictionInfo = document.getElementById(
              `prediction-info-${modelId}`
            );
            if (predictionInfo) {
              const trendClass =
                data.trend === 'up' ? 'trend-up' : 'trend-down';
              const trendIcon = data.trend === 'up' ? '↑' : '↓';

              predictionInfo.innerHTML = `
                <div class="prediction-trend ${trendClass}">
                  <span>予測トレンド: ${data.trend}</span>
                  <span>${trendIcon}</span>
                </div>
                <div class="confidence-interval">
                  信頼区間: ±¥${data.predictions[0].confidence_interval.toLocaleString()}
                </div>
              `;
            }
          }
        } catch (error) {
          console.error('Error fetching price prediction:', error);
          const predictionInfo = document.getElementById(
            `prediction-info-${modelId}`
          );
          if (predictionInfo) {
            predictionInfo.innerHTML = `
              <div style="color: red;">
                予測データの取得に失敗しました
              </div>
            `;
          }
        }
      }

      // モデル比較の実装
      const comparisonCharts = {};
      let selectedModels = [];

      function createModelComparison() {
        const comparisonContainer = document.createElement('div');
        comparisonContainer.className = 'model-comparison';
        comparisonContainer.id = 'model-comparison';

        const header = document.createElement('div');
        header.className = 'comparison-header';

        const title = document.createElement('div');
        title.className = 'comparison-title';
        title.textContent = 'モデル比較';

        const controls = document.createElement('div');
        controls.className = 'comparison-controls';

        // モデル選択用のマルチセレクト
        const modelSelector = document.createElement('select');
        modelSelector.className = 'model-selector';
        modelSelector.multiple = true;
        modelSelector.size = 4;

        // 期間選択
        const periodSelector = document.createElement('select');
        periodSelector.className = 'comparison-period';
        periodSelector.innerHTML = `
          <option value="7">過去1週間</option>
          <option value="14">過去2週間</option>
          <option value="30" selected>過去1ヶ月</option>
          <option value="90">過去3ヶ月</option>
        `;

        // 比較ボタン
        const compareButton = document.createElement('button');
        compareButton.className = 'graph-toggle';
        compareButton.textContent = '比較する';
        compareButton.onclick = () => {
          selectedModels = Array.from(modelSelector.selectedOptions).map(
            option => option.value
          );
          if (selectedModels.length >= 2) {
            fetchComparisonData(selectedModels, parseInt(periodSelector.value));
          } else {
            alert('比較するには2つ以上のモデルを選択してください');
          }
        };

        controls.appendChild(modelSelector);
        controls.appendChild(periodSelector);
        controls.appendChild(compareButton);
        header.appendChild(title);
        header.appendChild(controls);
        comparisonContainer.appendChild(header);

        // グラフコンテナ
        const graphContainer = document.createElement('div');
        graphContainer.className = 'comparison-graph';
        graphContainer.id = 'comparison-graph';
        comparisonContainer.appendChild(graphContainer);

        // 統計情報コンテナ
        const statsContainer = document.createElement('div');
        statsContainer.className = 'comparison-stats';
        statsContainer.id = 'comparison-stats';
        comparisonContainer.appendChild(statsContainer);

        document.body.appendChild(comparisonContainer);

        // モデル選択肢の更新
        updateModelSelector(modelSelector);
      }

      function updateModelSelector(selector) {
        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16e',
        ];
        const capacities = ['128GB', '256GB', '512GB', '1TB'];
        const colors = ['黒', '白', '桃', '緑', '青', '金', '灰'];

        selector.innerHTML = '';
        series.forEach(s => {
          capacities.forEach(cap => {
            colors.forEach(color => {
              const modelId = `${s}-${cap}-${color}`;
              const option = document.createElement('option');
              option.value = modelId;
              option.textContent = `${s} ${cap} ${color}`;
              selector.appendChild(option);
            });
          });
        });
      }

      async function fetchComparisonData(modelIds, days) {
        try {
          const response = await fetch(
            `/compare-prices?models=${modelIds.join(',')}&days=${days}`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          updateComparisonGraph(data);
          updateComparisonStats(data);
        } catch (error) {
          console.error('Error fetching comparison data:', error);
          const graphContainer = document.getElementById('comparison-graph');
          if (graphContainer) {
            graphContainer.innerHTML = `
              <div style="color: red; padding: 10px;">
                比較データの取得に失敗しました
              </div>
            `;
          }
        }
      }

      function updateComparisonGraph(data) {
        const graphContainer = document.getElementById('comparison-graph');
        if (!graphContainer) return;

        const canvas = document.createElement('canvas');
        graphContainer.innerHTML = '';
        graphContainer.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        const datasets = [];

        const colors = [
          'rgb(255, 99, 132)',
          'rgb(54, 162, 235)',
          'rgb(255, 206, 86)',
          'rgb(75, 192, 192)',
          'rgb(153, 102, 255)',
          'rgb(255, 159, 64)',
        ];

        Object.entries(data).forEach(([modelId, modelData], index) => {
          const color = colors[index % colors.length];
          datasets.push({
            label: modelId,
            data: modelData.price_history.map(item => item.price),
            borderColor: color,
            backgroundColor: color
              .replace('rgb', 'rgba')
              .replace(')', ', 0.1)'),
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            tension: 0.3,
            fill: true,
          });
        });

        new Chart(ctx, {
          type: 'line',
          data: {
            labels: data[Object.keys(data)[0]].price_history.map(item =>
              new Date(item.date).toLocaleDateString('ja-JP')
            ),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    return `${
                      context.dataset.label
                    }: ¥${context.parsed.y.toLocaleString()}`;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  callback: function (value) {
                    return '¥' + value.toLocaleString();
                  },
                },
              },
            },
          },
        });
      }

      function updateComparisonStats(data) {
        const statsContainer = document.getElementById('comparison-stats');
        if (!statsContainer) return;

        statsContainer.innerHTML = '';
        Object.entries(data).forEach(([modelId, modelData]) => {
          const statCard = document.createElement('div');
          statCard.className = 'model-stat-card';

          const priceChange = modelData.price_change;
          const changeClass = priceChange > 0 ? 'positive' : 'negative';
          const changeIcon = priceChange > 0 ? '↑' : '↓';

          statCard.innerHTML = `
            <div class="model-name">${modelId}</div>
            <div>現在価格: ¥${modelData.current_price.toLocaleString()}</div>
            <div>平均価格: ¥${modelData.avg_price.toLocaleString()}</div>
            <div>最高価格: ¥${modelData.max_price.toLocaleString()}</div>
            <div>最低価格: ¥${modelData.min_price.toLocaleString()}</div>
            <div class="price-change ${changeClass}">
              価格変動: ${Math.abs(priceChange).toFixed(1)}% ${changeIcon}
            </div>
          `;

          statsContainer.appendChild(statCard);
        });
      }

      // ページ読み込み時にモデル比較UIを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createModelComparison();
      });

      // フィルタリング機能の実装
      let currentFilters = {
        series: null,
        capacity: null,
        color: null,
      };

      function createFilterControls() {
        const filterContainer = document.createElement('div');
        filterContainer.className = 'filter-container';
        filterContainer.id = 'filter-container';

        // シリーズフィルター
        const seriesGroup = document.createElement('div');
        seriesGroup.className = 'filter-group';
        seriesGroup.innerHTML = `
          <label class="filter-label">シリーズ</label>
          <select class="filter-select" id="series-filter">
            <option value="">すべて</option>
            <option value="iPhone 16">iPhone 16</option>
            <option value="iPhone 16 Pro">iPhone 16 Pro</option>
            <option value="iPhone 16 Pro Max">iPhone 16 Pro Max</option>
            <option value="iPhone 16e">iPhone 16e</option>
          </select>
        `;

        // 容量フィルター
        const capacityGroup = document.createElement('div');
        capacityGroup.className = 'filter-group';
        capacityGroup.innerHTML = `
          <label class="filter-label">容量</label>
          <select class="filter-select" id="capacity-filter">
            <option value="">すべて</option>
            <option value="128GB">128GB</option>
            <option value="256GB">256GB</option>
            <option value="512GB">512GB</option>
            <option value="1TB">1TB</option>
          </select>
        `;

        // 色フィルター
        const colorGroup = document.createElement('div');
        colorGroup.className = 'filter-group';
        colorGroup.innerHTML = `
          <label class="filter-label">色</label>
          <select class="filter-select" id="color-filter">
            <option value="">すべて</option>
            <option value="黒">黒</option>
            <option value="白">白</option>
            <option value="桃">桃</option>
            <option value="緑">緑</option>
            <option value="青">青</option>
            <option value="金">金</option>
            <option value="灰">灰</option>
          </select>
        `;

        // フィルター適用ボタン
        const applyButton = document.createElement('button');
        applyButton.className = 'filter-button';
        applyButton.textContent = 'フィルターを適用';
        applyButton.onclick = applyFilters;

        // フィルターリセットボタン
        const resetButton = document.createElement('button');
        resetButton.className = 'filter-button';
        resetButton.textContent = 'リセット';
        resetButton.onclick = resetFilters;

        filterContainer.appendChild(seriesGroup);
        filterContainer.appendChild(capacityGroup);
        filterContainer.appendChild(colorGroup);
        filterContainer.appendChild(applyButton);
        filterContainer.appendChild(resetButton);

        document.body.insertBefore(
          filterContainer,
          document.getElementById('content')
        );

        // フィルターの初期状態を設定
        document
          .getElementById('series-filter')
          .addEventListener('change', updateFilterState);
        document
          .getElementById('capacity-filter')
          .addEventListener('change', updateFilterState);
        document
          .getElementById('color-filter')
          .addEventListener('change', updateFilterState);
      }

      function updateFilterState() {
        currentFilters = {
          series: document.getElementById('series-filter').value,
          capacity: document.getElementById('capacity-filter').value,
          color: document.getElementById('color-filter').value,
        };
      }

      function applyFilters() {
        const tables = document.querySelectorAll('.price-table');
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');
          let hasVisibleRows = false;

          rows.forEach(row => {
            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const isVisible =
              (!currentFilters.series ||
                series.includes(currentFilters.series)) &&
              (!currentFilters.capacity ||
                capacity === currentFilters.capacity) &&
              (!currentFilters.color || color === currentFilters.color);

            row.style.display = isVisible ? '' : 'none';
            if (isVisible) hasVisibleRows = true;
          });

          // テーブル全体の表示/非表示
          const tableContainer = table.closest('.series-section');
          if (tableContainer) {
            tableContainer.style.display = hasVisibleRows ? '' : 'none';
          }
        });

        // モデル比較セレクターの更新
        updateModelSelector(document.querySelector('.model-selector'));
      }

      function resetFilters() {
        document.getElementById('series-filter').value = '';
        document.getElementById('capacity-filter').value = '';
        document.getElementById('color-filter').value = '';
        currentFilters = { series: null, capacity: null, color: null };

        // すべての行を表示
        const rows = document.querySelectorAll('.price-table tbody tr');
        rows.forEach(row => (row.style.display = ''));

        // すべてのテーブルを表示
        const tables = document.querySelectorAll('.series-section');
        tables.forEach(table => (table.style.display = ''));

        // モデル比較セレクターの更新
        updateModelSelector(document.querySelector('.model-selector'));
      }

      function updateModelSelector(selector) {
        if (!selector) return;

        const series = [
          'iPhone 16',
          'iPhone 16 Pro',
          'iPhone 16 Pro Max',
          'iPhone 16e',
        ];
        const capacities = ['128GB', '256GB', '512GB', '1TB'];
        const colors = ['黒', '白', '桃', '緑', '青', '金', '灰'];

        selector.innerHTML = '';
        series.forEach(s => {
          if (currentFilters.series && !s.includes(currentFilters.series))
            return;

          capacities.forEach(cap => {
            if (currentFilters.capacity && cap !== currentFilters.capacity)
              return;

            colors.forEach(color => {
              if (currentFilters.color && color !== currentFilters.color)
                return;

              const modelId = `${s}-${cap}-${color}`;
              const option = document.createElement('option');
              option.value = modelId;
              option.textContent = `${s} ${cap} ${color}`;
              selector.appendChild(option);
            });
          });
        });
      }

      // ページ読み込み時にフィルターコントロールを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createFilterControls();
      });

      // 価格差の計算と表示機能
      function createPriceDifferenceSection() {
        const priceDifferenceContainer = document.createElement('div');
        priceDifferenceContainer.className = 'price-difference';
        priceDifferenceContainer.id = 'price-difference';

        const header = document.createElement('div');
        header.className = 'price-difference-header';

        const title = document.createElement('div');
        title.className = 'price-difference-title';
        title.textContent = '価格差の比較';

        const refreshButton = document.createElement('button');
        refreshButton.className = 'filter-button';
        refreshButton.textContent = '更新';
        refreshButton.onclick = updatePriceDifferences;

        header.appendChild(title);
        header.appendChild(refreshButton);
        priceDifferenceContainer.appendChild(header);

        const content = document.createElement('div');
        content.className = 'price-difference-content';
        content.id = 'price-difference-content';
        priceDifferenceContainer.appendChild(content);

        document.body.appendChild(priceDifferenceContainer);
      }

      function updatePriceDifferences() {
        const content = document.getElementById('price-difference-content');
        if (!content) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 価格差の計算と表示
        content.innerHTML = '';

        // 最大価格差
        const maxDiff = Object.values(priceData).reduce((max, item) =>
          Math.abs(item.difference) > Math.abs(max.difference) ? item : max
        );

        const maxDiffCard = document.createElement('div');
        maxDiffCard.className = 'price-difference-card';
        maxDiffCard.innerHTML = `
          <div class="price-difference-label">最大価格差</div>
          <div class="price-difference-value ${
            maxDiff.difference >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(maxDiff.difference).toLocaleString()}
            <span>(${maxDiff.differencePercentage}%)</span>
          </div>
          <div>${maxDiff.series} ${maxDiff.capacity} ${maxDiff.color}</div>
        `;
        content.appendChild(maxDiffCard);

        // 最小価格差
        const minDiff = Object.values(priceData).reduce((min, item) =>
          Math.abs(item.difference) < Math.abs(min.difference) ? item : min
        );

        const minDiffCard = document.createElement('div');
        minDiffCard.className = 'price-difference-card';
        minDiffCard.innerHTML = `
          <div class="price-difference-label">最小価格差</div>
          <div class="price-difference-value ${
            minDiff.difference >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(minDiff.difference).toLocaleString()}
            <span>(${minDiff.differencePercentage}%)</span>
          </div>
          <div>${minDiff.series} ${minDiff.capacity} ${minDiff.color}</div>
        `;
        content.appendChild(minDiffCard);

        // 平均価格差
        const avgDiff =
          Object.values(priceData).reduce(
            (sum, item) => sum + item.difference,
            0
          ) / Object.keys(priceData).length;
        const avgDiffPercentage = (
          (avgDiff / Object.values(priceData)[0].officialPrice) *
          100
        ).toFixed(1);

        const avgDiffCard = document.createElement('div');
        avgDiffCard.className = 'price-difference-card';
        avgDiffCard.innerHTML = `
          <div class="price-difference-label">平均価格差</div>
          <div class="price-difference-value ${
            avgDiff >= 0 ? 'positive' : 'negative'
          }">
            ¥${Math.abs(avgDiff).toLocaleString()}
            <span>(${avgDiffPercentage}%)</span>
          </div>
        `;
        content.appendChild(avgDiffCard);

        // 価格差の分布
        const positiveCount = Object.values(priceData).filter(
          item => item.difference > 0
        ).length;
        const negativeCount = Object.values(priceData).filter(
          item => item.difference < 0
        ).length;
        const zeroCount = Object.values(priceData).filter(
          item => item.difference === 0
        ).length;

        const distributionCard = document.createElement('div');
        distributionCard.className = 'price-difference-card';
        distributionCard.innerHTML = `
          <div class="price-difference-label">価格差の分布</div>
          <div>プラス: ${positiveCount}件</div>
          <div>マイナス: ${negativeCount}件</div>
          <div>変化なし: ${zeroCount}件</div>
        `;
        content.appendChild(distributionCard);
      }

      // ページ読み込み時に価格差セクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createPriceDifferenceSection();
        updatePriceDifferences();
      });

      // レコメンデーション機能の実装
      function createRecommendationSection() {
        const recommendationContainer = document.createElement('div');
        recommendationContainer.className = 'recommendation-section';
        recommendationContainer.id = 'recommendation-section';

        const header = document.createElement('div');
        header.className = 'recommendation-header';

        const title = document.createElement('div');
        title.className = 'recommendation-title';
        title.textContent = 'おすすめモデル';

        const controls = document.createElement('div');
        controls.className = 'recommendation-controls';

        // 優先条件の選択
        const prioritySelect = document.createElement('select');
        prioritySelect.className = 'preference-select';
        prioritySelect.id = 'priority-select';
        prioritySelect.innerHTML = `
          <option value="price">価格差を優先</option>
          <option value="capacity">容量を優先</option>
          <option value="color">色を優先</option>
          <option value="balance">バランス重視</option>
        `;

        // 予測期間の選択
        const predictionPeriodSelect = document.createElement('select');
        predictionPeriodSelect.className = 'prediction-period-select';
        predictionPeriodSelect.id = 'prediction-period-select';
        predictionPeriodSelect.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriodSelect.onchange = updateRecommendations;

        // 更新ボタン
        const updateButton = document.createElement('button');
        updateButton.className = 'filter-button';
        updateButton.textContent = '更新';
        updateButton.onclick = updateRecommendations;

        controls.appendChild(prioritySelect);
        controls.appendChild(predictionPeriodSelect);
        controls.appendChild(updateButton);
        header.appendChild(title);
        header.appendChild(controls);
        recommendationContainer.appendChild(header);

        // レコメンデーションカードのコンテナ
        const cardsContainer = document.createElement('div');
        cardsContainer.className = 'recommendation-cards';
        cardsContainer.id = 'recommendation-cards';
        recommendationContainer.appendChild(cardsContainer);

        document.body.appendChild(recommendationContainer);
      }

      function calculateRecommendationScore(
        model,
        priority,
        predictionData = null
      ) {
        let score = 0;
        const maxScore = 100;

        // 価格差のスコア（最大40点）
        const priceDiff = model.difference;
        const priceScore = Math.min(40, Math.abs(priceDiff) / 10000);
        score += priceScore;

        // 容量のスコア（最大30点）
        const capacityScore =
          {
            '128GB': 20,
            '256GB': 25,
            '512GB': 30,
            '1TB': 30,
          }[model.capacity] || 0;
        score += capacityScore;

        // 色のスコア（最大30点）
        const colorScore =
          {
            黒: 30,
            白: 25,
            青: 20,
            金: 20,
            灰: 15,
            緑: 15,
            桃: 10,
          }[model.color] || 0;
        score += colorScore;

        // 予測データがある場合、予測スコアを追加（最大20点）
        if (predictionData) {
          let predictionScore = 0;

          // トレンドによるスコア調整（最大10点）
          if (predictionData.trend === 'up') {
            predictionScore += 10; // 上昇トレンドは高評価
          } else if (predictionData.trend === 'down') {
            predictionScore += 5; // 下落トレンドは中評価
          }

          // 信頼区間によるスコア調整（最大10点）
          const confidenceInterval =
            predictionData.predictions[0].confidence_interval;
          const confidenceScore = Math.max(0, 10 - confidenceInterval / 10000);
          predictionScore += confidenceScore;

          score += predictionScore;
        }

        // 優先条件に応じてスコアを調整
        switch (priority) {
          case 'price':
            score = priceScore * 2.5;
            break;
          case 'capacity':
            score = capacityScore * 3.3;
            break;
          case 'color':
            score = colorScore * 3.3;
            break;
          // 'balance'の場合はデフォルトのスコアを使用
        }

        return Math.min(maxScore, Math.round(score));
      }

      async function updateRecommendations() {
        const priority = document.getElementById('priority-select').value;
        const predictionDays = parseInt(
          document.getElementById('prediction-period-select').value
        );
        const cardsContainer = document.getElementById('recommendation-cards');
        if (!cardsContainer) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 各モデルの予測データを取得
        const modelPredictions = {};
        for (const modelId in priceData) {
          try {
            const predictionData = await fetchPricePrediction(
              modelId,
              predictionDays
            );
            modelPredictions[modelId] = predictionData;
          } catch (error) {
            console.error(`Error fetching prediction for ${modelId}:`, error);
            modelPredictions[modelId] = null;
          }
        }

        // スコアの計算とソート（予測データを含む）
        const models = Object.values(priceData).map(model => {
          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          return {
            ...model,
            score: calculateRecommendationScore(
              model,
              priority,
              modelPredictions[modelId]
            ),
          };
        });

        models.sort((a, b) => b.score - a.score);

        // レコメンデーションカードの表示
        cardsContainer.innerHTML = '';
        models.slice(0, 3).forEach((model, index) => {
          const card = document.createElement('div');
          card.className = `recommendation-card ${
            index === 0 ? 'best' : index === 1 ? 'good' : 'fair'
          }`;

          const scoreClass =
            model.score >= 80 ? 'best' : model.score >= 60 ? 'good' : 'fair';
          const scoreText =
            model.score >= 80
              ? '最適'
              : model.score >= 60
              ? 'おすすめ'
              : '検討';

          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];

          // 価格予測情報の表示
          const predictionInfo = document.createElement('div');
          predictionInfo.className = 'prediction-info';

          if (predictionData && predictionData.trend) {
            const trendClass = predictionData.trend === 'up' ? 'up' : 'down';
            const trendIcon = predictionData.trend === 'up' ? '↑' : '↓';

            predictionInfo.innerHTML = `
              <div class="prediction-trend ${trendClass}">
                <span>予測トレンド: ${
                  predictionData.trend === 'up' ? '上昇' : '下落'
                }</span>
                <span>${trendIcon}</span>
              </div>
              <div class="confidence-interval">
                信頼区間: ±¥${predictionData.predictions[0].confidence_interval.toLocaleString()}
              </div>
              <div class="prediction-period">
                予測期間: ${predictionDays}日後まで
              </div>
            `;
          } else {
            predictionInfo.innerHTML = `
              <div style="color: #666; font-size: 0.9em;">
                予測データが利用できません
              </div>
            `;
          }

          card.appendChild(predictionInfo);

          card.innerHTML += `
            <div class="recommendation-model">${model.series} ${
            model.capacity
          } ${model.color}</div>
            <div class="recommendation-details">
              <div class="recommendation-detail">
                <span class="recommendation-label">公式価格</span>
                <span class="recommendation-value">¥${model.officialPrice.toLocaleString()}</span>
              </div>
              <div class="recommendation-detail">
                <span class="recommendation-label">買取価格</span>
                <span class="recommendation-value">¥${model.kaitoriPrice.toLocaleString()}</span>
              </div>
              <div class="recommendation-detail">
                <span class="recommendation-label">価格差</span>
                <span class="recommendation-value ${
                  model.difference >= 0 ? 'positive' : 'negative'
                }">
                  ¥${Math.abs(model.difference).toLocaleString()} (${
            model.differencePercentage
          }%)
                </span>
              </div>
            </div>
            <div class="recommendation-score">
              評価: ${scoreText} (スコア: ${model.score}/100)
            </div>
          `;

          cardsContainer.appendChild(card);
        });
      }

      // ページ読み込み時にレコメンデーションセクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createRecommendationSection();
        updateRecommendations();
      });

      function createPurchaseTimingSection() {
        const purchaseTimingContainer = document.createElement('div');
        purchaseTimingContainer.className = 'purchase-timing';
        purchaseTimingContainer.id = 'purchase-timing';

        const header = document.createElement('div');
        header.className = 'purchase-timing-header';

        const title = document.createElement('div');
        title.className = 'purchase-timing-title';
        title.textContent = '購入タイミングの提案';

        const controls = document.createElement('div');
        controls.className = 'purchase-timing-controls';

        // 予測期間の選択
        const predictionPeriodSelect = document.createElement('select');
        predictionPeriodSelect.className = 'prediction-period-select';
        predictionPeriodSelect.id = 'purchase-timing-period-select';
        predictionPeriodSelect.innerHTML = `
          <option value="7">7日後まで</option>
          <option value="14">14日後まで</option>
          <option value="30">30日後まで</option>
        `;
        predictionPeriodSelect.onchange = updatePurchaseTiming;

        // 更新ボタン
        const updateButton = document.createElement('button');
        updateButton.className = 'filter-button';
        updateButton.textContent = '更新';
        updateButton.onclick = updatePurchaseTiming;

        controls.appendChild(predictionPeriodSelect);
        controls.appendChild(updateButton);
        header.appendChild(title);
        header.appendChild(controls);
        purchaseTimingContainer.appendChild(header);

        // 提案カードのコンテナ
        const cardsContainer = document.createElement('div');
        cardsContainer.className = 'purchase-timing-cards';
        cardsContainer.id = 'purchase-timing-cards';
        purchaseTimingContainer.appendChild(cardsContainer);

        document.body.appendChild(purchaseTimingContainer);
      }

      function calculatePurchaseTimingScore(predictionData) {
        let score = 0;
        const maxScore = 100;

        if (!predictionData || !predictionData.predictions) {
          return 0;
        }

        // トレンドによるスコア（最大40点）
        if (predictionData.trend === 'down') {
          score += 40; // 下落トレンドは高評価
        } else if (predictionData.trend === 'up') {
          score += 20; // 上昇トレンドは中評価
        }

        // 信頼区間によるスコア（最大30点）
        const confidenceInterval =
          predictionData.predictions[0].confidence_interval;
        const confidenceScore = Math.max(0, 30 - confidenceInterval / 10000);
        score += confidenceScore;

        // 価格変動の安定性によるスコア（最大30点）
        const prices = predictionData.predictions.map(p => p.predicted_price);
        const priceChanges = [];
        for (let i = 1; i < prices.length; i++) {
          priceChanges.push(Math.abs(prices[i] - prices[i - 1]));
        }
        const avgPriceChange =
          priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length;
        const stabilityScore = Math.max(0, 30 - avgPriceChange / 1000);
        score += stabilityScore;

        return Math.min(maxScore, Math.round(score));
      }

      function getPurchaseTimingRecommendation(score, predictionData) {
        if (score >= 80) {
          return {
            timing: '今すぐ購入',
            reason: '価格が下落傾向で、信頼性の高い予測が示されています。',
            urgency: 'high',
          };
        } else if (score >= 60) {
          return {
            timing: '近日中に購入',
            reason: '価格が安定傾向で、購入の好機と判断されます。',
            urgency: 'medium',
          };
        } else if (score >= 40) {
          return {
            timing: '様子見',
            reason:
              '価格変動が予想されるため、しばらく様子を見ることをお勧めします。',
            urgency: 'low',
          };
        } else {
          return {
            timing: '購入を待機',
            reason: '価格が上昇傾向で、購入を待つことをお勧めします。',
            urgency: 'wait',
          };
        }
      }

      async function updatePurchaseTiming() {
        const predictionDays = parseInt(
          document.getElementById('purchase-timing-period-select').value
        );
        const cardsContainer = document.getElementById('purchase-timing-cards');
        if (!cardsContainer) return;

        const tables = document.querySelectorAll('.price-table');
        const priceData = {};

        // 価格データの収集
        tables.forEach(table => {
          const series = table.id.split('-')[0];
          const rows = table.querySelectorAll('tbody tr');

          rows.forEach(row => {
            if (row.style.display === 'none') return;

            const capacity = row.cells[0].textContent;
            const color = row.cells[1].textContent;
            const officialPrice = parseInt(
              row.cells[2].textContent.replace(/[^0-9]/g, '')
            );
            const kaitoriPrice = parseInt(
              row.cells[3].textContent.replace(/[^0-9]/g, '')
            );

            const modelId = `${series}-${capacity}-${color}`;
            priceData[modelId] = {
              series,
              capacity,
              color,
              officialPrice,
              kaitoriPrice,
              difference: kaitoriPrice - officialPrice,
              differencePercentage: (
                ((kaitoriPrice - officialPrice) / officialPrice) *
                100
              ).toFixed(1),
            };
          });
        });

        // 各モデルの予測データを取得
        const modelPredictions = {};
        for (const modelId in priceData) {
          try {
            const predictionData = await fetchPricePrediction(
              modelId,
              predictionDays
            );
            modelPredictions[modelId] = predictionData;
          } catch (error) {
            console.error(`Error fetching prediction for ${modelId}:`, error);
            modelPredictions[modelId] = null;
          }
        }

        // スコアの計算とソート
        const models = Object.values(priceData).map(model => {
          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];
          const score = calculatePurchaseTimingScore(predictionData);
          const recommendation = getPurchaseTimingRecommendation(
            score,
            predictionData
          );

          return {
            ...model,
            score,
            recommendation,
            predictionData,
          };
        });

        models.sort((a, b) => b.score - a.score);

        // 提案カードの表示
        cardsContainer.innerHTML = '';
        models.slice(0, 3).forEach((model, index) => {
          const card = document.createElement('div');
          card.className = `purchase-timing-card ${model.recommendation.urgency}`;

          const modelId = `${model.series}-${model.capacity}-${model.color}`;
          const predictionData = modelPredictions[modelId];

          card.innerHTML = `
            <div class="purchase-timing-model">${model.series} ${
            model.capacity
          } ${model.color}</div>
            <div class="purchase-timing-details">
              <div class="purchase-timing-detail">
                <span class="purchase-timing-label">現在の価格差</span>
                <span class="purchase-timing-value ${
                  model.difference >= 0 ? 'positive' : 'negative'
                }">
                  ¥${Math.abs(model.difference).toLocaleString()} (${
            model.differencePercentage
          }%)
                </span>
              </div>
              ${
                predictionData
                  ? `
                <div class="purchase-timing-detail">
                  <span class="purchase-timing-label">予測トレンド</span>
                  <span class="purchase-timing-value ${
                    predictionData.trend === 'down' ? 'positive' : 'negative'
                  }">
                    ${predictionData.trend === 'down' ? '下落傾向' : '上昇傾向'}
                  </span>
                </div>
                <div class="purchase-timing-detail">
                  <span class="purchase-timing-label">予測信頼度</span>
                  <span class="purchase-timing-value">
                    ${Math.round(
                      (1 -
                        predictionData.predictions[0].confidence_interval /
                          model.kaitoriPrice) *
                        100
                    )}%
                  </span>
                </div>
              `
                  : ''
              }
            </div>
            <div class="purchase-timing-recommendation">
              <strong>推奨アクション:</strong> ${
                model.recommendation.timing
              }<br>
              <strong>理由:</strong> ${model.recommendation.reason}
            </div>
            <div class="purchase-timing-score">
              提案スコア: ${model.score}/100
            </div>
          `;

          cardsContainer.appendChild(card);
        });
      }

      // ページ読み込み時に購入タイミングセクションを初期化
      document.addEventListener('DOMContentLoaded', function () {
        createPurchaseTimingSection();
        updatePurchaseTiming();
      });

      // 価格アラート設定の処理
      document
        .getElementById('alertForm')
        .addEventListener('submit', async function (e) {
          e.preventDefault();
          const threshold = document.getElementById('alertThreshold').value;

          try {
            const response = await fetch('/set-alert', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ threshold: threshold }),
            });

            if (response.ok) {
              alert('アラートを設定しました');
            } else {
              alert('アラートの設定に失敗しました');
            }
          } catch (error) {
            console.error('Error:', error);
            alert('エラーが発生しました');
          }
        });

      function updatePriceDisplay(series, capacity, data) {
        const container = document.getElementById(`${series}-${capacity}`);
        if (!container) return;

        const kaitoriMin = data.kaitori_price_min;
        const kaitoriMax = data.kaitori_price_max;
        const officialPrice = data.official_price;
        const profitMin = kaitoriMin - officialPrice;
        const profitMax = kaitoriMax - officialPrice;

        // 価格表示の更新
        container.querySelector(
          '.kaitori-price'
        ).textContent = `${kaitoriMin.toLocaleString()}円 〜 ${kaitoriMax.toLocaleString()}円`;
        container.querySelector(
          '.official-price'
        ).textContent = `${officialPrice.toLocaleString()}円`;
        container.querySelector(
          '.profit'
        ).textContent = `${profitMin.toLocaleString()}円 〜 ${profitMax.toLocaleString()}円`;

        // 色ごとの価格を更新
        const colorPricesContainer = container.querySelector('.color-prices');
        colorPricesContainer.innerHTML = '';

        Object.entries(data.colors).forEach(([color, priceInfo]) => {
          const colorDiv = document.createElement('div');
          colorDiv.className = 'color-price';
          colorDiv.innerHTML = `
                <span class="color-name">${color}</span>
                <span class="color-value">${priceInfo.price_text}</span>
            `;
          colorPricesContainer.appendChild(colorDiv);
        });

        // 利益率の計算と表示
        const profitRateMin = ((profitMin / officialPrice) * 100).toFixed(1);
        const profitRateMax = ((profitMax / officialPrice) * 100).toFixed(1);
        container.querySelector(
          '.profit-rate'
        ).textContent = `${profitRateMin}% 〜 ${profitRateMax}%`;

        // 利益率に応じた色付け
        const profitRateElement = container.querySelector('.profit-rate');
        const avgProfitRate =
          (parseFloat(profitRateMin) + parseFloat(profitRateMax)) / 2;

        if (avgProfitRate >= 20) {
          profitRateElement.className = 'profit-rate high-profit';
        } else if (avgProfitRate >= 10) {
          profitRateElement.className = 'profit-rate medium-profit';
        } else {
          profitRateElement.className = 'profit-rate low-profit';
        }
      }
    </script>
  </body>
</html>
</file>

<file path=".github/workflows/renovate.yaml">
name: renovate
on:
  workflow_dispatch:
  schedule:
    # JST Runs every Saturday at 9:00 a.m.
    - cron: '0 0 * * 6'

env:
  RENOVATE_REPOSITORIES: ${{ github.repository }}
  RENOVATE_USERNAME: ${{ github.repository_owner }}
  RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>'

jobs:
  renovate:
    runs-on: ubuntu-latest

    steps:
      - name: Generate token
        id: get_token
        uses: tibdex/github-app-token@v1
        with:
          app_id: ${{ secrets.RENOVATE_APP_ID }}
          private_key: ${{ secrets.RENOVATE_ACCESS_TOKEN }}

      - name: Output token
        env:
          TOKEN: ${{ steps.get_token.outputs.token }}
        run: |
          echo "Access Token: ${TOKEN:4}"

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      - name: Self-hosted Renovate
        uses: renovatebot/github-action@v41.0.22
        with:
          configurationFile: renovate.json
          token: 'x-access-token:${{ steps.get_token.outputs.token }}'
        env:
          RENOVATE_USERNAME: ${{ env.RENOVATE_USERNAME }}
          RENOVATE_GIT_AUTHOR: ${{ env.RENOVATE_GIT_AUTHOR }}
          RENOVATE_REPOSITORIES: ${{ env.RENOVATE_REPOSITORIES }}
</file>

<file path="tests/conftest.py">
import os
import shutil
import sys
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
import yaml

# プロジェクトのルートディレクトリをPythonパスに追加
project_root = str(Path(__file__).parent.parent)
sys.path.insert(0, project_root)

# 環境変数の設定
os.environ["PYTHONPATH"] = project_root

# テスト用の設定
def pytest_configure(config):
    config.addinivalue_line(
        "markers", "integration: mark test as integration test"
    )

@pytest.fixture(scope="function")
def mock_env_vars(monkeypatch):
    """環境変数をモックするフィクスチャ"""
    test_vars = {
        "FLASK_ENV": "testing",
        "SECRET_KEY": "test-secret-key-16ch",  # 16文字以上に変更
        "LOG_LEVEL": "DEBUG"
    }
    for key, value in test_vars.items():
        monkeypatch.setenv(key, value)
    return test_vars

@pytest.fixture
def mock_config():
    """Mock configuration for the scraper."""
    return {
        'scraper': {
            'selectors': {
                'price_item': '.price-item',
                'model': '.model',
                'price': '.price',
                'condition': '.condition'
            },
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            },
            'max_retries': 3,
            'timeout': 30,
            'cache_duration': 3600
        }
    }

@pytest.fixture
def mock_cache_dir(tmp_path):
    """Create a temporary cache directory."""
    cache_dir = tmp_path / "cache"
    cache_dir.mkdir()
    return cache_dir

@pytest.fixture
def mock_response():
    """Mock HTTP response with HTML content."""
    response = type('Response', (), {})()
    response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro 256GB</div>
        <div class="price">150000</div>
        <div class="condition">新品</div>
    </div>
    <div class="price-item">
        <div class="model">iPhone 15 Pro Max 512GB</div>
        <div class="price">180000</div>
        <div class="condition">中古</div>
    </div>
    """
    return response

@pytest.fixture
def test_config_file(mock_config):
    """Create a temporary YAML configuration file."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
        yaml.dump(mock_config, f)
        return Path(f.name)

@pytest.fixture(autouse=True)
def setup_test_env():
    """Set up test environment."""
    # Create test configuration file
    config_dir = Path("src/lambda_functions/get_prices_lambda/config")
    config_dir.mkdir(parents=True, exist_ok=True)
    
    test_config = {
        'scraper': {
            'selectors': {
                'price_item': '.price-item',
                'model': '.model',
                'price': '.price',
                'condition': '.condition'
            },
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'ja,en-US;q=0.7,en;q=0.3',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1'
            },
            'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'max_retries': 3,
            'timeout': 30,
            'cache_duration': 3600
        },
        'urls': {
            'kaitori': ['https://example.com/kaitori'],
            'official': ['https://example.com/official']
        }
    }
    
    with open(config_dir / "config.test.yaml", 'w') as f:
        yaml.dump(test_config, f)
    
    yield
    
    # Cleanup
    if (config_dir / "config.test.yaml").exists():
        (config_dir / "config.test.yaml").unlink()
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# ... existing code ...
artifacts/lambda/*
!artifacts/lambda/function_latest.zip
# ... existing code ...
# Python Lambda dependencies
terraform/lambda/*/
!terraform/lambda/*/*.py
!terraform/lambda/*/requirements.txt


# Terraform
*.tfstate
*.tfstate.*
*.tfstate.backup
*.tfstate.1746368792.backup
.terraform/
.terraform.lock.hcl
tfplan
terraform/layer/*

# Lambda deployment packages
*.zip
lambda_function.zip
layer.zip

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
.pytest_cache/
.coverage
coverage.xml

# Node
node_modules/
package-lock.json

# Temporary files
*.bak
*.backup
dynamodb_local/
cache/
</file>

<file path="terraform/iam.tf">
# Lambda実行用のIAMロール
resource "aws_iam_role" "lambda_execution_role" {
  name = "lambda_execution_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = {
    Name        = "lambda_execution_role"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# Lambda実行ロールに基本的な権限を付与
resource "aws_iam_role_policy_attachment" "lambda_execution_basic" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Lambda実行ロールにSQS権限を付与
resource "aws_iam_role_policy" "lambda_sqs_policy" {
  name = "lambda_sqs_policy"
  role = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "sqs:SendMessage",
          "sqs:ReceiveMessage",
          "sqs:DeleteMessage",
          "sqs:GetQueueAttributes"
        ]
        Resource = [
          aws_sqs_queue.lambda_dlq.arn
        ]
      }
    ]
  })
}

# Lambda実行用のIAMロール
resource "aws_iam_role" "get_prices_lambda_role" {
  name = "get_prices_lambda_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  lifecycle {
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "get_prices_lambda_role"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 基本的なLambda実行権限
resource "aws_iam_role_policy_attachment" "lambda_basic" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.get_prices_lambda_role.name
}

# DynamoDB アクセス用のポリシー
resource "aws_iam_role_policy" "dynamodb_access" {
  name = "dynamodb_access"
  role = aws_iam_role.get_prices_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Scan",
          "dynamodb:Query",
          "dynamodb:BatchGetItem",
          "dynamodb:BatchWriteItem"
        ]
        Resource = [
          aws_dynamodb_table.iphone_prices.arn,
          aws_dynamodb_table.official_prices.arn,
          aws_dynamodb_table.price_history.arn,
          aws_dynamodb_table.price_predictions.arn
        ]
      }
    ]
  })
}

# GitHub Actions用のIAMロール
resource "aws_iam_role" "github_actions" {
  name = "github-actions-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRoleWithWebIdentity"
        Effect = "Allow"
        Principal = {
          Federated = "arn:aws:iam::273354647319:oidc-provider/token.actions.githubusercontent.com"
        }
        Condition = {
          StringLike = {
            "token.actions.githubusercontent.com:sub" = "repo:PheasantDevil/priceComparisonAppForIphone:*"
          }
        }
      }
    ]
  })
}

resource "aws_iam_policy" "github_actions_policy" {
  name = "github_actions_policy"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "lambda:UpdateFunctionCode",
          "lambda:GetFunction",
          "lambda:InvokeFunction",
          "dynamodb:DescribeTable",
          "dynamodb:Scan",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:GetItem",
          "dynamodb:Query",
          "dynamodb:BatchWriteItem",
          "dynamodb:BatchGetItem"
        ]
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "github_actions_custom" {
  role       = aws_iam_role.github_actions.name
  policy_arn = aws_iam_policy.github_actions_policy.arn
}

resource "aws_iam_role_policy" "github_actions_terraform" {
  name = "github_actions_terraform"
  role = aws_iam_role.github_actions.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "iam:GetRole",
          "iam:CreateRole",
          "iam:DeleteRole",
          "iam:PutRolePolicy",
          "iam:DeleteRolePolicy",
          "iam:PassRole",
          "iam:CreatePolicy",
          "iam:DeletePolicy",
          "iam:AttachRolePolicy",
          "iam:DetachRolePolicy",
          "iam:GetPolicy",
          "iam:GetPolicyVersion",
          "iam:CreatePolicyVersion",
          "iam:DeletePolicyVersion",
          "iam:ListPolicyVersions",
          "iam:ListAttachedRolePolicies",
          "iam:ListRolePolicies",
          "iam:ListRoles",
          "iam:ListPolicies",
          "iam:GetRolePolicy",
          "iam:PutRolePolicy",
          "iam:DeleteRolePolicy",
          "iam:UpdateRole",
          "iam:UpdateRoleDescription",
          "iam:UpdateAssumeRolePolicy",
          "iam:TagRole",
          "iam:UntagRole",
          "iam:ListRoleTags",
          "iam:ListPolicyTags",
          "iam:TagPolicy",
          "iam:UntagPolicy",
          "iam:GetRole",
          "iam:GetPolicy",
          "iam:GetPolicyVersion",
          "iam:GetRolePolicy",
          "iam:ListRolePolicies",
          "iam:ListAttachedRolePolicies",
          "iam:ListPolicyVersions",
          "iam:ListRoles",
          "iam:ListPolicies",
          "iam:ListPolicyTags",
          "iam:ListRoleTags",
          "iam:PassRole",
          "iam:CreateRole",
          "iam:DeleteRole",
          "iam:PutRolePolicy",
          "iam:DeleteRolePolicy",
          "iam:CreatePolicy",
          "iam:DeletePolicy",
          "iam:AttachRolePolicy",
          "iam:DetachRolePolicy",
          "iam:CreatePolicyVersion",
          "iam:DeletePolicyVersion",
          "iam:UpdateRole",
          "iam:UpdateRoleDescription",
          "iam:UpdateAssumeRolePolicy",
          "iam:TagRole",
          "iam:UntagRole",
          "iam:TagPolicy",
          "iam:UntagPolicy"
        ]
        Resource = "*"
      }
    ]
  })
}

# デプロイメント検証用のIAMロール
resource "aws_iam_role" "deployment_verification" {
  name = "deployment-verification-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = {
    Name        = "deployment-verification-role"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# デプロイメント検証用のポリシー
resource "aws_iam_role_policy" "deployment_verification_policy" {
  name = "deployment_verification_policy"
  role = aws_iam_role.deployment_verification.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "lambda:GetFunction",
          "lambda:InvokeFunction",
          "dynamodb:DescribeTable",
          "dynamodb:Scan",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:GetItem",
          "dynamodb:Query",
          "dynamodb:BatchWriteItem",
          "dynamodb:BatchGetItem"
        ]
        Resource = "*"
      }
    ]
  })
}

# 価格履歴用のDynamoDBポリシー
resource "aws_iam_role_policy" "price_history_dynamodb_policy" {
  name = "price_history_dynamodb_policy"
  role = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Scan",
          "dynamodb:Query",
          "dynamodb:BatchGetItem",
          "dynamodb:BatchWriteItem"
        ]
        Resource = [
          aws_dynamodb_table.price_history.arn,
          aws_dynamodb_table.price_predictions.arn
        ]
      }
    ]
  })
}

# スモークテスト用のIAMロール
resource "aws_iam_role" "smoke_test" {
  name = "smoke-test-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = {
    Name        = "smoke-test-role"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# スモークテストロールに基本的な権限を付与
resource "aws_iam_role_policy_attachment" "smoke_test_basic" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.smoke_test.name
}

# スモークテスト用のカスタムポリシー
resource "aws_iam_role_policy" "smoke_test_policy" {
  name = "smoke_test_policy"
  role = aws_iam_role.smoke_test.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "lambda:GetFunction",
          "lambda:InvokeFunction",
          "dynamodb:DescribeTable",
          "dynamodb:Scan",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:GetItem",
          "dynamodb:Query",
          "dynamodb:BatchWriteItem",
          "dynamodb:BatchGetItem"
        ]
        Resource = "*"
      }
    ]
  })
}
</file>

<file path="terraform/main.tf">
terraform {
  required_version = ">= 1.0.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "4.67.0"
    }
    archive = {
      source  = "hashicorp/archive"
      version = "2.7.0"
    }
  }
}

provider "archive" {}

# 現在のAWSアカウントIDを取得
data "aws_caller_identity" "current" {}

# 現在のリージョンを取得
data "aws_region" "current" {}

# CloudWatch Eventsルール
resource "aws_cloudwatch_event_rule" "check_prices" {
  name                = "check-prices"
  description         = "定期的に価格をチェックする"
  schedule_expression = "rate(1 hour)"
}

resource "aws_cloudwatch_event_target" "check_prices" {
  rule      = aws_cloudwatch_event_rule.check_prices.name
  target_id = "CheckPrices"
  arn       = aws_lambda_function.check_prices_lambda.arn
}

resource "aws_lambda_permission" "cloudwatch" {
  statement_id  = "AllowCloudWatchInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.check_prices_lambda.function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.check_prices.arn
}

# IAM OpenID Connect Provider for GitHub Actions
resource "aws_iam_openid_connect_provider" "github_actions" {
  url             = "https://token.actions.githubusercontent.com"
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = ["6938fd4d98bab03faadb97b34396831e3780aea1"]
}
</file>

<file path="tests/unit/test_scraper.py">
import json
import os
import sys
import time
from concurrent.futures import Future, ThreadPoolExecutor
from datetime import datetime, timedelta, timezone
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch

import pytest
import requests
from bs4 import BeautifulSoup
from requests.exceptions import RequestException, Timeout

# プロジェクトのルートディレクトリをPythonパスに追加
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from src.lambda_functions.get_prices_lambda.scraper import (
    MAX_WORKERS, TIMEOUT, CacheError, CacheManager, ErrorHandler,
    ErrorSeverity, HTTPError, ParseError, PerformanceMetrics,
    PerformanceTracker, PriceData, Scraper, ScraperError, ValidationError,
    validate_price_data)


# テスト用のフィクスチャ
@pytest.fixture
def mock_response():
    response = Mock()
    response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro</div>
        <div class="price">120000</div>
        <div class="condition">新品</div>
    </div>
    """
    response.status_code = 200
    return response

@pytest.fixture
def mock_config():
    return {
        'headers': {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        },
        'urls': {
            'kaitori': ['https://www.apple.com/jp/shop/buy-iphone'],
            'official': ['https://www.apple.com/jp/shop/buy-iphone']
        },
        'timeout': 30,
        'max_retries': 3,
        'selectors': {
            'condition': '.condition',
            'model': '.model',
            'price': '.price',
            'price_item': '.price-item'
        }
    }

@pytest.fixture
def mock_scraper(mock_config, mock_response):
    """Create a mock Scraper instance with mocked dependencies"""
    scraper = Scraper(config=mock_config)
    scraper.session = MagicMock()
    scraper.session.get.return_value = mock_response
    scraper.cache_manager = MagicMock()
    scraper.cache_manager.get_cached_data.return_value = None
    scraper.error_handler = MagicMock()
    scraper.performance_tracker = MagicMock()
    return scraper

def test_scraper_initialization():
    """Scraperクラスの初期化テスト"""
    scraper = Scraper()
    assert isinstance(scraper.cache_manager, CacheManager)
    assert isinstance(scraper.error_handler, ErrorHandler)
    assert isinstance(scraper.performance_tracker, PerformanceTracker)

def test_get_kaitori_prices(mock_scraper, mock_response):
    """Test getting kaitori prices."""
    with patch('requests.get', return_value=mock_response):
        prices = mock_scraper.get_kaitori_prices()
        assert isinstance(prices, list)
        assert len(prices) > 0
        assert all(isinstance(p, PriceData) for p in prices)
        assert all(p.source == 'kaitori' for p in prices)

def test_get_official_prices(mock_scraper, mock_response):
    """Test getting official prices."""
    with patch('requests.get', return_value=mock_response):
        prices = mock_scraper.get_official_prices()
        assert isinstance(prices, list)
        assert len(prices) > 0
        assert all(isinstance(p, PriceData) for p in prices)
        assert all(p.source == 'official' for p in prices)

def test_scrape_url(mock_scraper, mock_response):
    """Test scraping a single URL"""
    url = "https://example.com"
    source = "kaitori"
    
    result = mock_scraper.scrape_url(url, source)
    
    assert isinstance(result, list)
    assert len(result) > 0
    assert all(isinstance(item, dict) for item in result)
    assert all('model' in item and 'price' in item for item in result)
    mock_scraper.session.get.assert_called_once_with(url, timeout=mock_scraper.config.get('timeout', 30))

def test_scrape_urls(mock_scraper, mock_response):
    """Test scraping multiple URLs in parallel"""
    urls = ["https://example1.com", "https://example2.com"]
    source = "kaitori"
    
    results = mock_scraper.scrape_urls(urls, source)
    
    assert isinstance(results, list)
    assert len(results) == len(urls)
    assert all(isinstance(result, list) for result in results)
    assert mock_scraper.session.get.call_count == len(urls)

def test_parse_response(mock_scraper, mock_response):
    """Test parsing response."""
    with patch('requests.get', return_value=mock_response):
        result = mock_scraper._parse_response(mock_response.text, 'test')
        assert isinstance(result, list)
        assert len(result) > 0
        assert all(isinstance(item, dict) for item in result)
        assert all('model' in item and 'price' in item for item in result)

def test_measure_request(mock_scraper):
    """Test measuring request duration."""
    start_time = time.time()
    mock_scraper.measure_request('https://example.com', start_time)
    assert isinstance(mock_scraper.performance_metrics['request_durations']['https://example.com'][0], float)

def test_record_cache_hit(mock_scraper):
    """Test recording cache hit."""
    mock_scraper.record_cache_hit('test')
    assert mock_scraper.performance_metrics['cache_hits']['test'] == 1

def test_record_cache_miss(mock_scraper):
    """Test recording cache miss."""
    mock_scraper.record_cache_miss('test')
    assert mock_scraper.performance_metrics['cache_misses']['test'] == 1

def test_start_scraping(mock_scraper):
    """Test starting scraping session."""
    mock_scraper.start_scraping()
    assert mock_scraper.performance_metrics['start_time'] is not None

def test_end_scraping(mock_scraper):
    """Test ending scraping session."""
    mock_scraper.start_scraping()
    mock_scraper.end_scraping()
    assert mock_scraper.performance_metrics['end_time'] is not None
    assert mock_scraper.performance_metrics['total_duration'] is not None

def test_get_kaitori_prices_success(mock_config, mock_response):
    """買取価格取得の成功テスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get', return_value=mock_response):
        prices = scraper.get_kaitori_prices()
        assert len(prices) > 0
        assert isinstance(prices[0], dict)
        assert 'model' in prices[0]
        assert 'price' in prices[0]

def test_get_kaitori_prices_retry(mock_config):
    """買取価格取得のリトライテスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get', side_effect=Exception("Connection error")):
        with pytest.raises(ScraperError) as exc_info:
            scraper.get_kaitori_prices()
        assert "買取価格の取得に失敗" in str(exc_info.value)

def test_price_data_validation():
    valid_data = {
        'model': 'iPhone 15',
        'price': 89800,
        'source': 'https://example.com',
        'timestamp': datetime.now()
    }
    assert validate_price_data(valid_data) is True

    with pytest.raises(ValueError):
        invalid_data = valid_data.copy()
        invalid_data['price'] = -1000
        validate_price_data(invalid_data)

    with pytest.raises(ValueError):
        invalid_data = valid_data.copy()
        invalid_data['source'] = 'not_a_url'
        validate_price_data(invalid_data)

def test_price_data_invalid_model():
    invalid_data = {
        'model': 'Invalid Model',
        'price': '120000',
        'source': 'test_source',
        'timestamp': datetime.now(timezone.utc)
    }
    with pytest.raises(ValueError):
        PriceData(**invalid_data)

@pytest.fixture
def mock_html_response():
    return """
    <div class="as-producttile">
        <span class="as-producttile-title">iPhone 15 Pro 256GB</span>
        <span class="as-price-currentprice">¥150,000</span>
    </div>
    <div class="as-producttile">
        <span class="as-producttile-title">iPhone 15 128GB</span>
        <span class="as-price-currentprice">¥120,000</span>
    </div>
    """

def test_get_official_prices_success(mock_config, mock_html_response):
    """公式価格取得の成功テスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get') as mock_get:
        # モックレスポンスの設定
        mock_response = MagicMock()
        mock_response.text = mock_html_response
        mock_get.return_value = mock_response
        
        # 関数の実行
        prices = scraper.get_official_prices()
        
        # 結果の検証
        assert len(prices) == 2
        assert prices[0]['model'] == "iPhone 15 Pro 256GB"
        assert prices[0]['price'] == 150000.0
        assert prices[0]['condition'] == "新品"
        assert prices[1]['model'] == "iPhone 15 128GB"
        assert prices[1]['price'] == 120000.0
        assert prices[1]['condition'] == "新品"

def test_get_official_prices_no_elements(mock_config):
    """公式価格取得の空要素テスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get') as mock_get:
        # 空のHTMLレスポンス
        mock_response = MagicMock()
        mock_response.text = "<html><body></body></html>"
        mock_get.return_value = mock_response
        
        # 関数の実行
        prices = scraper.get_official_prices()
        
        # 結果の検証
        assert len(prices) == 0

def test_get_official_prices_request_error(mock_config):
    """公式価格取得のリクエストエラーテスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get') as mock_get:
        # リクエストエラーをシミュレート
        mock_get.side_effect = HTTPError("Connection failed")
        
        # エラーが発生することを確認
        with pytest.raises(ScraperError) as exc_info:
            scraper.get_official_prices()
        
        assert "Failed to scrape Apple Store" in str(exc_info.value)

def test_get_official_prices_invalid_html(mock_config):
    """公式価格取得の無効なHTMLテスト"""
    scraper = Scraper(mock_config)
    with patch('requests.Session.get') as mock_get:
        # 無効なHTMLレスポンス
        mock_response = MagicMock()
        mock_response.text = "<div>Invalid HTML</div>"
        mock_get.return_value = mock_response
        
        # 関数の実行
        prices = scraper.get_official_prices()
        
        # 結果の検証
        assert len(prices) == 0

def test_scrape_url_performance_tracking(mock_scraper, mock_response):
    """Test performance tracking during URL scraping."""
    with patch('requests.get', return_value=mock_response):
        mock_scraper.start_scraping()
        result = mock_scraper.scrape_url('https://example.com', 'test')
        mock_scraper.end_scraping()
        
        assert mock_scraper.performance_metrics['start_time'] is not None
        assert mock_scraper.performance_metrics['end_time'] is not None
        assert mock_scraper.performance_metrics['total_duration'] is not None
        assert 'test' in mock_scraper.performance_metrics['request_durations']
        assert mock_scraper.performance_metrics['request_durations']['test'] > 0

def test_error_handling(mock_scraper):
    """Test error handling during scraping."""
    with patch('requests.get', side_effect=RequestException("Connection error")):
        with pytest.raises(HTTPError) as exc_info:
            mock_scraper.scrape_url('https://example.com', 'test')
        assert "Connection error" in str(exc_info.value)

def test_retry_mechanism(mock_scraper):
    """Test retry mechanism for failed requests."""
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro</div>
        <div class="price">120000</div>
        <div class="condition">新品</div>
    </div>
    """
    
    with patch('requests.get', side_effect=[RequestException("Temporary error"), mock_response]):
        result = mock_scraper.scrape_url('https://example.com', 'test')
        assert len(result) > 0

def test_cache_mechanism(mock_scraper, mock_response):
    """Test caching mechanism."""
    url = 'https://example.com'
    
    # First request - should miss cache
    with patch('requests.get', return_value=mock_response):
        result1 = mock_scraper.scrape_url(url, 'test')
        assert mock_scraper.performance_metrics['cache_misses']['test'] == 1
    
    # Second request - should hit cache
    with patch('requests.get', return_value=mock_response):
        result2 = mock_scraper.scrape_url(url, 'test')
        assert mock_scraper.performance_metrics['cache_hits']['test'] == 1
        assert result1 == result2

def test_concurrent_scraping(mock_scraper, mock_response):
    """Test concurrent scraping functionality."""
    urls = ['https://example1.com', 'https://example2.com']
    
    with patch('requests.get', return_value=mock_response):
        results = mock_scraper.scrape_urls(urls, 'test')
        assert len(results) == len(urls)
        assert all(isinstance(result, list) for result in results)
        assert all(len(result) > 0 for result in results)

def test_scrape_url_validation_error_handling(mock_config, mock_response):
    """検証エラーのハンドリングテスト"""
    mock_response.text = """
    <div class="tr">
        <h2>Invalid Model</h2>
        <div class="td2wrap">Invalid Price</div>
    </div>
    """
    with patch('requests.get', return_value=mock_response):
        prices = scrape_url('https://example.com/url1', mock_config)
        assert len(prices) == 0

def test_scrape_url_cache_error_handling(mock_config, mock_response):
    """キャッシュエラーのハンドリングテスト"""
    with patch('requests.get', return_value=mock_response), \
         patch.object(CacheManager, 'save_to_cache', side_effect=Exception("Cache error")):
        prices = scrape_url('https://example.com/url1', mock_config)
        assert len(prices) > 0  # キャッシュエラーでもデータは返す

def test_scrape_url_critical_error_handling(mock_config):
    """重大なエラーの連続発生時のハンドリングテスト"""
    with patch('requests.get', side_effect=HTTPError("Critical error")) as mock_get:
        # 3回連続でエラーを発生させる
        for _ in range(3):
            scrape_url('https://example.com/url1', mock_config)
        
        # 4回目は例外が発生するはず
        with pytest.raises(ScraperError) as exc_info:
            scrape_url('https://example.com/url1', mock_config)
        assert exc_info.value.severity == ErrorSeverity.HIGH

def test_error_severity_enum():
    """ErrorSeverity列挙型のテスト"""
    assert ErrorSeverity.LOW.value == "LOW"
    assert ErrorSeverity.MEDIUM.value == "MEDIUM"
    assert ErrorSeverity.HIGH.value == "HIGH"
    assert len(ErrorSeverity) == 3

def test_scraper_error_initialization():
    """ScraperErrorの初期化テスト"""
    error = ScraperError("Test error", ErrorSeverity.HIGH, {"key": "value"})
    assert str(error) == "Test error"
    assert error.severity == ErrorSeverity.HIGH
    assert error.context == {"key": "value"}
    assert isinstance(error.timestamp, datetime)
    assert error.error_id.startswith("ERR-")

def test_http_error_initialization():
    """HTTPErrorの初期化テスト"""
    error = HTTPError("Connection failed", 404, "https://example.com")
    assert error.severity == ErrorSeverity.HIGH
    assert error.context["status_code"] == 404
    assert error.context["url"] == "https://example.com"

def test_parse_error_initialization():
    """ParseErrorの初期化テスト"""
    html = "<div>test</div>" * 100  # 200文字以上のHTML
    error = ParseError("Parse failed", html, "div.test")
    assert error.severity == ErrorSeverity.MEDIUM
    assert len(error.context["html_snippet"]) == 200
    assert error.context["selector"] == "div.test"

def test_validation_error_initialization():
    """ValidationErrorの初期化テスト"""
    error = ValidationError("Invalid price", "price", 1000000)
    assert error.severity == ErrorSeverity.LOW
    assert error.context["field"] == "price"
    assert error.context["value"] == "1000000"

def test_cache_error_initialization():
    """CacheErrorの初期化テスト"""
    error = CacheError("Cache write failed", "save", Path("/test/cache.json"))
    assert error.severity == ErrorSeverity.LOW
    assert error.context["operation"] == "save"
    assert error.context["cache_path"] == "/test/cache.json"

def test_error_handler_initialization():
    """ErrorHandlerの初期化テスト"""
    handler = ErrorHandler()
    assert len(handler.errors) == 0
    assert handler.error_counts[ErrorSeverity.LOW] == 0
    assert handler.error_counts[ErrorSeverity.MEDIUM] == 0
    assert handler.error_counts[ErrorSeverity.HIGH] == 0

def test_error_handler_handle_error():
    """ErrorHandlerのエラー処理テスト"""
    handler = ErrorHandler()
    
    # 異なる重大度のエラーを追加
    handler.handle_error(ValidationError("Test error 1"))
    handler.handle_error(ParseError("Test error 2"))
    handler.handle_error(HTTPError("Test error 3"))
    
    assert len(handler.errors) == 3
    assert handler.error_counts[ErrorSeverity.LOW] == 1
    assert handler.error_counts[ErrorSeverity.MEDIUM] == 1
    assert handler.error_counts[ErrorSeverity.HIGH] == 1

def test_error_handler_get_summary():
    """Test error summary generation"""
    handler = ErrorHandler()
    handler.handle_error(ValidationError("Test error 1"))
    handler.handle_error(ParseError("Test error 2"))
    
    summary = handler.get_error_summary()
    assert summary['total_errors'] == 2
    assert summary['error_counts']['LOW'] == 1
    assert summary['error_counts']['MEDIUM'] == 1

def test_error_handler_should_continue():
    """ErrorHandlerの継続判断テスト"""
    handler = ErrorHandler()
    
    # HIGHレベルのエラーが2件までは継続可能
    for _ in range(2):
        handler.handle_error(HTTPError("Test error"))
    assert handler.should_continue() is True
    
    # HIGHレベルのエラーが3件以上で中断
    handler.handle_error(HTTPError("Test error"))
    assert handler.should_continue() is False

def test_scraper_consecutive_high_severity_errors():
    """連続した重大なエラーのテスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # 3回連続でHTTPエラーを発生させる
    with patch('requests.get', side_effect=HTTPError("Connection failed", 500, url)):
        for _ in range(3):
            scraper.scrape_url(url)
            
        # 4回目は例外が発生するはず
        with pytest.raises(ScraperError) as exc_info:
            scraper.scrape_url(url)
        assert exc_info.value.severity == ErrorSeverity.HIGH
        assert "Too many consecutive high severity errors" in str(exc_info.value)
        
def test_scraper_error_context():
    """エラーコンテキストのテスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # HTTPエラーのコンテキスト
    with patch('requests.get', side_effect=HTTPError("Connection failed", 404, url)):
        scraper.scrape_url(url)
        summary = scraper.get_summary()
        error = summary['errors']['recent_errors'][0]
        assert error['error_type'] == 'HTTPError'
        assert error['context']['status_code'] == 404
        assert error['context']['url'] == url
        
    # パースエラーのコンテキスト
    mock_response = MagicMock()
    mock_response.text = "<div>Invalid HTML</div>" * 100
    with patch('requests.get', return_value=mock_response):
        scraper.scrape_url(url)
        summary = scraper.get_summary()
        error = summary['errors']['recent_errors'][0]
        assert error['error_type'] == 'ParseError'
        assert len(error['context']['html_snippet']) == 200
        
def test_scraper_error_id_generation():
    """エラーIDの生成テスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    with patch('requests.get', side_effect=HTTPError("Connection failed", 404, url)):
        scraper.scrape_url(url)
        summary = scraper.get_summary()
        error = summary['errors']['recent_errors'][0]
        assert 'error_id' in error
        assert isinstance(error['error_id'], str)
        assert len(error['error_id']) > 0
        
def test_scraper_error_timestamp():
    """エラータイムスタンプのテスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    with patch('requests.get', side_effect=HTTPError("Connection failed", 404, url)):
        scraper.scrape_url(url)
        summary = scraper.get_summary()
        error = summary['errors']['recent_errors'][0]
        assert 'timestamp' in error['context']
        assert isinstance(error['context']['timestamp'], str)
        assert datetime.fromisoformat(error['context']['timestamp']).tzinfo is not None 

def test_scraper_performance_metrics():
    """Scraperクラスのパフォーマンスメトリクステスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # 成功ケースのテスト
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro 256GB</div>
        <div class="price">100,000</div>
        <div class="condition">新品</div>
    </div>
    """
    with patch('requests.get', return_value=mock_response):
        prices = scraper.scrape_url(url)
        summary = scraper.get_summary()
        assert summary['performance']['total_requests'] == 1
        assert summary['performance']['success_rate'] == 100.0
        assert summary['performance']['total_items_found'] == 1
        assert summary['performance']['avg_response_time'] > 0
        assert summary['performance']['min_response_time'] > 0
        assert summary['performance']['max_response_time'] > 0
        
    # 失敗ケースのテスト
    with patch('requests.get', side_effect=HTTPError("Connection failed", 404, url)):
        prices = scraper.scrape_url(url)
        summary = scraper.get_summary()
        assert summary['performance']['total_requests'] == 2
        assert summary['performance']['success_rate'] == 50.0
        assert summary['performance']['total_items_found'] == 1
        assert summary['performance']['error_rate'] == 50.0
        
def test_scraper_performance_metrics_multiple_requests():
    """複数リクエストのパフォーマンスメトリクステスト"""
    scraper = Scraper()
    urls = [
        "https://example.com/1",
        "https://example.com/2",
        "https://example.com/3"
    ]
    
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro 256GB</div>
        <div class="price">100,000</div>
        <div class="condition">新品</div>
    </div>
    """
    
    # 3つのURLに対してスクレイピングを実行
    with patch('requests.get', return_value=mock_response):
        for url in urls:
            scraper.scrape_url(url)
            
        summary = scraper.get_summary()
        assert summary['performance']['total_requests'] == 3
        assert summary['performance']['success_rate'] == 100.0
        assert summary['performance']['total_items_found'] == 3
        assert summary['performance']['avg_response_time'] > 0
        assert summary['performance']['median_response_time'] > 0
        assert summary['performance']['std_dev_response_time'] >= 0
        
def test_scraper_performance_metrics_timeout():
    """タイムアウト時のパフォーマンスメトリクステスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    def slow_response(*args, **kwargs):
        time.sleep(2)  # 2秒待機
        return MagicMock(text="<div>Response</div>")
        
    with patch('requests.get', side_effect=slow_response):
        with pytest.raises(requests.exceptions.Timeout):
            scraper.scrape_url(url)
            
        summary = scraper.get_summary()
        assert summary['performance']['total_requests'] == 1
        assert summary['performance']['success_rate'] == 0.0
        assert summary['performance']['total_items_found'] == 0
        assert summary['performance']['error_rate'] == 100.0
        assert summary['performance']['timeout_rate'] == 100.0
        
def test_scraper_performance_metrics_cache_hit():
    """キャッシュヒット時のパフォーマンスメトリクステスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # 最初のリクエスト（キャッシュミス）
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro 256GB</div>
        <div class="price">100,000</div>
        <div class="condition">新品</div>
    </div>
    """
    with patch('requests.get', return_value=mock_response):
        scraper.scrape_url(url)
        
    # 2回目のリクエスト（キャッシュヒット）
    with patch('requests.get', return_value=mock_response):
        scraper.scrape_url(url)
        
    summary = scraper.get_summary()
    assert summary['performance']['total_requests'] == 2
    assert summary['performance']['cache_hits'] == 1
    assert summary['performance']['cache_misses'] == 1
    assert summary['performance']['cache_hit_rate'] == 50.0
    
def test_scraper_performance_metrics_parallel_processing():
    """並列処理時のパフォーマンスメトリクステスト"""
    scraper = Scraper()
    urls = [
        "https://example.com/1",
        "https://example.com/2",
        "https://example.com/3"
    ]
    
    mock_response = MagicMock()
    mock_response.text = """
    <div class="price-item">
        <div class="model">iPhone 15 Pro 256GB</div>
        <div class="price">100,000</div>
        <div class="condition">新品</div>
    </div>
    """
    
    # 並列処理で3つのURLをスクレイピング
    with patch('requests.get', return_value=mock_response):
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = [executor.submit(scraper.scrape_url, url) for url in urls]
            for future in futures:
                future.result()
                
        summary = scraper.get_summary()
        assert summary['performance']['total_requests'] == 3
        assert summary['performance']['parallel_requests'] == 3
        assert summary['performance']['avg_parallel_workers'] == 3
        assert summary['performance']['total_execution_time'] > 0
        assert summary['performance']['parallel_efficiency'] > 0 

def test_cache_manager_initialization():
    """CacheManagerの初期化テスト"""
    cache_manager = CacheManager()
    assert cache_manager.cache_dir.exists()
    assert cache_manager.cache_duration == 3600  # デフォルトのキャッシュ期間（1時間）
    
    # カスタム設定での初期化
    custom_cache_dir = "test_cache"
    custom_duration = 1800  # 30分
    cache_manager = CacheManager(cache_dir=custom_cache_dir, cache_duration=custom_duration)
    assert cache_manager.cache_dir == Path(custom_cache_dir)
    assert cache_manager.cache_duration == custom_duration
    
def test_cache_path_generation():
    """キャッシュファイルパスの生成テスト"""
    cache_manager = CacheManager()
    url = "https://example.com/path?param=value"
    cache_path = cache_manager._get_cache_path(url)
    
    # URLから安全なファイル名が生成されているか
    assert cache_path.parent == cache_manager.cache_dir
    assert not any(c in cache_path.name for c in '/:?&')  # 特殊文字が除去されている
    assert cache_path.suffix == '.json'
    
def test_cache_validity():
    """キャッシュの有効期限テスト"""
    cache_manager = CacheManager(cache_duration=60)  # 1分のキャッシュ期間
    url = "https://example.com"
    cache_path = cache_manager._get_cache_path(url)
    
    # 有効なキャッシュ
    cache_data = [{'model': 'iPhone 15', 'price': 100000}]
    cache_manager.save_to_cache(url, cache_data)
    assert cache_manager._is_cache_valid(cache_path)
    
    # 期限切れのキャッシュ
    with patch('os.path.getmtime', return_value=time.time() - 120):  # 2分前
        assert not cache_manager._is_cache_valid(cache_path)
        
def test_cache_save_and_retrieve():
    """キャッシュの保存と取得テスト"""
    cache_manager = CacheManager()
    url = "https://example.com"
    test_data = [{
        'model': 'iPhone 15 Pro 256GB',
        'price': 150000,
        'source': url,
        'timestamp': datetime.now(timezone.utc),
        'condition': '新品'
    }]
    
    # データの保存
    cache_manager.save_to_cache(url, test_data)
    assert cache_manager._get_cache_path(url).exists()
    
    # データの取得
    retrieved_data = cache_manager.get_cached_data(url)
    assert retrieved_data == test_data
    
    # 無効なJSONデータのテスト
    with open(cache_manager._get_cache_path(url), 'w') as f:
        f.write('invalid json')
    assert cache_manager.get_cached_data(url) is None
    
def test_cache_clear():
    """キャッシュのクリアテスト"""
    cache_manager = CacheManager()
    urls = [
        "https://example.com/1",
        "https://example.com/2",
        "https://example.com/3"
    ]
    
    # 複数のキャッシュファイルを作成
    for url in urls:
        cache_manager.save_to_cache(url, [{'model': 'iPhone', 'price': 100000}])
        
    # キャッシュのクリア
    cache_manager.clear_cache()
    assert len(list(cache_manager.cache_dir.glob('*.json'))) == 0
    
def test_scrape_url_with_cache():
    """スクレイピング時のキャッシュ使用テスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # キャッシュにデータを保存
    cache_data = [{
        'model': 'iPhone 15 Pro 256GB',
        'price': 150000,
        'source': url,
        'timestamp': datetime.now(timezone.utc),
        'condition': '新品'
    }]
    scraper.cache_manager.save_to_cache(url, cache_data)
    
    # スクレイピング実行（キャッシュからデータを取得）
    with patch('requests.get') as mock_get:
        prices = scraper.scrape_url(url)
        assert prices == cache_data
        mock_get.assert_not_called()  # HTTPリクエストが行われていないことを確認
        
def test_scrape_url_with_expired_cache():
    """期限切れキャッシュのスクレイピングテスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # 期限切れのデータをキャッシュに保存
    expired_data = [{
        'model': 'iPhone 15 Pro 256GB',
        'price': 150000,
        'source': url,
        'timestamp': datetime.now(timezone.utc) - timedelta(hours=2),
        'condition': '新品'
    }]
    scraper.cache_manager.save_to_cache(url, expired_data)
    
    # キャッシュを期限切れにする
    with patch('os.path.getmtime', return_value=time.time() - 7200):  # 2時間前
        # 新しいデータをモック
        mock_response = MagicMock()
        mock_response.text = """
        <div class="price-item">
            <div class="model">iPhone 15 Pro 256GB</div>
            <div class="price">150000</div>
            <div class="condition">新品</div>
        </div>
        """
        with patch('requests.get', return_value=mock_response):
            prices = scraper.scrape_url(url)
            assert prices[0]['price'] == 150000  # 新しい価格が取得されていることを確認
            
def test_cache_error_handling():
    """キャッシュエラーのハンドリングテスト"""
    scraper = Scraper()
    url = "https://example.com"
    
    # キャッシュ保存時のエラー
    with patch.object(CacheManager, 'save_to_cache', side_effect=CacheError("Cache write failed", "save", Path("/test/cache.json"))):
        mock_response = MagicMock()
        mock_response.text = """
        <div class="price-item">
            <div class="model">iPhone 15 Pro 256GB</div>
            <div class="price">150000</div>
            <div class="condition">新品</div>
        </div>
        """
        with patch('requests.get', return_value=mock_response):
            prices = scraper.scrape_url(url)
            assert len(prices) > 0  # キャッシュエラーでもデータは返す
            summary = scraper.get_summary()
            assert 'errors' in summary
            assert summary['errors'].get('error_types', {}).get('CacheError', 0) > 0

@patch('requests.get')
def test_scrape_url_success(mock_get, mock_config, mock_response):
    mock_get.return_value = mock_response
    
    scraper = Scraper(mock_config)
    results = scraper.scrape_url(mock_config['urls']['official'][0], mock_config)
    
    assert len(results) == 1
    assert results[0]['model'] == 'iPhone 13 Pro'
    assert results[0]['price'] == 120000.0
    assert results[0]['condition'] == '新品'
    assert results[0]['source'] == mock_config['urls']['official'][0]

@patch('requests.get')
def test_scrape_url_http_error(mock_get, mock_config):
    mock_get.side_effect = RequestException("Connection error")
    
    scraper = Scraper(mock_config)
    with pytest.raises(HTTPError):
        scraper.scrape_url(mock_config['urls']['official'][0], mock_config)
</file>

<file path="lambdas/get_prices_lambda/requirements.txt">
requests==2.31.0
beautifulsoup4==4.12.2
PyYAML==6.0.1
boto3==1.38.9
</file>

<file path="src/lambda_functions/get_prices_lambda/scraper.py">
import concurrent.futures
import hashlib
import json
import logging
import os
import random
import re
import time
import uuid
import warnings
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from pathlib import Path
from statistics import mean, median, stdev
from typing import Any, ContextManager, Dict, List, Optional, Union

import requests
import yaml
from bs4 import BeautifulSoup
from pydantic import BaseModel, Field, HttpUrl, field_validator, validator
from tenacity import (after_log, before_sleep_log, retry,
                      retry_if_exception_type, stop_after_attempt,
                      wait_exponential)

# 定数定義
MAX_WORKERS = 5  # 同時に実行する最大スレッド数
TIMEOUT = 30     # 各タスクのタイムアウト（秒）
CACHE_DURATION = 3600  # キャッシュの有効期間（秒）

# ロギング設定
class ScraperFormatter(logging.Formatter):
    """カスタムログフォーマッタ"""
    def format(self, record):
        # 基本情報
        log_data = {
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'level': record.levelname,
            'message': record.getMessage(),
            'function': record.funcName,
            'line': record.lineno
        }
        
        # 追加情報
        if hasattr(record, 'extra'):
            log_data.update(record.extra)
        
        return str(log_data)

def setup_logger():
    """ロガーのセットアップ"""
    logger = logging.getLogger('price_scraper')
    logger.setLevel(logging.INFO)
    
    # 既存のハンドラをクリア
    logger.handlers = []
    
    # コンソールハンドラ
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(ScraperFormatter())
    logger.addHandler(console_handler)
    
    # ファイルハンドラ
    log_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'logs'))
    os.makedirs(log_dir, mode=0o755, exist_ok=True)
    log_file = os.path.join(log_dir, 'scraper.log')
    file_handler = logging.FileHandler(log_file, mode='a')
    file_handler.setFormatter(ScraperFormatter())
    logger.addHandler(file_handler)
    
    return logger

logger = setup_logger()

def log_with_context(message: str, level: int = logging.INFO, **kwargs):
    """コンテキスト情報を含むログ出力"""
    extra = {
        'context': {
            'timestamp': datetime.now(timezone.utc).isoformat(),
            **kwargs
        }
    }
    logger.log(level, message, extra=extra)

def log_scraping_start(url: str):
    """スクレイピング開始のログ"""
    log_with_context(
        "Starting scraping",
        url=url,
        timestamp=datetime.now(timezone.utc).isoformat()
    )

def log_scraping_success(url: str, items_found: int):
    """スクレイピング成功のログ"""
    log_with_context(
        "Scraping completed successfully",
        url=url,
        items_found=items_found,
        timestamp=datetime.now(timezone.utc).isoformat()
    )

def log_scraping_error(url: str, error: Exception):
    """スクレイピングエラーのログ"""
    log_with_context(
        "Scraping failed",
        url=url,
        error_type=type(error).__name__,
        error_message=str(error),
        timestamp=datetime.now(timezone.utc).isoformat(),
        level=logging.ERROR
    )

def log_price_data(price_data: Dict[str, Any]):
    """価格データのログ"""
    log_with_context(
        "Price data found",
        model=price_data['model'],
        price=price_data['price'],
        source=price_data['source'],
        condition=price_data.get('condition'),
        timestamp=datetime.now(timezone.utc).isoformat()
    )

def log_validation_error(field: str, value: Any, error: str):
    """検証エラーのログ"""
    log_with_context(
        "Validation error",
        field=field,
        value=value,
        error=error,
        timestamp=datetime.now(timezone.utc).isoformat(),
        level=logging.WARNING
    )

class ErrorType(Enum):
    HTTP = "HTTP"
    PARSE = "PARSE"
    VALIDATION = "VALIDATION"
    CACHE = "CACHE"
    SCRAPER = "SCRAPER"

class ErrorSeverity(Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"

class ScraperError(Exception):
    def __init__(self, message: str, error_type: Union[ErrorType, str] = ErrorType.SCRAPER, severity: ErrorSeverity = ErrorSeverity.HIGH, context: Optional[Dict] = None):
        super().__init__(message)
        self.message = message
        self.error_type = error_type if isinstance(error_type, ErrorType) else ErrorType.SCRAPER
        self.severity = severity if isinstance(severity, ErrorSeverity) else ErrorSeverity.HIGH
        self.context = context or {}
        self.error_id = f"ERR-{int(time.time())}-{random.randint(1000, 9999)}"
        self.timestamp = datetime.now(timezone.utc)

class HTTPError(ScraperError):
    def __init__(self, message: str, status_code: Optional[int] = None, url: Optional[str] = None):
        context = {
            'status_code': status_code,
            'url': url
        } if status_code and url else {}
        super().__init__(message, ErrorType.HTTP, ErrorSeverity.HIGH, context)

class ParseError(ScraperError):
    def __init__(self, message: str, html: str = '', selector: str = ''):
        html_snippet = html[:200] if len(html) > 200 else html
        context = {
            'html_snippet': html_snippet,
            'selector': selector
        }
        super().__init__(message, ErrorType.PARSE, ErrorSeverity.MEDIUM, context)

class ValidationError(ScraperError):
    def __init__(self, message: str, field: Optional[str] = None, value: Optional[str] = None):
        context = {
            'field': field,
            'value': str(value)
        } if field else {}
        super().__init__(message, ErrorType.VALIDATION, ErrorSeverity.LOW, context)

class CacheError(ScraperError):
    def __init__(self, message: str, operation: str = '', cache_path: Union[str, Path] = ''):
        context = {
            'operation': operation,
            'cache_path': str(cache_path)
        }
        super().__init__(message, ErrorType.CACHE, ErrorSeverity.LOW, context)

class ConfigError(ScraperError):
    """設定ファイルエラー"""
    pass

# リトライ設定
RETRY_CONFIG = {
    'max_attempts': 3,
    'wait_min': 4,
    'wait_max': 10,
    'wait_multiplier': 1
}

def create_retry_decorator():
    """リトライデコレータの作成"""
    return retry(
        stop=stop_after_attempt(RETRY_CONFIG['max_attempts']),
        wait=wait_exponential(
            multiplier=RETRY_CONFIG['wait_multiplier'],
            min=RETRY_CONFIG['wait_min'],
            max=RETRY_CONFIG['wait_max']
        ),
        retry=retry_if_exception_type((HTTPError, ParseError)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
        after=after_log(logger, logging.INFO),
        reraise=True
    )

def log_error(error: ScraperError) -> None:
    """エラーをログに記録"""
    log_data = {
        'error_id': error.error_id,
        'severity': error.severity.name,
        'message': str(error),
        'timestamp': error.timestamp.isoformat(),
        'context': error.context
    }
    logger.error(json.dumps(log_data, ensure_ascii=False))

def safe_request(url: str, headers: Dict[str, str], timeout: int = TIMEOUT) -> requests.Response:
    """安全なHTTPリクエストを実行"""
    try:
        response = requests.get(url, headers=headers, timeout=timeout, verify=True)
        response.raise_for_status()
        return response
    except requests.exceptions.RequestException as e:
        raise HTTPError(f"Request failed: {str(e)}", url=url)

def load_config():
    """
    設定ファイルを読み込む
    """
    config_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'config', 'config.production.yaml')
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
            if not config or 'scraper' not in config:
                raise ConfigError("Invalid configuration: missing 'scraper' section")
            return config
    except FileNotFoundError:
        logger.error(f"Config file not found: {config_path}")
        raise ConfigError(f"Configuration file not found: {config_path}")
    except yaml.YAMLError as e:
        logger.error(f"Error parsing config file: {str(e)}")
        raise ConfigError(f"Invalid YAML format: {str(e)}")
    except Exception as e:
        logger.error(f"Error loading config: {str(e)}")
        raise ConfigError(f"Failed to load configuration: {str(e)}")

class PriceData(BaseModel):
    """価格データモデル"""
    model: str
    price: float
    source: HttpUrl
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    url: Optional[str] = None
    condition: Optional[str] = None
    notes: Optional[str] = None
    currency: str = "JPY"

    def to_dict(self) -> Dict[str, Any]:
        data = self.model_dump()
        if isinstance(data['timestamp'], datetime):
            data['timestamp'] = data['timestamp'].isoformat()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PriceData':
        if 'timestamp' in data and isinstance(data['timestamp'], str):
            data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        return cls(**data)

    @validator('price')
    def validate_price(cls, v):
        if v <= 0:
            raise ValueError('Price must be positive')
        return v

    @field_validator('model')
    @classmethod
    def validate_model(cls, v: str) -> str:
        """モデル名の検証"""
        if not v or not isinstance(v, str):
            raise ValueError("Model must be a non-empty string")
        # iPhoneモデルの正規表現パターン
        pattern = r'^iPhone\s+\d+(\s+Pro(\s+Max)?)?(\s+\d+GB)?$'
        if not re.match(pattern, v):
            raise ValueError("Invalid iPhone model format")
        return v

    @field_validator('condition')
    @classmethod
    def validate_condition(cls, v: Optional[str]) -> Optional[str]:
        """状態の検証"""
        if v is None:
            return v
        valid_conditions = ['新品', '中古', 'リファービッシュ']
        if v not in valid_conditions:
            raise ValueError(f"Invalid condition. Must be one of: {', '.join(valid_conditions)}")
        return v

    @field_validator('source')
    @classmethod
    def validate_source(cls, v: str) -> str:
        """ソースURLの検証"""
        if not v or not isinstance(v, str):
            raise ValueError("Source must be a non-empty string")
        if not v.startswith(('http://', 'https://')):
            raise ValueError("Source must be a valid URL")
        return v

    @field_validator('timestamp')
    @classmethod
    def validate_timestamp(cls, v: datetime) -> datetime:
        """タイムスタンプの検証"""
        if not isinstance(v, datetime):
            raise ValueError("Timestamp must be a datetime object")
        if v.tzinfo is None:
            return v.replace(tzinfo=timezone.utc)
        return v

def normalize_price_data(raw_data):
    try:
        # 価格の正規化
        price = raw_data['price']
        if isinstance(price, str):
            price = price.replace(',', '').replace('¥', '').replace('￥', '')
        
        # モデル名の正規化
        model = raw_data['model']
        model = re.sub(r'\s+', ' ', model).strip()  # 余分な空白を削除
        
        # 条件の正規化
        condition = raw_data.get('condition', '新品')
        condition_map = {
            'new': '新品',
            'used': '中古',
            'unused': '未使用'
        }
        condition = condition_map.get(condition.lower(), condition)
        
        return PriceData(
            model=model,
            price=float(price),
            source=raw_data['source'],
            timestamp=datetime.now(timezone.utc),
            condition=condition
        )
    except KeyError as e:
        logger.error(f"Missing required field: {str(e)}")
        raise ValidationError(f"Missing required field: {str(e)}")
    except ValueError as e:
        logger.error(f"Invalid data format: {str(e)}")
        raise ValidationError(f"Invalid data format: {str(e)}")
    except Exception as e:
        logger.error(f"Failed to normalize price data: {str(e)}")
        raise ValidationError(f"Data normalization failed: {str(e)}")

# 並列処理の設定
MAX_WORKERS = 5  # 同時に実行する最大スレッド数
TIMEOUT = 30     # 各タスクのタイムアウト（秒）

@dataclass
class PerformanceMetrics:
    """パフォーマンスメトリクスのデータクラス"""
    url: str
    start_time: float
    end_time: float
    response_time: float
    success: bool
    error_message: Optional[str] = None
    items_found: int = 0

class PerformanceTracker:
    """パフォーマンスメトリクスのトラッキング"""
    def __init__(self):
        self.start_time = None
        self.end_time = None
        self.request_durations = defaultdict(list)
        self.cache_hits = defaultdict(int)
        self.cache_misses = defaultdict(int)
        self.total_requests = 0
        self.successful_requests = 0
        self.failed_requests = 0

    def start_scraping(self):
        """スクレイピングの開始時刻を記録"""
        self.start_time = time.time()

    def end_scraping(self):
        """スクレイピングの終了時刻を記録"""
        self.end_time = time.time()

    def record_request(self, url: str, duration: float, success: bool = True):
        """リクエストの実行時間を記録"""
        self.request_durations[url].append(duration)
        self.total_requests += 1
        if success:
            self.successful_requests += 1
        else:
            self.failed_requests += 1

    def record_cache_hit(self, url: str):
        """キャッシュヒットを記録"""
        self.cache_hits[url] += 1

    def record_cache_miss(self, url: str):
        """キャッシュミスを記録"""
        self.cache_misses[url] += 1

    def get_summary(self) -> Dict:
        """パフォーマンスメトリクスのサマリーを取得"""
        if not self.start_time or not self.end_time:
            return {}

        total_duration = self.end_time - self.start_time
        avg_response_time = sum(
            sum(durations) for durations in self.request_durations.values()
        ) / max(self.total_requests, 1)

        total_cache_hits = sum(self.cache_hits.values())
        total_cache_misses = sum(self.cache_misses.values())
        total_cache_requests = total_cache_hits + total_cache_misses
        cache_hit_ratio = (total_cache_hits / total_cache_requests * 100) if total_cache_requests > 0 else 0
        success_rate = (self.successful_requests / max(self.total_requests, 1)) * 100

        return {
            'total_duration': total_duration,
            'total_requests': self.total_requests,
            'successful_requests': self.successful_requests,
            'failed_requests': self.failed_requests,
            'success_rate': success_rate,
            'avg_response_time': avg_response_time,
            'cache_hits': dict(self.cache_hits),
            'cache_misses': dict(self.cache_misses),
            'cache_hit_ratio': cache_hit_ratio,
            'request_durations': dict(self.request_durations)
        }

    def clear(self):
        """パフォーマンスメトリクスをクリアする"""
        self.start_time = None
        self.end_time = None
        self.request_durations.clear()
        self.cache_hits.clear()
        self.cache_misses.clear()
        self.total_requests = 0
        self.successful_requests = 0
        self.failed_requests = 0

class ErrorHandler:
    def __init__(self):
        self.error_counts = {severity: 0 for severity in ErrorSeverity}
        self.error_types = {error_type: 0 for error_type in ErrorType}
        self.recent_errors = []
        self.max_recent_errors = 10
        self.errors = []  # 全てのエラーを保持

    def handle_error(self, error: Union[ScraperError, Exception]):
        """エラーを処理し、ログに記録する"""
        if not isinstance(error, ScraperError):
            error = ScraperError(str(error))

        self.error_counts[error.severity] += 1
        self.error_types[error.error_type] += 1
        
        error_info = {
            'error_id': error.error_id,
            'severity': error.severity.name,
            'message': str(error),
            'timestamp': error.timestamp.isoformat(),
            'context': error.context
        }
        
        self.recent_errors.append(error_info)
        self.errors.append(error)
        if len(self.recent_errors) > self.max_recent_errors:
            self.recent_errors.pop(0)
            
        log_error(error)

    def get_summary(self) -> Dict:
        """エラーサマリーを取得する"""
        return {
            'total_errors': sum(self.error_counts.values()),
            'error_counts': {severity.name: count for severity, count in self.error_counts.items()},
            'error_types': {error_type.name: count for error_type, count in self.error_types.items()},
            'recent_errors': self.recent_errors
        }

    def should_continue(self) -> bool:
        """スクレイピングを続行すべきかを判断する"""
        high_severity_count = self.error_counts[ErrorSeverity.HIGH]
        return high_severity_count < 3

    def clear(self):
        """エラー情報をクリアする"""
        self.error_counts = {severity: 0 for severity in ErrorSeverity}
        self.error_types = {error_type: 0 for error_type in ErrorType}
        self.recent_errors = []
        self.errors = []

class CacheManager:
    """キャッシュを管理するクラス"""
    def __init__(self, cache_dir: str = 'cache', cache_ttl: int = 3600, cache_duration: Optional[int] = None):
        self.cache_dir = Path(cache_dir)
        # Support legacy cache_duration parameter with deprecation warning
        if cache_duration is not None:
            warnings.warn(
                "The 'cache_duration' parameter is deprecated and will be removed in a future version. "
                "Use 'cache_ttl' instead.",
                DeprecationWarning,
                stacklevel=2
            )
            self.cache_ttl = cache_duration
        else:
            self.cache_ttl = cache_ttl
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _get_cache_path(self, url: str) -> Path:
        """URLに基づいてキャッシュファイルのパスを生成する"""
        url_hash = str(hash(url))
        return self.cache_dir / f"{url_hash}.json"

    def _is_cache_valid(self, cache_path: Path) -> bool:
        """キャッシュが有効かどうかを確認する"""
        if not cache_path.exists():
            return False

        try:
            with open(cache_path, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            cache_time = datetime.fromisoformat(cache_data['timestamp'])
            now = datetime.now(timezone.utc)
            
            return (now - cache_time).total_seconds() < self.cache_ttl
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            logging.error(f"Cache validation error: {str(e)}")
            return False

    def get_cached_data(self, url: str) -> Optional[List[Dict]]:
        """URLに対応するキャッシュデータを取得する"""
        cache_path = self._get_cache_path(url)
        
        if not self._is_cache_valid(cache_path):
            return None

        try:
            with open(cache_path, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            # ISO形式の文字列をdatetimeオブジェクトに変換
            data = cache_data['data']
            for item in data:
                if 'timestamp' in item:
                    item['timestamp'] = datetime.fromisoformat(item['timestamp'])
            
            logging.info(f"Successfully read from cache: {url}")
            return data
        except (json.JSONDecodeError, KeyError, OSError) as e:
            raise CacheError(f"Cache read error: {str(e)}", "read", cache_path)

    def save_to_cache(self, url: str, data: List[Dict]):
        """データをキャッシュに保存する"""
        cache_path = self._get_cache_path(url)
        
        try:
            # datetimeオブジェクトをISO形式の文字列に変換
            serializable_data = []
            for item in data:
                item_copy = item.copy()
                if 'timestamp' in item_copy:
                    item_copy['timestamp'] = item_copy['timestamp'].isoformat()
                serializable_data.append(item_copy)
            
            cache_data = {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'data': serializable_data
            }
            
            with open(cache_path, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)
            logging.info(f"Successfully cached data for: {url}")
        except (OSError, TypeError) as e:
            logging.error(f"Cache write error: {str(e)}")
            raise CacheError("Cache write failed", "save", cache_path)

    def clear_cache(self):
        """キャッシュディレクトリ内のすべてのファイルを削除する"""
        try:
            for cache_file in self.cache_dir.glob('*.json'):
                cache_file.unlink()
        except OSError as e:
            raise CacheError(f"Cache clear error: {str(e)}", "clear", self.cache_dir)

class Scraper:
    """スクレイピングを実行するクラス"""
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.session = requests.Session()
        self.cache_manager = CacheManager()
        self.error_handler = ErrorHandler()
        self.performance_tracker = PerformanceTracker()

    @contextmanager
    def _measure_request(self, url: str):
        """リクエストの実行時間を計測するコンテキストマネージャ"""
        start_time = time.time()
        success = True
        try:
            yield
        except Exception:
            success = False
            raise
        finally:
            duration = time.time() - start_time
            self.performance_tracker.record_request(url, duration, success)

    def scrape_url(self, url: str, source: str = 'unknown') -> List[Dict]:
        """指定されたURLからデータをスクレイピング"""
        try:
            cached_data = self.cache_manager.get_cached_data(url)
            if cached_data:
                self.performance_tracker.record_cache_hit(url)
                return cached_data

            self.performance_tracker.record_cache_miss(url)
            
            with self._measure_request(url):
                response = self.session.get(url, timeout=self.config.get('timeout', 30))
                response.raise_for_status()
                data = self._parse_response(response.text, source)
                self.cache_manager.save_to_cache(url, data)
                return data
        except requests.exceptions.RequestException as e:
            error = HTTPError(f"Request failed: {str(e)}", getattr(e.response, 'status_code', None), url)
            self.error_handler.handle_error(error)
            raise error
        except Exception as e:
            if not isinstance(e, ScraperError):
                error = ScraperError(f"Scraping failed: {str(e)}", context={
                    'url': url,
                    'source': source,
                    'error_type': str(type(e).__name__)
                })
                self.error_handler.handle_error(error)
                raise error
            self.error_handler.handle_error(e)
            raise e

    def scrape_urls(self, urls: List[str], source: str) -> List[List[Dict[str, Any]]]:
        """
        複数のURLを並列でスクレイピングする
        
        Args:
            urls: スクレイピング対象のURLリスト
            source: データソース（'kaitori'または'official'）
            
        Returns:
            List[List[Dict[str, Any]]]: 各URLの価格データリスト
        """
        results = []
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(self.scrape_url, url, source): url for url in urls}
            for future in as_completed(future_to_url):
                url = future_to_url[future]
                try:
                    data = future.result()
                    results.append(data)
                except Exception as e:
                    logger.error(f"Error scraping {url}: {str(e)}")
                    results.append([])
        return results

    def get_kaitori_prices(self) -> List[Dict]:
        """買取価格を取得する"""
        try:
            self.performance_tracker.start_scraping()
            prices = []
            for url in self.config.get('urls', {}).get('kaitori', []):
                try:
                    prices.extend(self.scrape_url(url, 'kaitori'))
                except Exception as e:
                    self.error_handler.handle_error(e)
                    if not self.error_handler.should_continue():
                        break
            return prices
        finally:
            self.performance_tracker.end_scraping()

    def get_official_prices(self) -> List[Dict]:
        """公式価格を取得する"""
        try:
            self.performance_tracker.start_scraping()
            prices = []
            for url in self.config.get('urls', {}).get('official', []):
                try:
                    prices.extend(self.scrape_url(url, 'official'))
                except Exception as e:
                    self.error_handler.handle_error(e)
                    if not self.error_handler.should_continue():
                        break
            return prices
        finally:
            self.performance_tracker.end_scraping()

    def _parse_response(self, html: str, source: str) -> List[Dict]:
        """HTMLレスポンスをパースする"""
        try:
            soup = BeautifulSoup(html, 'html.parser')
            if source == 'kaitori':
                items = soup.select('.price-item')
                if not items:
                    raise ParseError("No price items found", html, '.price-item')
                
                prices = []
                for item in items:
                    try:
                        model = item.select_one('.model').text.strip()
                        price = float(item.select_one('.price').text.strip().replace(',', ''))
                        condition = item.select_one('.condition').text.strip()
                        
                        price_data = {
                            'model': model,
                            'price': price,
                            'source': source,
                            'condition': condition,
                            'timestamp': datetime.now(timezone.utc)
                        }
                        
                        if validate_price_data(price_data):
                            prices.append(price_data)
                    except (AttributeError, ValueError) as e:
                        raise ParseError(f"Failed to parse price item: {str(e)}", str(item), source)
                
                return prices
            else:
                items = soup.select('.product-item')
                if not items:
                    raise ParseError("No product items found", html, '.product-item')
                
                prices = []
                for item in items:
                    try:
                        model = item.select_one('.model-name').text.strip()
                        price = float(item.select_one('.price').text.strip().replace(',', ''))
                        
                        price_data = {
                            'model': model,
                            'price': price,
                            'source': source,
                            'timestamp': datetime.now(timezone.utc)
                        }
                        
                        if validate_price_data(price_data):
                            prices.append(price_data)
                    except (AttributeError, ValueError) as e:
                        raise ParseError(f"Failed to parse product item: {str(e)}", str(item), source)
                
                return prices
        except Exception as e:
            if not isinstance(e, ScraperError):
                e = ParseError(f"Failed to parse HTML: {str(e)}", html, source)
            self.error_handler.handle_error(e)
            raise e

    def get_summary(self) -> Dict[str, Any]:
        """スクレイピングの実行結果サマリーを取得"""
        return {
            'performance': self.performance_tracker.get_summary(),
            'errors': self.error_handler.get_summary()
        }

def validate_price_data(data: Dict[str, Any]) -> bool:
    """価格データをバリデーションする"""
    try:
        PriceData(**data)
        return True
    except ValidationError as e:
        logging.error(f"Price data validation error: {str(e)}")
        return False
</file>

<file path="terraform/api_gateway.tf">
# CloudWatch Log Group is already defined in monitoring.tf
# resource "aws_cloudwatch_log_group" "api_gateway" {
#   name              = "/aws/apigateway/price-comparison-api"
#   retention_in_days = 30
#   tags = {
#     Name        = "api-gateway-logs"
#     Environment = "production"
#     Project     = "iphone_price_tracker"
#   }
# }

# HTTP API Gateway
resource "aws_apigatewayv2_api" "main" {
  name          = "price-comparison-http-api"
  protocol_type = "HTTP"
  description   = "HTTP API for iPhone price comparison"
}

# API Gateway Stage
resource "aws_api_gateway_stage" "production" {
  deployment_id = aws_api_gateway_deployment.price_comparison.id
  rest_api_id   = aws_api_gateway_rest_api.price_comparison.id
  stage_name    = "production"

  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_gateway_logs.arn
    format         = jsonencode({
      requestId               = "$context.requestId"
      sourceIp               = "$context.identity.sourceIp"
      requestTime            = "$context.requestTime"
      protocol              = "$context.protocol"
      httpMethod            = "$context.httpMethod"
      resourcePath          = "$context.resourcePath"
      routeKey              = "$context.routeKey"
      status                = "$context.status"
      responseLength        = "$context.responseLength"
      integrationErrorMessage = "$context.integrationErrorMessage"
    })
  }

  xray_tracing_enabled = true

  depends_on = [
    aws_api_gateway_deployment.price_comparison
  ]
}

resource "aws_api_gateway_rest_api" "price_comparison" {
  name        = "price-comparison-api"
  description = "API for iPhone price comparison"
}

resource "aws_api_gateway_resource" "prices" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  parent_id   = aws_api_gateway_rest_api.price_comparison.root_resource_id
  path_part   = "get_prices"
}

resource "aws_api_gateway_method" "get_prices" {
  rest_api_id   = aws_api_gateway_rest_api.price_comparison.id
  resource_id   = aws_api_gateway_resource.prices.id
  http_method   = "GET"
  authorization = "NONE"
}

# CORS設定の追加
resource "aws_api_gateway_method" "get_prices_options" {
  rest_api_id   = aws_api_gateway_rest_api.price_comparison.id
  resource_id   = aws_api_gateway_resource.prices.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_method_response" "get_prices_options_200" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  resource_id = aws_api_gateway_resource.prices.id
  http_method = aws_api_gateway_method.get_prices_options.http_method
  status_code = "200"

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration" "get_prices_options_integration" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  resource_id = aws_api_gateway_resource.prices.id
  http_method = aws_api_gateway_method.get_prices_options.http_method
  type        = "MOCK"

  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_integration_response" "get_prices_options_integration_response" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  resource_id = aws_api_gateway_resource.prices.id
  http_method = aws_api_gateway_method.get_prices_options.http_method
  status_code = aws_api_gateway_method_response.get_prices_options_200.status_code

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "method.response.header.Access-Control-Allow-Methods" = "'GET,OPTIONS'"
    "method.response.header.Access-Control-Allow-Origin"  = "'*'"
  }
}

resource "aws_api_gateway_integration" "lambda" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  resource_id = aws_api_gateway_resource.prices.id
  http_method = aws_api_gateway_method.get_prices.http_method

  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.get_prices.invoke_arn
}

resource "aws_api_gateway_deployment" "price_comparison" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id

  depends_on = [
    aws_api_gateway_integration.lambda
  ]

  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_api_gateway_stage" "prod" {
  deployment_id = aws_api_gateway_deployment.price_comparison.id
  rest_api_id   = aws_api_gateway_rest_api.price_comparison.id
  stage_name    = "prod"
}

resource "aws_lambda_permission" "api_gateway" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.get_prices.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.price_comparison.execution_arn}/*/*"
}

resource "aws_api_gateway_resource" "price_history" {
  rest_api_id = aws_api_gateway_rest_api.price_comparison.id
  parent_id   = aws_api_gateway_rest_api.price_comparison.root_resource_id
  path_part   = "price-history"
}

resource "aws_api_gateway_method" "price_history_get" {
  rest_api_id   = aws_api_gateway_rest_api.price_comparison.id
  resource_id   = aws_api_gateway_resource.price_history.id
  http_method   = "GET"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "price_history_integration" {
  rest_api_id             = aws_api_gateway_rest_api.price_comparison.id
  resource_id             = aws_api_gateway_resource.price_history.id
  http_method             = aws_api_gateway_method.price_history_get.http_method
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.get_price_history.invoke_arn
}

resource "aws_lambda_permission" "api_gateway_price_history" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.get_price_history.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.price_comparison.execution_arn}/*/*"
}

resource "aws_apigatewayv2_route" "predict_prices" {
  api_id    = aws_apigatewayv2_api.main.id
  route_key = "GET /predict-prices"
  target    = "integrations/${aws_apigatewayv2_integration.predict_prices.id}"
}

resource "aws_apigatewayv2_integration" "predict_prices" {
  api_id           = aws_apigatewayv2_api.main.id
  integration_type = "AWS_PROXY"

  connection_type    = "INTERNET"
  description        = "Predict prices integration"
  integration_method = "POST"
  integration_uri    = aws_lambda_function.predict_prices_lambda.invoke_arn
}

resource "aws_apigatewayv2_route" "compare_prices" {
  api_id    = aws_apigatewayv2_api.main.id
  route_key = "GET /compare-prices"
  target    = "integrations/${aws_apigatewayv2_integration.compare_prices.id}"
}

resource "aws_apigatewayv2_integration" "compare_prices" {
  api_id           = aws_apigatewayv2_api.main.id
  integration_type = "AWS_PROXY"

  connection_type    = "INTERNET"
  description        = "Compare prices integration"
  integration_method = "POST"
  integration_uri    = aws_lambda_function.compare_prices_lambda.invoke_arn
}

resource "aws_apigatewayv2_route" "line_notification" {
  api_id    = aws_apigatewayv2_api.main.id
  route_key = "POST /line-notification"
  target    = "integrations/${aws_apigatewayv2_integration.line_notification.id}"
}

resource "aws_apigatewayv2_integration" "line_notification" {
  api_id           = aws_apigatewayv2_api.main.id
  integration_type = "AWS_PROXY"

  connection_type    = "INTERNET"
  description        = "LINE notification integration"
  integration_method = "POST"
  integration_uri    = aws_lambda_function.line_notification_lambda.invoke_arn
}
</file>

<file path=".github/workflows/terraform.yml">
# .github/workflows/terraform.yml
name: Terraform Deploy

on:
  push:
    paths:
      - 'terraform/**'
      - 'src/**'
      - 'lambda/**'
      - '.github/workflows/terraform.yml'
  pull_request:
    paths:
      - 'terraform/**'
      - 'src/**'
      - 'lambda/**'
      - '.github/workflows/terraform.yml'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-northeast-1
  TF_WORKSPACE: default
  PYTHON_VERSION: '3.9'

jobs:
  prepare:
    name: Prepare Lambda Functions
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r terraform/requirements.txt

      - name: Package Lambda functions
        run: |
          cd terraform/scripts
          python package_lambda.py

      - name: Upload Lambda packages
        uses: actions/upload-artifact@v3
        with:
          name: lambda-packages
          path: |
            terraform/*.zip
            !terraform/terraform.*.zip

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r terraform/requirements.txt
          pip install pytest pytest-cov python-dotenv

      - name: Run Python tests
        run: |
          PYTHONPATH=$PYTHONPATH:$(pwd) pytest tests/unit/ -v --cov=src --cov-report=xml --cov-report=term-missing --tb=short

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          fail_ci_if_error: false

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install security tools
        run: |
          pip install bandit safety
          curl -L -o tfsec https://github.com/aquasecurity/tfsec/releases/download/v1.28.1/tfsec-linux-amd64
          chmod +x tfsec
          sudo mv tfsec /usr/local/bin/

      - name: Run Bandit security scan
        run: |
          bandit -r src/ -f json -o bandit-results.json -c .bandit || true

      - name: Run dependency security check
        run: |
          safety check -r terraform/requirements.txt --json > safety-results.json || true

      - name: Run Terraform security scan
        run: |
          tfsec terraform/ --format json --out tfsec-results.json || true

      - name: Upload security scan results
        uses: actions/upload-artifact@v3
        with:
          name: security-scan-results
          path: |
            bandit-results.json
            safety-results.json
            tfsec-results.json

  validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Lambda packages
        uses: actions/download-artifact@v3
        with:
          name: lambda-packages
          path: terraform/

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsSession

      - name: Initialize Terraform
        working-directory: terraform
        run: |
          # Remove any existing .terraform directory and .terraform.lock.hcl
          rm -rf .terraform .terraform.lock.hcl
          terraform init -input=false

      - name: Validate Terraform configuration
        working-directory: terraform
        run: |
          terraform validate

      - name: Check Terraform formatting
        working-directory: terraform
        run: |
          terraform fmt -check -recursive -diff

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Lambda packages
        uses: actions/download-artifact@v3
        with:
          name: lambda-packages
          path: terraform/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsSession

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Initialize Terraform
        working-directory: terraform
        run: |
          terraform init -input=false

      - name: Handle existing resources
        working-directory: terraform
        run: |
          # Import existing DynamoDB tables if they exist
          terraform import aws_dynamodb_table.iphone_prices iphone_prices || true
          terraform import aws_dynamodb_table.official_prices official_prices || true
          terraform import aws_dynamodb_table.price_history price_history || true
          terraform import aws_dynamodb_table.price_predictions price_predictions || true
          
          # Import existing IAM roles if they exist
          terraform import aws_iam_role.lambda_role get_prices_lambda_role || true
          terraform import aws_iam_openid_connect_provider.github_actions https://token.actions.githubusercontent.com || true

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan \
            -input=false \
            -var="skip_organization_policy=true" \
            -var="evaluation_periods=120" \
            -var="period=300" \
            -out=tfplan

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v3
        with:
          name: tfplan
          path: terraform/tfplan

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [test, security, validate, plan]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Lambda packages
        uses: actions/download-artifact@v3
        with:
          name: lambda-packages
          path: terraform/

      - name: Download Plan Artifact
        uses: actions/download-artifact@v3
        with:
          name: tfplan
          path: terraform/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsSession

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Initialize Terraform
        working-directory: terraform
        run: |
          terraform init -input=false

      - name: Apply Terraform changes
        working-directory: terraform
        run: |
          terraform apply -auto-approve tfplan

      - name: Verify deployment
        working-directory: terraform
        run: |
          # Invoke deployment verification Lambda
          aws lambda invoke \
            --function-name deployment-verification \
            --payload '{}' \
            response.json
          cat response.json

      - name: Run smoke tests
        working-directory: terraform
        run: |
          # Invoke smoke test Lambda
          aws lambda invoke \
            --function-name smoke-test \
            --payload '{}' \
            response.json
          cat response.json

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Delete artifacts
        uses: geekyeggo/delete-artifact@v2
        with:
          name: |
            lambda-packages
            tfplan
            security-scan-results
</file>

<file path="terraform/lambda.tf">
locals {
  lambda_src_dir = "${path.module}/.."
  lambda_files = [
    "lambdas/get_prices_lambda/lambda_function.py",
    "lambdas/save_price_history_lambda/save_price_history.py",
    "lambdas/get_price_history_lambda/get_price_history.py",
    "src/apple_scraper_for_rudea.py",
    "config/config.production.yaml"
  ]
  layer_build_dir = "${path.module}/layer"
  layer_zip_path  = "${path.module}/layer.zip"
}

# Lambda Layer用のPythonパッケージをインストール
resource "null_resource" "install_lambda_layer_packages" {
  triggers = {
    requirements = filemd5("${path.module}/requirements.txt")
  }

  provisioner "local-exec" {
    command = <<EOF
mkdir -p ${local.layer_build_dir}/python
pip install --no-cache-dir --platform manylinux2014_x86_64 --target=${local.layer_build_dir}/python --implementation cp --python-version 3.9 --only-binary=:all: --upgrade -r ${path.module}/requirements.txt
cd ${local.layer_build_dir} && zip -r ${local.layer_zip_path} .
EOF
  }

  lifecycle {
    create_before_destroy = true
  }
}

# Lambda Layer
resource "aws_lambda_layer_version" "dependencies" {
  layer_name          = "get_prices_dependencies"
  description         = "Dependencies for get_prices Lambda function"
  compatible_runtimes = ["python3.9"]
  filename            = local.layer_zip_path
  source_code_hash    = null_resource.install_lambda_layer_packages.id

  depends_on = [null_resource.install_lambda_layer_packages]
}

# Lambda関数のソースコードをZIP化
data "archive_file" "lambda_get_prices" {
  type        = "zip"
  output_path = "${path.module}/lambda_function.zip"

  dynamic "source" {
    for_each = local.lambda_files
    content {
      content  = file("${local.lambda_src_dir}/${source.value}")
      filename = basename(source.value)
    }
  }
}

# Get Prices Lambda Function
resource "aws_lambda_function" "get_prices" {
  filename         = "./get_prices_lambda.zip"
  function_name    = "get_prices"
  role             = aws_iam_role.get_prices_lambda_role.arn
  handler          = "lambda_function.lambda_handler"
  runtime          = "python3.9"
  source_code_hash = filebase64sha256("./get_prices_lambda.zip")
  timeout          = 30
  memory_size      = 128

  environment {
    variables = {
      DYNAMODB_TABLE = "iphone_prices"
      ENVIRONMENT    = "production"
    }
  }

  tags = {
    Name        = "get_prices"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# Lambda関数のメモリとタイムアウトの最適化
resource "aws_lambda_function" "price_comparison" {
  filename      = "lambda_function.zip"
  function_name = "price-comparison-function"
  description   = "Lambda function for price comparison"
  role          = aws_iam_role.lambda_execution_role.arn
  handler       = "lambda_function.lambda_handler"
  runtime       = "python3.9"
  timeout       = 30
  memory_size   = 128
  publish       = true  # バージョンを公開

  environment {
    variables = {
      DYNAMODB_TABLE = aws_dynamodb_table.iphone_prices.name
      ENVIRONMENT    = "production"
    }
  }

  tags = {
    Name        = "price-comparison-function"
    Environment = "production"
    Project     = "iphone_price_tracker"
    Service     = "price-comparison"
  }
}

# Lambda関数のエイリアス
resource "aws_lambda_alias" "get_prices" {
  name             = "production"
  description      = "Production alias for get_prices Lambda function"
  function_name    = aws_lambda_function.price_comparison.function_name
  function_version = aws_lambda_function.price_comparison.version  # 公開されたバージョンを使用
}

# Lambda関数のバージョン
resource "aws_lambda_function_event_invoke_config" "get_prices" {
  function_name = aws_lambda_function.price_comparison.function_name

  maximum_event_age_in_seconds = 60
  maximum_retry_attempts       = 2

  destination_config {
    on_failure {
      destination = aws_sqs_queue.lambda_dlq.arn
    }
  }
}

# Lambda関数のデッドレターキュー
resource "aws_sqs_queue" "lambda_dlq" {
  name                       = "get_prices_dlq"
  message_retention_seconds  = 1209600 # 14日間
  visibility_timeout_seconds = 300     # 5分

  tags = {
    Name        = "get_prices_dlq"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# Lambda関数の自動スケーリング設定
resource "aws_appautoscaling_target" "lambda_target" {
  max_capacity       = 10
  min_capacity       = 2
  resource_id        = "function:${aws_lambda_function.price_comparison.function_name}:${aws_lambda_alias.get_prices.name}"
  scalable_dimension = "lambda:function:ProvisionedConcurrency"
  service_namespace  = "lambda"
}

resource "aws_appautoscaling_policy" "lambda_scaling_policy" {
  name               = "lambda-scaling-policy"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.lambda_target.resource_id
  scalable_dimension = aws_appautoscaling_target.lambda_target.scalable_dimension
  service_namespace  = aws_appautoscaling_target.lambda_target.service_namespace

  target_tracking_scaling_policy_configuration {
    target_value       = 0.7  # 70%の使用率を目標に
    scale_in_cooldown  = 300
    scale_out_cooldown = 300

    predefined_metric_specification {
      predefined_metric_type = "LambdaProvisionedConcurrencyUtilization"
    }
  }
}

# デプロイメント検証用のLambda関数
resource "aws_lambda_function" "deployment_verification" {
  filename      = "deployment_verification.zip"
  function_name = "deployment-verification"
  role          = aws_iam_role.deployment_verification.arn
  handler       = "verify_deployment.lambda_handler"
  runtime       = "python3.9"
  timeout       = 300
  memory_size   = 128

  environment {
    variables = {
      LAMBDA_FUNCTION_NAME = aws_lambda_function.price_comparison.function_name
      DYNAMODB_TABLES      = jsonencode([aws_dynamodb_table.iphone_prices.name, aws_dynamodb_table.official_prices.name])
      API_ID               = aws_api_gateway_rest_api.price_comparison.id
      ENVIRONMENT          = "production"
    }
  }

  tags = {
    Name        = "deployment-verification"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# スモークテスト用のLambda関数
resource "aws_lambda_function" "smoke_test" {
  filename      = "smoke_test.zip"
  function_name = "smoke-test"
  role          = aws_iam_role.smoke_test.arn
  handler       = "run_smoke_tests.lambda_handler"
  runtime       = "python3.9"
  timeout       = 300
  memory_size   = 128

  environment {
    variables = {
      LAMBDA_FUNCTION_NAME = aws_lambda_function.price_comparison.function_name
      DYNAMODB_TABLES      = jsonencode([aws_dynamodb_table.iphone_prices.name, aws_dynamodb_table.official_prices.name])
      API_URL              = "https://${aws_api_gateway_rest_api.price_comparison.id}.execute-api.${data.aws_region.current.name}.amazonaws.com/production/prices"
      ENVIRONMENT          = "production"
    }
  }

  tags = {
    Name        = "smoke-test"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 価格履歴保存用のLambda関数
resource "aws_lambda_function" "save_price_history" {
  filename      = "save_price_history.zip"
  function_name = "save-price-history"
  role          = aws_iam_role.lambda_execution_role.arn
  handler       = "save_price_history.lambda_handler"
  runtime       = "python3.9"
  timeout       = 300
  memory_size   = 128

  environment {
    variables = {
      DYNAMODB_TABLE = aws_dynamodb_table.iphone_prices.name
      ENVIRONMENT    = "production"
    }
  }

  tags = {
    Name        = "save-price-history"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 価格履歴保存用のCloudWatchイベントルール
resource "aws_cloudwatch_event_rule" "save_price_history_schedule" {
  name                = "save-price-history-schedule"
  description         = "Schedule for saving price history"
  schedule_expression = "rate(1 hour)"

  tags = {
    Name        = "save-price-history-schedule"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 価格履歴保存用のCloudWatchイベントターゲット
resource "aws_cloudwatch_event_target" "save_price_history_target" {
  rule      = aws_cloudwatch_event_rule.save_price_history_schedule.name
  target_id = "SavePriceHistory"
  arn       = aws_lambda_function.save_price_history.arn
}

# 価格履歴保存用のLambdaパーミッション
resource "aws_lambda_permission" "allow_cloudwatch" {
  statement_id  = "AllowExecutionFromCloudWatch"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.save_price_history.function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.save_price_history_schedule.arn
}

# 価格履歴取得用のLambda関数
resource "aws_lambda_function" "get_price_history" {
  filename      = "get_price_history.zip"
  function_name = "get-price-history"
  role          = aws_iam_role.lambda_execution_role.arn
  handler       = "get_price_history.lambda_handler"
  runtime       = "python3.9"
  timeout       = 300
  memory_size   = 128

  environment {
    variables = {
      DYNAMODB_TABLE = aws_dynamodb_table.iphone_prices.name
      ENVIRONMENT    = "production"
    }
  }

  tags = {
    Name        = "get-price-history"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 価格予測用のLambda関数
resource "aws_lambda_function" "predict_prices_lambda" {
  filename         = "predict_prices_lambda.zip"
  function_name    = "predict-prices"
  role             = aws_iam_role.lambda_execution_role.arn
  handler          = "predict_prices.handler"
  runtime          = "python3.9"
  timeout          = 30
  memory_size      = 256
  source_code_hash = filebase64sha256("predict_prices_lambda.zip")
}

# 価格比較用のLambda関数
resource "aws_lambda_function" "compare_prices_lambda" {
  filename         = "compare_prices_lambda.zip"
  function_name    = "compare-prices"
  role             = aws_iam_role.lambda_execution_role.arn
  handler          = "compare_prices.handler"
  runtime          = "python3.9"
  timeout          = 30
  memory_size      = 256
  source_code_hash = filebase64sha256("compare_prices_lambda.zip")
}

# LINE通知用のLambda関数
resource "aws_lambda_function" "line_notification_lambda" {
  filename         = "line_notification_lambda.zip"
  function_name    = "line-notification"
  role             = aws_iam_role.lambda_execution_role.arn
  handler          = "line_notification.handler"
  runtime          = "python3.9"
  timeout          = 30
  memory_size      = 256
  source_code_hash = filebase64sha256("line_notification_lambda.zip")
}

# 価格チェック用のLambda関数
resource "aws_lambda_function" "check_prices_lambda" {
  filename      = "check_prices.zip"
  function_name = "check-prices"
  role          = aws_iam_role.lambda_execution_role.arn
  handler       = "check_prices.lambda_handler"
  runtime       = "python3.9"
  timeout       = 300
  memory_size   = 128

  environment {
    variables = {
      DYNAMODB_TABLE    = aws_dynamodb_table.iphone_prices.name
      LINE_NOTIFY_TOKEN = var.line_notify_token
      ENVIRONMENT      = "production"
    }
  }

  tags = {
    Name        = "check-prices"
    Environment = "production"
    Project     = "iphone_price_tracker"
    Service     = "price-check"
  }
}

# 価格チェック用のLambdaパーミッション
resource "aws_lambda_permission" "check_prices_lambda_permission" {
  statement_id  = "AllowExecutionFromCloudWatch"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.check_prices_lambda.function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.check_prices.arn
}
</file>

<file path="terraform/dynamodb.tf">
# DynamoDBテーブルのデータ管理
resource "aws_dynamodb_table_item" "iphone_prices_data" {
  count = var.create_sample_data ? 1 : 0

  table_name = aws_dynamodb_table.iphone_prices.name
  hash_key   = "series"
  range_key  = "capacity"

  item = jsonencode({
    series = {
      S = "iPhone 16"
    }
    capacity = {
      S = "128GB"
    }
    price = {
      N = "999"
    }
    timestamp = {
      S = timestamp()
    }
  })
}

# DynamoDBテーブルの定義
resource "aws_dynamodb_table" "iphone_prices" {
  name           = "iphone_prices"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "series"
  range_key      = "capacity"

  attribute {
    name = "series"
    type = "S"
  }

  attribute {
    name = "capacity"
    type = "S"
  }

  global_secondary_index {
    name            = "CapacityIndex"
    hash_key        = "series"
    range_key       = "capacity"
    projection_type = "ALL"
  }

  point_in_time_recovery {
    enabled = true
  }

  lifecycle {
    ignore_changes = [
      read_capacity,
      write_capacity,
      billing_mode
    ]
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "iphone_prices"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_dynamodb_table" "official_prices" {
  name           = "official_prices"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "series"
  range_key      = "capacity"

  attribute {
    name = "series"
    type = "S"
  }

  attribute {
    name = "capacity"
    type = "S"
  }

  global_secondary_index {
    name            = "CapacityIndex"
    hash_key        = "series"
    range_key       = "capacity"
    projection_type = "ALL"
  }

  point_in_time_recovery {
    enabled = true
  }

  lifecycle {
    ignore_changes = [
      read_capacity,
      write_capacity,
      billing_mode
    ]
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "official_prices"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 価格情報を格納するメインテーブル
resource "aws_dynamodb_table" "price_comparison" {
  name           = "price-comparison"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "id"
  stream_enabled = true
  stream_view_type = "NEW_AND_OLD_IMAGES"

  attribute {
    name = "id"
    type = "S"
  }

  server_side_encryption {
    enabled = true
    kms_key_arn = aws_kms_key.data_encryption.arn
  }

  replica {
    region_name = "ap-southeast-1"
    kms_key_arn = aws_kms_key.data_encryption_replica.arn
  }

  tags = {
    Name        = "price-comparison"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

# 公式価格データの登録
locals {
  official_prices = jsondecode(file("${path.module}/../data/official_prices.json"))

  flattened_prices = {
    for item in flatten([
      for series, models in local.official_prices : [
        for capacity, colors in models : {
          series   = series
          capacity = capacity
          colors   = colors
        }
      ]
    ]) : "${item.series}-${item.capacity}" => item
  }
}

resource "aws_dynamodb_table_item" "official_prices_data" {
  for_each = var.create_sample_data ? local.flattened_prices : {}

  table_name = aws_dynamodb_table.official_prices.name
  hash_key   = "series"
  range_key  = "capacity"

  item = jsonencode({
    series = {
      S = each.value.series
    }
    capacity = {
      S = each.value.capacity
    }
    colors = {
      M = {
        for color, price in each.value.colors : color => {
          S = tostring(price)  # 数値を文字列として保存
        }
      }
    }
    timestamp = {
      S = timestamp()
    }
  })
}

resource "aws_dynamodb_table" "price_history" {
  name           = "price_history"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "model"
  range_key      = "timestamp"

  attribute {
    name = "model"
    type = "S"
  }

  attribute {
    name = "timestamp"
    type = "N"
  }

  global_secondary_index {
    name            = "TimestampIndex"
    hash_key        = "model"
    range_key       = "timestamp"
    projection_type = "ALL"
  }

  ttl {
    attribute_name = "expiration_time"
    enabled        = true
  }

  lifecycle {
    ignore_changes = [
      read_capacity,
      write_capacity,
      billing_mode
    ]
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "price_history"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_dynamodb_table" "price_predictions" {
  name           = "price_predictions"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "series"
  range_key      = "timestamp"

  attribute {
    name = "series"
    type = "S"
  }

  attribute {
    name = "timestamp"
    type = "S"
  }

  lifecycle {
    ignore_changes = [
      read_capacity,
      write_capacity,
      billing_mode
    ]
    # prevent_destroy = true  # 一時的に無効化
  }

  tags = {
    Name        = "price_predictions"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}

resource "aws_dynamodb_table" "kaitori_prices" {
  name           = "kaitori_prices"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "series"
  range_key      = "capacity"

  attribute {
    name = "series"
    type = "S"
  }

  attribute {
    name = "capacity"
    type = "S"
  }

  attribute {
    name = "color"
    type = "S"
  }

  global_secondary_index {
    name               = "ColorIndex"
    hash_key           = "color"
    range_key          = "series"
    projection_type    = "ALL"
  }

  point_in_time_recovery {
    enabled = true
  }

  lifecycle {
    prevent_destroy = false
    ignore_changes = [
      read_capacity,
      write_capacity,
      billing_mode
    ]
  }

  tags = {
    Name        = "kaitori_prices"
    Environment = "production"
    Project     = "iphone_price_tracker"
  }
}
</file>

<file path="terraform/requirements.txt">
boto3==1.38.9
requests==2.32.3
line-bot-sdk==3.17.1
beautifulsoup4==4.13.4
flask==3.1.0
aiohttp==3.11.7
attrs==25.2.0
async-timeout==5.0.1
aiosignal==1.3.2
aiohappyeyeballs==2.6.1
</file>

<file path="requirements.txt">
boto3>=1.34.0
requests>=2.32.3,<3.0
urllib3>=2.0.5,<3.0
selenium>=4.16.0,<5.0
line-bot-sdk>=3.7.0
playwright==1.52.0
pytest==7.4.4
pytest-cov==6.1.1
pytest-mock==3.14.0
python-dotenv==1.1.0
beautifulsoup4==4.13.4
flask==3.1.0
gunicorn==23.0.0
</file>

</files>
